<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>xiejunyi Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="xiejunyi Blog">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;page&#x2F;2&#x2F;index.html">
<meta property="og:site_name" content="xiejunyi Blog">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="xiejunyi Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">xiejunyi Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-dwarf和符号化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/30/dwarf%E5%92%8C%E7%AC%A6%E5%8F%B7%E5%8C%96/" class="article-date">
  <time datetime="2018-09-30T08:21:07.000Z" itemprop="datePublished">2018-09-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/APM/">APM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/30/dwarf%E5%92%8C%E7%AC%A6%E5%8F%B7%E5%8C%96/">DWARF和符号化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="DWARF-格式简介"><a href="#DWARF-格式简介" class="headerlink" title="DWARF 格式简介"></a>DWARF 格式简介</h2><p>DWARF: 它是可执行程序与源代码关系的一个紧凑的表示.</p>
<p>大多数现代编程语言是块结构的：每个实体（例如，一个类定义或一个函数）被包含在另一个实体中。在一个C程序里，每个文件可能包含多个数据定义、多个变量定义，及多个函数。DWARF遵循这个模型，它也是块结构的。在DWARF里基本的描述项是调试信息项（DebuggingInformation Entry——DIE）。一个DIE有一个标签，它指明了这个DIE描述什么及一个填入了细节并进一步描述该项的属性列表。一个DIE（除了最顶层的）被一个父DIE包含（或者说拥有），并可能有兄弟DIE或子DIE。属性可能包含各种值：常量（比如一个函数名），变量（比如一个函数的起始地址），或对另一个DIE的引用（比如一个函数的返回值类型）。</p>
<h2 id="利用DWARF符号化"><a href="#利用DWARF符号化" class="headerlink" title="利用DWARF符号化"></a>利用DWARF符号化</h2><p>符号化地址，我们期望的结果是，获取地址对应的函数名称和调用行数等信息。DWARF调试格式中携带了大量信息，当然包括函数名称和地址。因此如果我们提供的调用地址能在函数中找到信息，优先使用DWARF中的符号信息进行符号化。</p>
<p>在 DWARF 中，这些信息主要由 DW_AT_subprogram 和 line table 承载。<br>我们只需要根据地址在 DWARF 文件中找到对应的 信息。</p>
<h3 id="函数名称"><a href="#函数名称" class="headerlink" title="函数名称"></a>函数名称</h3><p>DW_AT_Subprogram 中可以获取到的信息</p>
<p>很容易看到，Dwarf调试信息中精心设计了 函数信息的具体表示，我们可以获取名称和类型等重要的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1</span>$:    DW_TAG_unspecified_type</span><br><span class="line">           DW_AT_name(<span class="string">"void"</span>)</span><br><span class="line">           ...</span><br><span class="line"><span class="number">2</span>$     DW_TAG_base_type</span><br><span class="line">           DW_AT_name(<span class="string">"int"</span>)</span><br><span class="line">           ...</span><br><span class="line"><span class="number">3</span>$:    DW_TAG_class_type</span><br><span class="line">           DW_AT_name(<span class="string">"A"</span>)</span><br><span class="line">           ...</span><br><span class="line"><span class="number">4</span>$:        DW_TAG_pointer_type</span><br><span class="line">               DW_AT_type(reference to <span class="number">3</span>$)</span><br><span class="line">               ...</span><br><span class="line"><span class="number">5</span>$:        DW_TAG_const_type</span><br><span class="line">               DW_AT_type(reference to <span class="number">3</span>$)</span><br><span class="line">               ...</span><br><span class="line"><span class="number">6</span>$:        DW_TAG_pointer_type</span><br><span class="line">               DW_AT_type(reference to <span class="number">5</span>$)</span><br><span class="line">               ...</span><br><span class="line"><span class="number">7</span>$:        DW_TAG_subprogram</span><br><span class="line">               DW_AT_name(<span class="string">"func1"</span>)</span><br><span class="line">               DW_AT_type(reference to <span class="number">1</span>$)</span><br><span class="line">               DW_AT_object_pointer(reference to <span class="number">8</span>$)</span><br><span class="line">                   ! References a formal parameter in <span class="keyword">this</span> member function</span><br><span class="line">               ...</span><br><span class="line"><span class="number">8</span>$:            DW_TAG_formal_parameter</span><br><span class="line">                   DW_AT_artificial(<span class="literal">true</span>)</span><br><span class="line">                   DW_AT_name(<span class="string">"this"</span>)</span><br><span class="line">                   DW_AT_type(reference to <span class="number">4</span>$)</span><br><span class="line">                       ! Makes type of 'this' as 'A*' =&gt;</span><br><span class="line">                       ! func1 has <span class="keyword">not</span> been marked <span class="keyword">const</span> <span class="keyword">or</span> <span class="keyword">volatile</span></span><br><span class="line">                   DW_AT_location ...</span><br><span class="line">                   ...</span><br><span class="line"><span class="number">9</span>$:            DW_TAG_formal_parameter</span><br><span class="line">                   DW_AT_name(x1)</span><br><span class="line">                   DW_AT_type(reference to <span class="number">2</span>$)</span><br><span class="line">                   ...</span><br><span class="line"><span class="number">10</span>$:       DW_TAG_subprogram</span><br><span class="line">               DW_AT_name(<span class="string">"func2"</span>)</span><br><span class="line">               DW_AT_type(reference to <span class="number">1</span>$)</span><br><span class="line">               DW_AT_object_pointer(reference to <span class="number">11</span>$)</span><br><span class="line">                   ! References a formal parameter in <span class="keyword">this</span> member function</span><br><span class="line">               ...</span><br><span class="line"><span class="number">11</span>$:           DW_TAG_formal_parameter</span><br><span class="line">                   DW_AT_artificial(<span class="literal">true</span>)</span><br><span class="line">                   DW_AT_name(<span class="string">"this"</span>)</span><br><span class="line">                   DW_AT_type(reference to <span class="number">6</span>$)</span><br><span class="line">                       ! Makes type of 'this' as 'A const*' =&gt;</span><br><span class="line">                       ! func2 marked as <span class="keyword">const</span></span><br><span class="line">                   DW_AT_location ...</span><br><span class="line">                   ...</span><br><span class="line"><span class="number">12</span>$:       DW_TAG_subprogram</span><br><span class="line">               DW_AT_name(<span class="string">"func3"</span>)</span><br><span class="line">               DW_AT_type(reference to <span class="number">1</span>$)</span><br><span class="line">               ...</span><br><span class="line">                   ! No 'this' formal parameter =&gt; func3 is static</span><br><span class="line"><span class="number">13</span>$:           DW_TAG_formal_parameter</span><br><span class="line">                   DW_AT_name(x3)</span><br><span class="line">                   DW_AT_type(reference to <span class="number">2</span>$)</span><br><span class="line">                   ...</span><br></pre></td></tr></table></figure>


<h3 id="内联函数处理"><a href="#内联函数处理" class="headerlink" title="内联函数处理"></a>内联函数处理</h3><p>对于内联函数，编译器会将其在多处展开。可以通过 DW_AT_inline 标志判断其展开的状态和判断其是否是”abstract instance entry”.<br>基于存储空间的考虑，把 某个内联函数构造成 “abstract instance entry” 提供名称等信息，可以避免多个具体内联函数展开的重复空间消耗。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">       ! Abstract instance <span class="keyword">for</span> OUTER</span><br><span class="line">        !</span><br><span class="line">OUTER.AI<span class="number">.1</span><span class="number">.1</span>:</span><br><span class="line">        DW_TAG_subprogram</span><br><span class="line">            DW_AT_name(<span class="string">"OUTER"</span>)</span><br><span class="line">            DW_AT_inline(DW_INL_declared_inlined)</span><br><span class="line">            ! No low/high PCs</span><br><span class="line">OUTER.AI<span class="number">.1</span><span class="number">.2</span>:</span><br><span class="line">            DW_TAG_formal_parameter</span><br><span class="line">                DW_AT_name(<span class="string">"OUTER_FORMAL"</span>)</span><br><span class="line">                DW_AT_type(reference to integer)</span><br><span class="line">                ! No location</span><br><span class="line">OUTER.AI<span class="number">.1</span><span class="number">.3</span>:</span><br><span class="line">            DW_TAG_variable</span><br><span class="line">                DW_AT_name(<span class="string">"OUTER_LOCAL"</span>)</span><br><span class="line">                DW_AT_type(reference to integer)</span><br><span class="line">                ! No location</span><br><span class="line">            !</span><br><span class="line">            ! Abstract instance <span class="keyword">for</span> INNER</span><br><span class="line">            !</span><br><span class="line">INNER.AI<span class="number">.1</span><span class="number">.1</span>:</span><br><span class="line">            DW_TAG_subprogram</span><br><span class="line">                DW_AT_name(<span class="string">"INNER"</span>)</span><br><span class="line">                DW_AT_inline(DW_INL_declared_inlined)</span><br><span class="line">                ! No low/high PCs</span><br><span class="line">INNER.AI<span class="number">.1</span><span class="number">.2</span>:   DW_TAG_formal_parameter</span><br><span class="line">                    DW_AT_name(<span class="string">"INNER_FORMAL"</span>)</span><br><span class="line">                    DW_AT_type(reference to integer)</span><br><span class="line">                    ! No location</span><br><span class="line">INNER.AI<span class="number">.1</span><span class="number">.3</span>:   DW_TAG_variable</span><br><span class="line">                    DW_AT_name(<span class="string">"INNER_LOCAL"</span>)</span><br><span class="line">                    DW_AT_type(reference to integer)</span><br><span class="line">                    ! No location</span><br><span class="line">                ...</span><br><span class="line">                <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            ! <span class="function">No <span class="title">DW_TAG_inlined_subroutine</span> <span class="params">(concrete instance)</span></span></span><br><span class="line">      ! for INNER corresponding to calls of INNER</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Figure <span class="number">66.</span> Inlining example #<span class="number">1</span>: abstract instance</span><br></pre></td></tr></table></figure>

<p><strong>concrete instance</strong> 表示编译时，某处内联函数的展开。它最主要的信息就是 DW_AT_low_pc,DW_AT_high_pc 通过pc地址信息，我们可以将函数调用地址定位到具体的DWARF debug entry。<br>由于存在 “abstract instance”，”concrete instance” 的某些属性会被省略，因此我们需要通过 DW_AT_abstract_origin 属性去找到对应的 abstract instance entry，获取被省略掉的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">        ! Concrete instance <span class="keyword">for</span> call <span class="string">"OUTER(7)"</span></span><br><span class="line">  !</span><br><span class="line">OUTER.CI<span class="number">.1</span><span class="number">.1</span>:</span><br><span class="line">        DW_TAG_inlined_subroutine</span><br><span class="line">            ! No name</span><br><span class="line">            DW_AT_abstract_origin(reference to OUTER.AI<span class="number">.1</span><span class="number">.1</span>)</span><br><span class="line">            DW_AT_low_pc(...)</span><br><span class="line">            DW_AT_high_pc(...)</span><br><span class="line">OUTER.CI<span class="number">.1</span><span class="number">.2</span>:</span><br><span class="line">            DW_TAG_formal_parameter</span><br><span class="line">                ! No name</span><br><span class="line">                DW_AT_abstract_origin(reference to OUTER.AI<span class="number">.1</span><span class="number">.2</span>)</span><br><span class="line">    DW_AT_const_value(<span class="number">7</span>)</span><br><span class="line">OUTER.CI<span class="number">.1</span><span class="number">.3</span>:</span><br><span class="line">            DW_TAG_variable</span><br><span class="line">                ! No name</span><br><span class="line">                DW_AT_abstract_origin(reference to OUTER.AI<span class="number">.1</span><span class="number">.3</span>)</span><br><span class="line">                DW_AT_location(...)</span><br><span class="line">            !</span><br><span class="line">            ! <span class="function">No <span class="title">DW_TAG_subprogram</span> <span class="params">(abstract instance)</span> <span class="keyword">for</span> INNER</span></span><br><span class="line">            !</span><br><span class="line">            ! <span class="function">Concrete instance <span class="keyword">for</span> call <span class="title">INNER</span><span class="params">(OUTER_LOCAL)</span></span></span><br><span class="line">            ! </span><br><span class="line">INNER.CI<span class="number">.1</span><span class="number">.1</span>:</span><br><span class="line">            DW_TAG_inlined_subroutine</span><br><span class="line">                ! No name</span><br><span class="line">                DW_AT_abstract_origin(reference to INNER.AI<span class="number">.1</span><span class="number">.1</span>)</span><br><span class="line">                DW_AT_low_pc(...)</span><br><span class="line">                DW_AT_high_pc(...)</span><br><span class="line">                DW_AT_static_link(...)</span><br><span class="line">INNER.CI<span class="number">.1</span><span class="number">.2</span>:   DW_TAG_formal_parameter</span><br><span class="line">                    ! No name</span><br><span class="line">                    DW_AT_abstract_origin(reference to INNER.AI<span class="number">.1</span><span class="number">.2</span>)</span><br><span class="line">                    DW_AT_location(...)</span><br><span class="line">INNER.CI<span class="number">.1</span><span class="number">.3</span>:   DW_TAG_variable</span><br><span class="line">                    ! No name</span><br><span class="line">                    DW_AT_abstract_origin(reference to INNER.AI<span class="number">.1</span><span class="number">.3</span>)</span><br><span class="line">                    DW_AT_location(...)</span><br><span class="line">                ...</span><br><span class="line">                <span class="number">0</span></span><br><span class="line"></span><br><span class="line">      ! Another concrete instance of INNER within OUTER</span><br><span class="line">      ! <span class="keyword">for</span> the call <span class="string">"INNER(31)"</span></span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="非定义调试信息项处理"><a href="#非定义调试信息项处理" class="headerlink" title="非定义调试信息项处理"></a>非定义调试信息项处理</h3><p>当函数定义并不在声明区域时，subprogram DIE 就会有 DW_AT_specification 属性，指向相关的函数定义DIE.<br>对于带有 DW_AT_specification 的调试信息项，我们需要进行特殊处理。</p>
<h3 id="定位地址对应Dwarf-debug-info"><a href="#定位地址对应Dwarf-debug-info" class="headerlink" title="定位地址对应Dwarf debug info"></a>定位地址对应Dwarf debug info</h3><p>backtrace() 我们可以拿到 image 的 loadaddress 和 address调用地址。</p>
<p>进而得到文件虚拟地址<br>fileVmAddress = address - (loadaddress - imageFileVmTextAddress)</p>
<p>通过文件虚拟地址后通过 .debug_aranges 查找到指定的 DWARF compile unit，进而查找到具体的DIE. 从属性中获取我们需要的信息。</p>
<p>.debug_aranges 是DWARF 中包含 debug info entry offset的 Section。<br>DWARF compile unit 是编译单元，在这里我们可以理解为文件或文件中的片段。也是DIE</p>
<h3 id="行号信息"><a href="#行号信息" class="headerlink" title="行号信息"></a>行号信息</h3><p>对于一个文件，我们将其编译后，其产出汇编代码类似于这种形式，在原始文件中的行对应着多条汇编指令。<br>对于行号的查找我们只需要 将符号的运行时地址转换为文件的虚拟地址，在该文件的行号信息中进行范围查找即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: <span class="keyword">int</span></span><br><span class="line"><span class="number">2</span>: main()</span><br><span class="line">    <span class="number">0x239</span>: push pb</span><br><span class="line">    <span class="number">0x23a</span>: mov  bp,sp</span><br><span class="line"><span class="number">3</span>:  &#123;</span><br><span class="line"><span class="number">4</span>:  <span class="built_in">printf</span>(“Omit needless words\n”);</span><br><span class="line">    <span class="number">0x23c</span>: mov  ax,<span class="number">0xaa</span></span><br><span class="line">    <span class="number">0x23f</span>: push ax</span><br><span class="line">    <span class="number">0x240</span>: call _printf</span><br><span class="line">    <span class="number">0x243</span>: pop  cx</span><br><span class="line"><span class="number">5</span>:  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="number">0x244</span>: xor  ax,ax</span><br><span class="line">    <span class="number">0x246</span>: push ax</span><br><span class="line">    <span class="number">0x247</span>: call _exit</span><br><span class="line">    <span class="number">0x24a</span>: pop  cx</span><br><span class="line"><span class="number">6</span>:  &#125;</span><br><span class="line">    <span class="number">0x24b</span>: pop  bp</span><br><span class="line">    <span class="number">0x24c</span>: ret</span><br><span class="line"><span class="number">7</span>:</span><br><span class="line">    <span class="number">0x24d</span>:</span><br></pre></td></tr></table></figure>

<p>对应的编码类似于: SPECIAL(n,m) 制定了行号增加和地址增加</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Opcode  Operand Byte <span class="built_in">Stream</span></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">DW_LNS_advance_pc LEB128(0x239) 0x2, 0xb9, 0x04</span><br><span class="line">SPECIAL(<span class="number">2</span>, <span class="number">0</span>)   <span class="number">0xb</span></span><br><span class="line">SPECIAL(<span class="number">2</span>, <span class="number">3</span>)   <span class="number">0x38</span></span><br><span class="line">SPECIAL(<span class="number">1</span>, <span class="number">8</span>)   <span class="number">0x82</span></span><br><span class="line">SPECIAL(<span class="number">1</span>, <span class="number">7</span>)   <span class="number">0x73</span></span><br><span class="line">DW_LNS_advance_pc   LEB128(2) 0x2, 0x2</span><br><span class="line">DW_LNE_end_sequence   <span class="number">0x0</span>, <span class="number">0x1</span>, <span class="number">0x1</span></span><br></pre></td></tr></table></figure>

<h2 id="利用symtab符号化"><a href="#利用symtab符号化" class="headerlink" title="利用symtab符号化"></a>利用symtab符号化</h2><p>当我们代码编译的时候，可以选择产生调试信息。也可以不产生调试信息，作为降级方案，我们仍可采用symbtab所包含的信息进行符号化。<br>symtab段我们可以提取到具体符号的地址，对应字符串表中的偏移地址，很容易就取到对应的符号名称。</p>
<p>具体可以参考各种实现，这里贴一段fishhook里的代码段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rebind_symbols_for_image</span><span class="params">(struct rebindings_entry *rebindings,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">const</span> struct mach_header *header,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">intptr_t</span> slide)</span> </span>&#123;</span><br><span class="line">  Dl_info info;</span><br><span class="line">  <span class="keyword">if</span> (dladdr(header, &amp;info) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"dli_fname:%s \ndli_sname:%s"</span>, info.dli_fname, info.dli_sname);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">segment_command_t</span> *cur_seg_cmd;</span><br><span class="line">  <span class="keyword">segment_command_t</span> *linkedit_segment = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">symtab_command</span>* <span class="title">symtab_cmd</span> = <span class="title">NULL</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dysymtab_command</span>* <span class="title">dysymtab_cmd</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">uintptr_t</span> cur = (<span class="keyword">uintptr_t</span>)header + <span class="keyword">sizeof</span>(<span class="keyword">mach_header_t</span>);</span><br><span class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123;</span><br><span class="line">    cur_seg_cmd = (<span class="keyword">segment_command_t</span> *)cur;</span><br><span class="line">    <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cur_seg_cmd-&gt;segname, SEG_LINKEDIT) == <span class="number">0</span>) &#123;</span><br><span class="line">        linkedit_segment = cur_seg_cmd;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SYMTAB) &#123;</span><br><span class="line">      symtab_cmd = (struct symtab_command*)cur_seg_cmd;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_DYSYMTAB) &#123;</span><br><span class="line">      dysymtab_cmd = (struct dysymtab_command*)cur_seg_cmd;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!symtab_cmd || !dysymtab_cmd || !linkedit_segment ||</span><br><span class="line">      !dysymtab_cmd-&gt;nindirectsyms) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find base symbol/string table addresses</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> linkedit_base = (<span class="keyword">uintptr_t</span>)slide + linkedit_segment-&gt;vmaddr - linkedit_segment-&gt;fileoff;</span><br><span class="line">  <span class="keyword">nlist_t</span> *symtab = (<span class="keyword">nlist_t</span> *)(linkedit_base + symtab_cmd-&gt;symoff);</span><br><span class="line">  <span class="keyword">char</span> *strtab = (<span class="keyword">char</span> *)(linkedit_base + symtab_cmd-&gt;stroff);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get indirect symbol table (array of uint32_t indices into symbol table)</span></span><br><span class="line">  <span class="keyword">uint32_t</span> *indirect_symtab = (<span class="keyword">uint32_t</span> *)(linkedit_base + dysymtab_cmd-&gt;indirectsymoff);</span><br><span class="line"></span><br><span class="line">  cur = (<span class="keyword">uintptr_t</span>)header + <span class="keyword">sizeof</span>(<span class="keyword">mach_header_t</span>);</span><br><span class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123;</span><br><span class="line">    cur_seg_cmd = (<span class="keyword">segment_command_t</span> *)cur;</span><br><span class="line">    <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cur_seg_cmd-&gt;segname, SEG_DATA) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">          <span class="built_in">strcmp</span>(cur_seg_cmd-&gt;segname, SEG_DATA_CONST) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; cur_seg_cmd-&gt;nsects; j++) &#123;</span><br><span class="line">        <span class="keyword">section_t</span> *sect =</span><br><span class="line">          (<span class="keyword">section_t</span> *)(cur + <span class="keyword">sizeof</span>(<span class="keyword">segment_command_t</span>)) + j;</span><br><span class="line">        <span class="keyword">if</span> ((sect-&gt;flags &amp; SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS) &#123;</span><br><span class="line">          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((sect-&gt;flags &amp; SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS) &#123;</span><br><span class="line">          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>符号化工具提供了 将函数地址 转化为 具体名称等信息的能力。但是提供大规模的符号化能力，需要在 网络I/O,缓存,Server端进一步的优化，这些优化我会写在内网Wiki上 hhhhh…</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>符号化仅是DWARF提供能力的冰山一角，作为提供给 lldb, gdb等调试器的文件格式，蕴含着大量的信息，也就是说，上传了DWARF文件，也相当于应用裸奔了…</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/30/dwarf%E5%92%8C%E7%AC%A6%E5%8F%B7%E5%8C%96/" data-id="ck8hkauuo000totjh0hyi8vek" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CrashSymbolicateSystemDesign" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/16/CrashSymbolicateSystemDesign/" class="article-date">
  <time datetime="2018-09-16T14:36:27.000Z" itemprop="datePublished">2018-09-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/APM/">APM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/16/CrashSymbolicateSystemDesign/">APM Crash系统</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><img src="design.png" alt="design"></p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><ol>
<li>Crash/OOM/ANR 抓取</li>
<li>上报日志格式</li>
</ol>
<h3 id="Crash-OOM-卡顿-抓取"><a href="#Crash-OOM-卡顿-抓取" class="headerlink" title="Crash/OOM/卡顿 抓取"></a>Crash/OOM/卡顿 抓取</h3><p>这块技术有很多的开源方案，</p>
<p>Crash抓取有 KSCrash PLCrash…<br>OOM 可以参考腾讯的OOMDetector自己优化一下<br>ANR 可以参考很多方案，这里就不细说了</p>
<h3 id="日志上报格式"><a href="#日志上报格式" class="headerlink" title="日志上报格式"></a>日志上报格式</h3><p>上报的日志我认为最好兼容苹果的 symbolicatecrash 工具, 这就需要我们去理解 symbolicate 工作的原理，随后我们可以加上自己的内容，方便自己进行更多的功能扩展。</p>
<h4 id="symbolicatecrash-的原理"><a href="#symbolicatecrash-的原理" class="headerlink" title="symbolicatecrash 的原理"></a><strong>symbolicatecrash</strong> 的原理</h4><ol>
<li>解析头部信息是否符合规范</li>
<li>解析堆栈信息，符号表 信息</li>
<li>在文件中查找符号表的路径</li>
<li>根据堆栈信息去匹配相应符号表</li>
<li>使用atosl工具进行符号化</li>
<li>文本替换成符号化后的日志</li>
</ol>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><ol>
<li>符号化和解析服务</li>
<li>堆栈聚合服务</li>
<li>符号文件管理系统</li>
</ol>
<h3 id="符号化和解析服务"><a href="#符号化和解析服务" class="headerlink" title="符号化和解析服务"></a>符号化和解析服务</h3><p>我们可以把这块看成两个部分，1符号化，2解析服务</p>
<h4 id="符号化"><a href="#符号化" class="headerlink" title="符号化"></a>符号化</h4><p>符号化就是把地址翻译成对应的符号信息，比如说 把堆栈调用的地址 翻译成 调用方法的名称。<br>苹果给我们在 MacOS 下提供了 atosl 工具，可以帮助我们完成这部分工作。但是这个工具仅仅可以在MacOS 下工作，对于大规模的用户日志来说，依赖于MacOS系统不容易部署维护，费用也十分昂贵，因此我们需要在Linux下实现一个相等功能的工具。</p>
<h4 id="解析服务"><a href="#解析服务" class="headerlink" title="解析服务"></a>解析服务</h4><p>由于我们的日志是文本格式，我们需要提取其中的信息才可以将其用作符号化工具的输入，可以通过正则匹配的方式去处理这些信息。</p>
<h2 id="工具实现"><a href="#工具实现" class="headerlink" title="工具实现"></a>工具实现</h2><ol>
<li>Linux 平台下可用的符号化工具</li>
</ol>
<h3 id="Linux-平台下可用的符号化工具"><a href="#Linux-平台下可用的符号化工具" class="headerlink" title="Linux 平台下可用的符号化工具"></a>Linux 平台下可用的符号化工具</h3><p>总体来说，iOS符号化我们需要了解两部分知识， 1 Dwarf调试格式 2 Macho文件格式</p>
<h4 id="Dwarf调试格式"><a href="#Dwarf调试格式" class="headerlink" title="Dwarf调试格式"></a>Dwarf调试格式</h4><p>我们经常可以接触到的dsym文件是一个目录，其中包含了一个格式为Dwarf的调试信息文件。<br>调试信息是在编译器生成机器码的时候一起产生的。它代表着可执行程序和源代码之间的关系。这个信息以预定义的格式进行编码，并同机器码一起存储。<br>在DWARF里基本的描述项是调试信息项（DebuggingInformation Entry——DIE）。一个DIE有一个标签，它指明了这个DIE描述什么及一个填入了细节并进一步描述该项的属性列表。一个DIE（除了最顶层的）被一个父DIE包含（或者说拥有），并可能有兄弟DIE或子DIE。<br>通过提取Dwarf文件中的调试信息和对应的堆栈进行匹配，就可以解出一些符号信息，包含调用行号文件名称等信息。</p>
<h5 id="需要注意的一些知识点"><a href="#需要注意的一些知识点" class="headerlink" title="需要注意的一些知识点"></a>需要注意的一些知识点</h5><p><strong>DW_AT_abstract_origin， DW_AT_specification</strong></p>
<blockquote>
<p>A debugging information entry that represents a declaration that<br>completes another (earlier) non-defining declaration may have a<br>DW_AT_specification attribute whose value is a reference to the<br>debugging information entry representing the non-defining declaration.<br>A debugging information entry with a DW_AT_specification attribute<br>does not need to duplicate information provided by the debugging<br>information entry referenced by that specification attribute.<br>A DW_TAG_subprogram entry can contain a reference to a DW_AT_abstract_origin entry instead of &gt; duplicating the information. </p>
</blockquote>
<p>这意味着 我们需要针对 DW_AT_abstract_origin 进行特别处理</p>
<h4 id="Macho-文件格式"><a href="#Macho-文件格式" class="headerlink" title="Macho 文件格式"></a>Macho 文件格式</h4><p>上文中提到的符号文件，是Macho文件格式的。<br>Macho文件中包含 SymbolTable 可以提取出符号的名称，对于系统库和外部符号（例如你的静态库中的符号），我们可以从SymbolTable中提取符号名称。</p>
<h3 id="堆栈聚合服务"><a href="#堆栈聚合服务" class="headerlink" title="堆栈聚合服务"></a>堆栈聚合服务</h3><p>因为导致用户Crash的问题大多是相同的，导致用户Crash的堆栈存在许多相似和相等的情况，我们需要把同一类堆栈聚合在一起，协助平台用户高效的解决问题。</p>
<h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><p>接下来我会逐渐介绍这整套系统的设计和相关技术实现。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/16/CrashSymbolicateSystemDesign/" data-id="ck8hkauub0007otjh4g564jbv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-libmalloc" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/13/libmalloc/" class="article-date">
  <time datetime="2018-06-13T12:52:38.000Z" itemprop="datePublished">2018-06-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/APM/">APM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/13/libmalloc/">libmalloc &#34;malloc&#34; 探究</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前腾讯开源了 <a href="https://github.com/Tencent/OOMDetector" target="_blank" rel="noopener">OOMDetector</a> 用于监控内存分配，在集成到我司项目时, 修复了一些bug崩溃，优化了性能，在内存不是频繁分配的App上是有用武之地的。</p>
<p>OOMDetector 监控内存分配的核心处理 是通过 libmalloc库 中的 malloc_logger 指针实现的。</p>
<p>我之前一直疑惑 OOMDetector 的监控方式是否能够完善的监控到应用层面的<code>&quot;malloc&quot;</code>内存分配。这就有必要探究下应用层的内存分配API</p>
<h2 id="iOS-“malloc”-内存分配"><a href="#iOS-“malloc”-内存分配" class="headerlink" title="iOS “malloc” 内存分配"></a>iOS “malloc” 内存分配</h2><p>iOS上都通过kernel进行内存分配，将虚拟内存页映射到应用内存空间上。我们在应用层可以通过mmap实现这种内存分配。</p>
<p>不过大多数情况下我们都通过<strong>“malloc”</strong>进行内存分配, 我们可以使用malloc来获取内存，而不用每次都请求vmpage映射。而malloc分配的内存实质上都是从vmpage映射获取的。</p>
<p>你一定注意到了 <strong>“malloc”</strong>, 是的，它代表calloc, realloc, valloc, malloc_zone_malloc, malloc_zone_calloc, malloc_zone_valloc, malloc_zone_realloc, malloc_zone_batch_malloc 等方法，本质上他们的分配都应该被归于一类，都是利用 <code>scalable_zone</code> 进行分配的。</p>
<p>顺便提一下，C++ new的分配 其实现也是用 libc 中的 malloc 进行分配的<br><a href="http://gcc.gnu.org/viewcvs/gcc/trunk/libstdc++-v3/libsupc++/new_opnt.cc?view=markup" target="_blank" rel="noopener">new_opnt.cc</a></p>
<h3 id="libmalloc-分析"><a href="#libmalloc-分析" class="headerlink" title="libmalloc 分析"></a>libmalloc 分析</h3><h3 id="default-zone"><a href="#default-zone" class="headerlink" title="default_zone"></a>default_zone</h3><p>本着质疑的精神，一般我是不会相信空口无凭的文章的，因此，可以从<code>libmalloc</code>中找到答案。</p>
<p>首先找到 malloc, calloc等函数.. 的实现，因为原理类似，就不一一举出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line"><span class="built_in">malloc</span>(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span> *retval;</span><br><span class="line">	retval = malloc_zone_malloc(default_zone, <span class="built_in">size</span>);</span><br><span class="line">	<span class="keyword">if</span> (retval == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		errno = ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line"><span class="built_in">calloc</span>(<span class="keyword">size_t</span> num_items, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span> *retval;</span><br><span class="line">	retval = malloc_zone_calloc(default_zone, num_items, <span class="built_in">size</span>);</span><br><span class="line">	<span class="keyword">if</span> (retval == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		errno = ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先来看看这个 <code>default_zone</code> 是什么东西, 代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">malloc_zone_t</span> malloc_zone;</span><br><span class="line">	<span class="keyword">uint8_t</span> pad[PAGE_MAX_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">malloc_zone_t</span>)];</span><br><span class="line">&#125; <span class="keyword">virtual_default_zone_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">virtual_default_zone_t</span> virtual_default_zone</span><br><span class="line">__attribute__((section(<span class="string">"__DATA,__v_zone"</span>)))</span><br><span class="line">__attribute__((aligned(PAGE_MAX_SIZE))) = &#123;</span><br><span class="line">	<span class="literal">NULL</span>,</span><br><span class="line">	<span class="literal">NULL</span>,</span><br><span class="line">	default_zone_size,</span><br><span class="line">	default_zone_malloc,</span><br><span class="line">	default_zone_calloc,</span><br><span class="line">	default_zone_valloc,</span><br><span class="line">	default_zone_free,</span><br><span class="line">	default_zone_realloc,</span><br><span class="line">	default_zone_destroy,</span><br><span class="line">	DEFAULT_MALLOC_ZONE_STRING,</span><br><span class="line">	default_zone_batch_malloc,</span><br><span class="line">	default_zone_batch_free,</span><br><span class="line">	&amp;default_zone_introspect,</span><br><span class="line">	<span class="number">9</span>,</span><br><span class="line">	default_zone_memalign,</span><br><span class="line">	default_zone_free_definite_size,</span><br><span class="line">	default_zone_pressure_relief</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">malloc_zone_t</span> *default_zone = &amp;virtual_default_zone.malloc_zone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">default_zone_malloc(<span class="keyword">malloc_zone_t</span> *zone, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span><br><span class="line">&#123;</span><br><span class="line">	zone = runtime_default_zone();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> zone-&gt;<span class="built_in">malloc</span>(zone, <span class="built_in">size</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MALLOC_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">malloc_zone_t</span> *</span><br><span class="line">runtime_default_zone() &#123;</span><br><span class="line">	<span class="keyword">return</span> (lite_zone) ? lite_zone : inline_malloc_default_zone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>default_zone</code> 通过这种方式来初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">malloc_zone_t</span> *</span><br><span class="line">inline_malloc_default_zone(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	_malloc_initialize_once();</span><br><span class="line">	<span class="comment">// _malloc_printf(ASL_LEVEL_INFO, "In inline_malloc_default_zone with %d %d\n", malloc_num_zones, malloc_has_debug_zone);</span></span><br><span class="line">	<span class="keyword">return</span> malloc_zones[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>随后的调用如下</strong><br><code>_malloc_initialize</code> -&gt; <code>create_scalable_zone</code> -&gt; <code>create_scalable_szone</code> 最终我们创建了 szone_t 类型的对象，通过类型转换，得到了我们的 default_zone。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">malloc_zone_t</span> *</span><br><span class="line">create_scalable_zone(<span class="keyword">size_t</span> initial_size, <span class="keyword">unsigned</span> debug_flags) &#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">malloc_zone_t</span> *) create_scalable_szone(initial_size, debug_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="“malloc”"><a href="#“malloc”" class="headerlink" title="“malloc”"></a>“malloc”</h3><p>上文代码段中写道<code>malloc</code> 中调用了 <code>malloc_zone_malloc</code>, 看看malloc_zone_malloc 的实现是什么</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">malloc_zone_malloc(<span class="keyword">malloc_zone_t</span> *zone, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span><br><span class="line">&#123;</span><br><span class="line">	MALLOC_TRACE(TRACE_malloc | DBG_FUNC_START, (<span class="keyword">uintptr_t</span>)zone, <span class="built_in">size</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> *ptr;</span><br><span class="line">	<span class="keyword">if</span> (malloc_check_start &amp;&amp; (malloc_check_counter++ &gt;= malloc_check_start)) &#123;</span><br><span class="line">		internal_check();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">size</span> &gt; MALLOC_ABSOLUTE_MAX_SIZE) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ptr = zone-&gt;<span class="built_in">malloc</span>(zone, <span class="built_in">size</span>);		<span class="comment">// if lite zone is passed in then we still call the lite methods</span></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (malloc_logger) &#123;</span><br><span class="line">		malloc_logger(MALLOC_LOG_TYPE_ALLOCATE | MALLOC_LOG_TYPE_HAS_ZONE, (<span class="keyword">uintptr_t</span>)zone, (<span class="keyword">uintptr_t</span>)<span class="built_in">size</span>, <span class="number">0</span>, (<span class="keyword">uintptr_t</span>)ptr, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	MALLOC_TRACE(TRACE_malloc | DBG_FUNC_END, (<span class="keyword">uintptr_t</span>)zone, <span class="built_in">size</span>, (<span class="keyword">uintptr_t</span>)ptr, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其分配实现是 <code>zone-&gt;malloc</code> 根据之前的分析，就是szone_t结构体对象中对应的malloc实现。</p>
<p>在创建szone之后，做了一系列如下的初始化操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize the security token.</span></span><br><span class="line">szone-&gt;cookie = (<span class="keyword">uintptr_t</span>)malloc_entropy[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">szone-&gt;basic_zone.version = <span class="number">9</span>;</span><br><span class="line">szone-&gt;basic_zone.<span class="built_in">size</span> = (<span class="keyword">void</span> *)szone_size;</span><br><span class="line">szone-&gt;basic_zone.<span class="built_in">malloc</span> = (<span class="keyword">void</span> *)szone_malloc;</span><br><span class="line">szone-&gt;basic_zone.<span class="built_in">calloc</span> = (<span class="keyword">void</span> *)szone_calloc;</span><br><span class="line">szone-&gt;basic_zone.valloc = (<span class="keyword">void</span> *)szone_valloc;</span><br><span class="line">szone-&gt;basic_zone.<span class="built_in">free</span> = (<span class="keyword">void</span> *)szone_free;</span><br><span class="line">szone-&gt;basic_zone.<span class="built_in">realloc</span> = (<span class="keyword">void</span> *)szone_realloc;</span><br><span class="line">szone-&gt;basic_zone.destroy = (<span class="keyword">void</span> *)szone_destroy;</span><br><span class="line">szone-&gt;basic_zone.batch_malloc = (<span class="keyword">void</span> *)szone_batch_malloc;</span><br><span class="line">szone-&gt;basic_zone.batch_free = (<span class="keyword">void</span> *)szone_batch_free;</span><br><span class="line">szone-&gt;basic_zone.introspect = (struct <span class="keyword">malloc_introspection_t</span> *)&amp;szone_introspect;</span><br><span class="line">szone-&gt;basic_zone.memalign = (<span class="keyword">void</span> *)szone_memalign;</span><br><span class="line">szone-&gt;basic_zone.free_definite_size = (<span class="keyword">void</span> *)szone_free_definite_size;</span><br><span class="line">szone-&gt;basic_zone.pressure_relief = (<span class="keyword">void</span> *)szone_pressure_relief;</span><br></pre></td></tr></table></figure>

<p>在magazine_malloc.c有着对应的实现。</p>
<h3 id="malloc-logger"><a href="#malloc-logger" class="headerlink" title="malloc_logger"></a>malloc_logger</h3><p>malloc_logger 在 libmalloc 中的以下方法内被调用 <code>malloc_zone_malloc</code> <code>malloc_zone_calloc</code> <code>malloc_zone_valloc</code> <code>malloc_zone_realloc</code> <code>malloc_zone_free</code> <code>malloc_zone_free_definite_size</code> <code>malloc_zone_memalign</code> 等函数中被调用，我们 “malloc” 系列的方法都会调用到这些函数 </p>
<p>如果你使用 malloc_logger 回调，那么 “malloc” 分配你都可以监控到. OOMDetector 中也针对不同的分配做了不同的处理。因此使用malloc_logger回调是可以监控到 “malloc”分配的，验证了文章开头的猜测。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以malloc_logger为线索，探究了一下libmalloc的源码，确定了OOMDetector的原理。当然最重要的是建立对 iOS 内存分配的整体理解。 本文只写了对”malloc”内存分配的理解，以后有时间，会写一下 XNU内存管理相关的文章。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/13/libmalloc/" data-id="ck8hkauus0012otjhhcxgfwei" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-dependency" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/dependency/" class="article-date">
  <time datetime="2018-04-13T05:08:46.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/">设计架构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/dependency/">关于架构和编码的思考</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>长期更新，记录我对设计架构的理解</strong></p>
<h2 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h2><p>A,B,C三个组件，如果可以互相调用，则ABC互相依赖。在大型项目中，这种会造成组件间耦合紧密的问题。</p>
<h2 id="思考一下，组件间调用的本质"><a href="#思考一下，组件间调用的本质" class="headerlink" title="思考一下，组件间调用的本质"></a>思考一下，组件间调用的本质</h2><ol>
<li>有组件的实例</li>
<li>接口</li>
</ol>
<p><strong>拥有组件的实例</strong>，我们直接拥有另一个组件，这显然是依赖的。</p>
<p><strong>如何在尽量减少依赖的情况下解决这些问题呢？</strong></p>
<ol>
<li>可以通过反射的方式, 需要建立 {组件}&lt;-&gt;{字符串} 的映射表，把关系转移到了配置文件中，这种方式存在安全性问题，因为没有编译器的强类型检查。</li>
<li>建立映射关系。我们可以 建立Class和某种物件的映射， 因为有protocol的存在，接口的问题被解决了。于是建立Class和Protocol的映射，可以获得实例的同时也知晓接口。这就构成了一个组件调用的基础条件。并且我们需要一个manager替我们管理映射。</li>
</ol>
<p>在2中，依赖关系变成了如下<br>{组件}-&gt;{manager}-&gt;{interface}</p>
<p>组件的耦合转移到了组件和interface的耦合。这在工程维护中存在一个问题，我们需要维护一个庞大的protocol列表。不过相比于组件间相互依赖，这种做法好了很多。</p>
<h3 id="接口类映射-和-反射-的选择"><a href="#接口类映射-和-反射-的选择" class="headerlink" title="接口类映射 和 反射 的选择"></a>接口类映射 和 反射 的选择</h3><p>我个人愿意维护protocols，而不是维护组件字符串映射表。 从逻辑上说，无法实现双方相互隐藏。这无非是 “关系” 的体现方式不同。我选择程序内的映射关系，有编译器检查。</p>
<h2 id="依赖倒置"><a href="#依赖倒置" class="headerlink" title="依赖倒置"></a>依赖倒置</h2><p>传统的过程性系统的设计方法倾向于使高层次的模块依赖于低层次的模块，抽象层次依赖于具体层次。<br>而依赖倒置则将{高层次模块，低层次模块}-&gt;{抽象接口}，这样无论上层还是下层的整个模块出现了替换，只要接口不变化，就不需要修改另一层次的模块。</p>
<p><strong>这里值得注意的是，低层次模块依赖了高层次模块中定义的接口。当我们把低层次模块拆分后，将其用于别的项目时，会出现问题。对此我的想法是：</strong></p>
<ol>
<li>如果高层次模块需要和底层次模块完全隔离，方便的替换整个低层次模块的实现，那么使用依赖倒置。</li>
<li>如果没有1中的需求，那么还是直接依赖低层次模块，我认为低层次模块本身的接口暴露合理，内部实现的改动也不会对高层次模块有什么影响。</li>
</ol>
<h3 id="采用接口的成本"><a href="#采用接口的成本" class="headerlink" title="采用接口的成本"></a>采用接口的成本</h3><ol>
<li>接口定义，接口维护，遵循类维护</li>
<li>如果暴露了一些定义的数据结构、类，则这些也需要抽象。会造成很多重复的代码。<br>我觉得还是尽量只在必要情况下使用接口，</li>
</ol>
<ul>
<li>足够底层的类，可以放到核心库中。让所有模块都依赖呗。</li>
<li>接口适用于 同级别模块间的服务交互</li>
</ul>
<h3 id="包装一下"><a href="#包装一下" class="headerlink" title="包装一下"></a>包装一下</h3><p>我们使用高层模块时，其实就是构造一个符合接口的东西而已。<br>底层模块A去遵循高层模块的协议，无疑让底层模块无法复用。这时候我们可以再新建一个类C，让C去遵循协议，C通过A来构建自己。</p>
<h2 id="单一职责和关注点分离原则"><a href="#单一职责和关注点分离原则" class="headerlink" title="单一职责和关注点分离原则"></a>单一职责和关注点分离原则</h2><p><strong>关注点分离</strong>要求每一个功能对应一个单独的任务，每一个功能都要在一个独立的模块中实现。每个模块都有自己的职责，而不会关注其他模块的职责。如果一个类包含多个职责，要求改其中的一个职责，则可能会影响该类里其他职责的实现。<br><strong>单一职责原则</strong>要求每个类只包含一个职责，所有方法都应该为了实现该职责。要修改一个类的职责，只涉及该类。</p>
<h3 id="例子：Record和Log写在一起？"><a href="#例子：Record和Log写在一起？" class="headerlink" title="例子：Record和Log写在一起？"></a>例子：Record和Log写在一起？</h3><p>场景：Record模块，存储了Crash的信息。我们需要生成某种格式的日志。Record把生成日志的代码通过分类实现。<br>这里通过category的实现，方便，不会引入单独的类。把格式化生成log的职责放在了record模块里。但是Log是个改动频繁的功能，兼具有相当多的扩展性(多种格式..)。仅是log当做Record的一个功能，职责和灵活性都说不过去。Record应<strong>仅关注信息的记录</strong>。把Log当做另一个同等级模块来看待。</p>
<p>做法1：把Log和Record拆分为同等级的模块，Log模块依赖于Record,生成相应的日志。<br>这里纠正一个错误，有同学说，既然存在依赖，那就用分类好了不需要拆分。<strong>模块拆分和依赖无关，关注的是职责分离和粒度控制，是通过现在情况和未来发展做出的判断。</strong></p>
<p><strong>从框架开发的角度来看</strong>，Record和Log都是独立的模块，不能互相依赖。Log模块需要元数据，我们可以定义Info协议，Log依赖Info协议。当需要生成log时，我们构造一个遵循Info协议的类RecordInfo，给Log使用即可。多了一层中间层，但是把 Record和Log隔离出来，两者都可以复用。 <strong>维护成本由 Log和Record 的使用者承担。</strong>这是做的很干净的写法，适用于需要复用的情况，如果仅仅把Log用在固定的场景，那么直接依赖元数据类也是可以的。</p>
<h2 id="策略控制"><a href="#策略控制" class="headerlink" title="策略控制"></a>策略控制</h2><p>现在对于 某个功能 有一个实现A， 此时，在A的实现的基础上出现了另一种分支，达到B的效果。</p>
<p>在A的代码中，修改逻辑是常用的做法，借此实现AB功能。<br>但这样破坏了原有的功能，使得逻辑日渐复杂。我认为相对合理的做法是，将AB的共同逻辑抽取，差异逻辑分开。如果实现代码很多，可以拆分成两个策略类。关于<code>func</code>还是<code>strategy class</code>可以根据代码量和复杂程度来权衡。</p>
<p>软件开发中是无法避免依赖的，我们可以把相关的逻辑放在类中，也可以放在函数中。我认为这本质上是一样的。粒度是开发过程中需要考虑的问题。合理的设计出最适用用与当下的框架，不过度设计。要知道我们无法从根本上改变软件逐渐增大的复杂度，我们能做的是改变自己的编码方式，将逻辑写的合理清晰就好了。</p>
<h2 id="创建模式的思考"><a href="#创建模式的思考" class="headerlink" title="创建模式的思考"></a>创建模式的思考</h2><ol>
<li>工厂模式 生产一类物品</li>
<li>抽象工厂模式 生产多类物品</li>
<li>生成器模式 构造复杂的产品</li>
</ol>
<p>工厂模式将实现代码与暴露的接口隔离。抽象工厂模式在工厂模式的基础上将多种工厂的能力统一暴露。生成器模式关注于复杂对象的步骤生成。</p>
<p>创建模式都将实现与产品隔离。生成器模式相较于抽象工厂模式，在对象的生成中更加细化，将生成的对象各个步骤隔离，各个步骤可以组合。而抽象工厂模式适用于简单的对象生成。</p>
<p><strong>我认为，本质上，创建者模式，通过依赖注入，以统一的接口分发不同的实现。可以根据实际情况，根据复杂度选择合适的做法。</strong></p>
<h2 id="契约式设计"><a href="#契约式设计" class="headerlink" title="契约式设计"></a>契约式设计</h2><p>DbC的核心思想是对软件系统中的元素之间相互合作以及“责任”与“义务”的比喻。这种比喻从商业活动中“客户”与“供应商”达成“契约”而得来。例如：</p>
<ul>
<li>供应商必须提供某种产品（责任），并且他有权期望客户已经付款（权利）。</li>
<li>客户必须付款（责任），并且有权得到产品（权利）。</li>
<li>契约双方必须履行那些对所有契约都有效的责任，如法律和规定等。</li>
</ul>
<p>同样的，如果在面向对象程序设计中一个类的函数提供了某种功能，那么它要：</p>
<ul>
<li>期望所有调用它的客户模块都保证一定的进入条件：这就是函数的先验条件—客户的义务和供应商的权利，这样它就不用去处理不满足先验条件的情况。</li>
<li>保证退出时给出特定的属性：这就是函数的后验条件—供应商的义务，显然也是客户的权利。</li>
<li>在进入时假定，并在退出时保持一些特定的属性：不变条件。</li>
</ul>
<h3 id="调用方和被调用方相互负责的看法"><a href="#调用方和被调用方相互负责的看法" class="headerlink" title="调用方和被调用方相互负责的看法"></a>调用方和被调用方相互负责的看法</h3><p>在写code中经常会遇到 不知道一些guard 条件到底写在哪好。<br>写在调用方，逻辑清晰一些。写在被调用方，可以减少代码冗余。</p>
<p>我个人觉得这样的写法比较合适:</p>
<ol>
<li>调用者体内会被改变的状态，在调用者做校验。</li>
<li>被调用者处理上下文的一些信息。</li>
<li>当被调用者的guard逻辑重复多次，考虑将判断逻辑抽象成函数。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/13/dependency/" data-id="ck8hkauum000potjh3zzd7s2i" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iosoom" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/10/iosoom/" class="article-date">
  <time datetime="2018-04-10T12:30:35.000Z" itemprop="datePublished">2018-04-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/APM/">APM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/10/iosoom/">iOS OOM</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近在做oom,简单的总结下相关知识</p>
<p><strong>Out Of Memory 是 Jetsam同过响应压力通知杀掉优先级内消耗内存太多的进程, 导致应用闪退的一种现象，难于捕获和分析。</strong></p>
<h2 id="技术点："><a href="#技术点：" class="headerlink" title="技术点："></a>技术点：</h2><pre><code>1. iOS 内存分配系统的实现
2. 如何抓到回调与如何监控
3. 数据结构设计
4. iOS abort机制
5. OOM事件捕获</code></pre><h2 id="iOS内存分配系统的实现（用户层级）"><a href="#iOS内存分配系统的实现（用户层级）" class="headerlink" title="iOS内存分配系统的实现（用户层级）"></a>iOS内存分配系统的实现（用户层级）</h2><p>iOS中，内存堆分配的基本控制者是 malloc_zone, 通常是default_zone. 实际上是一个 scallable zone. 我们的通过malloc 分配的内存都是 通过Zone中的空闲内存块链表中获取的. 实际上Zone 从VMPage获取4k对齐的内存(mvm_allocate_pages). 然后再分给我们小块的，效率高，我们通过malloc分配内存，就不必每次都需要申请vmpages. malloc 内存申请分为 tiny, small, large… </p>
<h3 id="虚拟内存分配相关的知识："><a href="#虚拟内存分配相关的知识：" class="headerlink" title="虚拟内存分配相关的知识："></a>虚拟内存分配相关的知识：</h3><p>vm_map, vm_map_entry, vm_object, vm_page, vm_object, vm_page<br>对虚拟内存页面的调用都在bsd/kern/kern_mman.c中实现。</p>
<h3 id="物理内存-pmap…"><a href="#物理内存-pmap…" class="headerlink" title="物理内存: pmap…"></a>物理内存: pmap…</h3><h2 id="iOS-abort-机制"><a href="#iOS-abort-机制" class="headerlink" title="iOS abort 机制"></a>iOS abort 机制</h2><h3 id="Pageout"><a href="#Pageout" class="headerlink" title="Pageout"></a>Pageout</h3><p>管理页面交换的策略，判断哪些页面需要写回到其后备存储。<br>垃圾回收线程 (vm_pageout_grabage_collect())  调用 consider_pressure_events -&gt; vm_dispatch_memory_pressure() -&gt; BSD -&gt; NOTE_VM_PRESSURE-&gt; 响应压力通知<br>如果进程并不是总能找到可以抛弃的内存，当这种协作方法失败时，Jetsam机制介入。</p>
<h3 id="Jetsam"><a href="#Jetsam" class="headerlink" title="Jetsam"></a>Jetsam</h3><p>通过响应压力通知杀掉优先级内消耗内存太多的进程。<br>BSD层起了一个内核优先级最高的线程VM_memorystatus，这个线程会在维护两个列表，一个是我们之前提到的基于进程优先级的进程列表，还有一个是所谓的内存快照列表，即保存了每个进程消耗的内存页memorystatus_jetsam_snapshot。<br>这个常驻线程接受从内核对于内存的守护程序pageout通过内核调用给每个App进程发送的内存压力通知，来处理事件，这个事件转发成上层的UI事件就是平常我们会收到的全局内存警告或者每个ViewController里面的didReceiveMemoryWarning。</p>
<h4 id="杀的类别"><a href="#杀的类别" class="headerlink" title="杀的类别"></a>杀的类别</h4><p>读了一下源码，发现 杀的机制有如下两种，他们大致的执行流程如下</p>
<p><strong>highwater 的处理 -&gt; 我们App占用的内存不要超过限制</strong><br>    1. 从优先级列表里循环寻找线程<br>    2. 判断是否满足p_memstat_memlimit的限制条件<br>    3. DiagnoseActive, FREEZE过滤<br>    4. 杀进程，杀到了exit, 否则继续循环</p>
<p><strong>memorystatus_act_aggressive处理 -&gt; 内存占用高按优先级杀</strong><br>    1. 根据policy加载 jld_bucket_count， 用来判断是否开杀<br>    2. 从JETSAM_PRIORITY_ELEVATED_INACTIVE 开始杀<br>    3. jld_bucket_count 和 memorystatus_jld_eval_period_msecs 判断是否开杀<br>    4. 根据优先级从低向高杀，直到memorystatus_avail_pages_below_pressure</p>
<h4 id="触发入口"><a href="#触发入口" class="headerlink" title="触发入口"></a>触发入口</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># static boolean_t</span></span><br><span class="line">memorystatus_action_needed(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_EMBEDDED</span></span><br><span class="line">    <span class="keyword">return</span> (is_reason_thrashing(kill_under_pressure_cause) ||</span><br><span class="line">            is_reason_zone_map_exhaustion(kill_under_pressure_cause) ||</span><br><span class="line">           memorystatus_available_pages &lt;= memorystatus_available_pages_pressure);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* CONFIG_EMBEDDED */</span></span></span><br><span class="line">    <span class="keyword">return</span> (is_reason_thrashing(kill_under_pressure_cause) ||</span><br><span class="line">            is_reason_zone_map_exhaustion(kill_under_pressure_cause));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_EMBEDDED */</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>针对这种情况我们可以</strong></p>
<p>memorystatus_action_needed 判断 -&gt; 规避Jetsam处理<br>    1. 是否因为thrashing(如果是EMBEDED则不会触发这种情况)<br>    2. 是否因为zone_map_exhaustion(判断Zone的消耗情况, vm_map 相关参数来做，感觉这个意义不大)<br>    3. 是否因为memorystatus_available_pages &lt;= memorystatus_available_pages_pressure(是否是EMBEDDED)(根据物理内存page占比计算得到) -&gt; boot_arguments…能取到(外部拿不到，只能走内核调试拿.. )</p>
<h3 id="watchdog"><a href="#watchdog" class="headerlink" title="watchdog"></a>watchdog</h3><p>为了避免应用陷入错误状态导致界面无响应，Apple 设计了看门狗 (WatchDog) 机制。一旦超时，强制杀死进程。在不同的生命周期，触发看门狗机制的超时时间有所不同：</p>
<table>
<thead>
<tr>
<th>生命周期</th>
<th>超时时间</th>
</tr>
</thead>
<tbody><tr>
<td>启动 Launch</td>
<td>20 s</td>
</tr>
<tr>
<td>恢复 Resume</td>
<td>10 s</td>
</tr>
<tr>
<td>悬挂 Suspend</td>
<td>10 s</td>
</tr>
<tr>
<td>退出 Quit</td>
<td>6 s</td>
</tr>
<tr>
<td>后台 Background</td>
<td>10 min</td>
</tr>
</tbody></table>
<h3 id="如何抓到回调与如何监控"><a href="#如何抓到回调与如何监控" class="headerlink" title="如何抓到回调与如何监控"></a>如何抓到回调与如何监控</h3><p><strong>抓到</strong>：libmalloc 中的 malloc_logger 函数指针。通过这个可以抓到所有malloc类分配。<br>vm 则可以根据hook或者私有变量，和 malloc_logger一致。</p>
<p><strong>监控</strong>: 每次抓到都获取调用栈，存储进自己定义的数据结构中。  这里为什么不会循环调用需要值得注意一下。是通过不同的逻辑分支，保证不会走到相同的带分配的逻辑分支。</p>
<h3 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h3><pre><code>1. 空间占用
2. 访问速度
3. 细节存储优化</code></pre><h3 id="OOM事件捕获"><a href="#OOM事件捕获" class="headerlink" title="OOM事件捕获"></a>OOM事件捕获</h3><ol>
<li>现有方案，排除法</li>
<li>存在的问题 applicationstate不准等</li>
<li>经验值+ANR 优化</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/10/iosoom/" data-id="ck8hkauur000yotjh3dvja9ye" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-sharedlibraryandpic" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/15/sharedlibraryandpic/" class="article-date">
  <time datetime="2018-01-14T16:35:39.000Z" itemprop="datePublished">2018-01-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Hook/">Hook</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/15/sharedlibraryandpic/">fishhook与共享库和PIC</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>fishhook是不能hook同一个library内的符号调用的，在某个issus的解答如下。</p>
<blockquote>
<p>People have had issues with socket and/or connect in the past. One problem is that fishhook can only hook external calls, which means function calls within the same library generally cannot be hooked. In this case, calls to socket and connect from within the same library (libSystem) cannot be hooked. With the simulator, the system libraries are broken out into many sub-libraries, including libsystem_networking. With many sub-libraries, this means function calls from one sub-library to another can be hooked on the simulator, but on device where there’s just a single libSystem, those same calls are within the same library and cannot be hooked.</p>
</blockquote>
<p>这是由于fishhook利用 Macho-O dyld link 的 dynamically rebinding symbols实现所导致的。</p>
<p>这边文章就围绕这个话题来展开，解释一下la_symbol_ptr存在的原因。由于Mac OS 上使用 stubs, la_symbol_ptrs, stub_helper来实现延迟绑定的原理和Linux ELF差不多，这里就使用ELF的实现来解释。</p>
<h2 id="PIC位置无关代码的引入"><a href="#PIC位置无关代码的引入" class="headerlink" title="PIC位置无关代码的引入"></a>PIC位置无关代码的引入</h2><p>设想一个场景，因为Linux/Mac os使用的是虚拟内存系统，这意味着共享库引用的外部符号地址在不同进程的虚拟内存中是不同的，对应到物理内存中TEXT段也不同，所以必须拷贝多份。这显然是不可以接受的，内存中存在了大量拷贝，浪费RAM资源。</p>
<p>如果我们共享库对外部引用是位置无关的就好了，就不会存在这个问题。</p>
<h3 id="GOT-全局偏移表"><a href="#GOT-全局偏移表" class="headerlink" title="GOT 全局偏移表"></a>GOT 全局偏移表</h3><p>这时利用DATA段读写的特性，DATA段会在内存中有多份拷贝，并且DATA段和TEXT段的距离不变，在DATA段存储变化的地址，TEXT段使用指向DATA段对应位置的引用。这就解决了TEXT段共享的问题。这里我们引入了一个全局偏移量表，GOT。动态链接器会重定位GOT中的每个条目，使得它包含正确的绝对地址。</p>
<h3 id="PIC函数调用-和-PLT过程链接表"><a href="#PIC函数调用-和-PLT过程链接表" class="headerlink" title="PIC函数调用 和 PLT过程链接表"></a>PIC函数调用 和 PLT过程链接表</h3><p>使用GOT这种方式，我们每次调用函数都需要额外的三条指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">        call L1</span><br><span class="line">L1:   popl %ebx </span><br><span class="line">        addl $PROCOFF, %ebx</span><br><span class="line">        call *(%ebx)</span><br></pre></td></tr></table></figure>
<ol>
<li>将PC的值移到 ebx中</li>
<li>ebx 指向GOT中适当的条目</li>
</ol>
<p>这样的效率未免有些低。于是引入了 延迟绑定的技术，将过程地址的绑定推迟到第一次调用该过程时。第一次调用过程的运行时开销很大，但是其后的每次调用都只会花费一条指令和一个间接地存储器引用。</p>
<p><strong>过程</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call 8048464</span><br></pre></td></tr></table></figure>
<p>调用相应的PLT条目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jmp *0x8049684</span><br><span class="line">pushl $0x8</span><br><span class="line">jmp 8048444</span><br></pre></td></tr></table></figure>
<p>跳转到addvec</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/15/sharedlibraryandpic/" data-id="ck8hkauuw001aotjh4lghbtlx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-In-depthUnderStandingOfThreadSafety" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/24/In-depthUnderStandingOfThreadSafety/" class="article-date">
  <time datetime="2017-12-24T07:29:03.000Z" itemprop="datePublished">2017-12-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/24/In-depthUnderStandingOfThreadSafety/">理解线程安全</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="线程安全问题的来源"><a href="#线程安全问题的来源" class="headerlink" title="线程安全问题的来源"></a>线程安全问题的来源</h2><blockquote>
<p>线程安全是编程中的术语，指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。</p>
</blockquote>
<p>可以看到这一切的诱因就是因为共享变量。如果我们的线程执行过程中，没有相互影响，就不会出现问题。</p>
<p>当我们的线程访问共享变量时，我们无法预测操作系统是否将为我们的线程选择一个正确的顺序。这就尴尬了！</p>
<p>对多个线程对资源的访问，我们称之为 竞争。</p>
<p>由于两个或者多个进程竞争使用不能被同时访问的资源，使得这些进程有可能因为时间上推进的先后原因而出现问题，这叫做竞争条件（Race Condition）。</p>
<p><strong>竞争条件分为两类</strong></p>
<ol>
<li>Mutex 不能被多个进程同时使用的资源</li>
<li>Synchronization 两个或多个进程彼此指针存在内在的制约关系</li>
</ol>
<ul>
<li>消费者生产者问题就是同步问题，它需要调度对共享资源的访问，是  Synchronization。</li>
<li>读者写者问题是互斥问题的一个概括。</li>
</ul>
<p><strong>消费者生产者问题</strong></p>
<blockquote>
<p>因为插入和取出项目都涉及更新共享变量，所以我们必须保证对缓冲区的访问是互斥的。但是只保证互斥访问是不够的，我们还需要调度对缓冲区的访问。如果缓冲区是满的，那么生产者必须等待直到有一个槽位变为可用。与之相似，如果缓冲区是空的，那么消费者必须等待直到有一个项目变为可用。</p>
</blockquote>
<p><strong>读者-写者问题</strong></p>
<blockquote>
<p>读者写者问题是互斥问题的一个概括。一组并发的线程要访问一个共享对象。写者必须拥有对对象独占的访问。</p>
</blockquote>
<h2 id="如何保证线程安全"><a href="#如何保证线程安全" class="headerlink" title="如何保证线程安全"></a>如何保证线程安全</h2><p>在我们需要访问共享变量的情况下，我们需要保证线程执行顺序的正确性。或者我们尽量避免使用共享变量。</p>
<p><strong>进度图</strong><br>如果我们用 纵横坐标分别表示两个进程执行的指令顺序，那么操作共享变量的指令会构成一个二维的不安全区，当两条线程的执行轨迹会同时访问不安全区时，我们就认为执行是不安全的。(局限性：无法描述多处理器并发执行)</p>
<p>我们可以选择安全的轨迹线，或者使用信号量实现互斥。</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>思考一下，锁做了什么？</p>
<p>lock是在执行多线程时用于强行限制资源访问的同步机制，即用于在并发控制中保证对互斥要求的满足.<br>对于竞争条件中的 Mutex 我们可以使用互斥锁处理。Synchronization 可以使用条件锁。<br>使用lock是可以保证线程安全的，但不能保证线程的执行顺序。</p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>原子性（Atomic），一个事务包含多个操作，这些操作要么全部执行，要么全都不执行。</p>
<p>OC 中一个很经典的面试题是， property 设置 atomic 能保证线程安全吗？<br>很多人都回答可以，这是压根没理解线程安全的体现。<br><strong>原子性不能保证线程安全</strong><br>原子性可以保证写操作一小块代码段是互斥的，但是并不能保证线程安全。</p>
<p>设置atomic之后，只是保证了 属性的赋值操作是互斥的，可惜只是该属性..<br>不能保证我们整个代码的线程安全。</p>
<p>考虑一段代码.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.a = <span class="number">0</span>;<span class="comment">//1</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.a == <span class="number">0</span>) &#123;</span><br><span class="line">    print(<span class="string">"safe"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    print(<span class="string">"unsafe"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 self.a = 0; 执行完毕后</p>
<p>处理机调度，切换到另一个线程执行</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.b = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>再次切换为原先的线程<br>此时，结果是<br><strong>unsafe.</strong><br>我们原先的值被其他线程篡改了。并不能保证线程安全。</p>
<p>会想一下 那经典的 进度图，原子性无法阻止多个线程访问不安全区。</p>
<p>加锁之后，就保证 代码块 不会被多个进程访问，保证了线程安全。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lock();</span><br><span class="line"><span class="keyword">self</span>.a = <span class="number">0</span>;<span class="comment">//1</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.a == <span class="number">0</span>) &#123;</span><br><span class="line">    print(<span class="string">"safe"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    print(<span class="string">"unsafe"</span>);</span><br><span class="line">&#125;</span><br><span class="line">unlock();</span><br></pre></td></tr></table></figure>


<h2 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h2><p>不可变性，这个跟线程安全关系大吗？<br>显然，我们对共享变量的访问，会导致线程安全问题是因为我们对其进行了写操作。不可变可以避免代码编写中因为疏忽导致的问题。真正处理线程安全的时候，你遇到的，会是可变的共享变量！<br>所以，这个对线程安全问题，没有用处。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/24/In-depthUnderStandingOfThreadSafety/" data-id="ck8hkauud000aotjh54y7682c" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-safeSwizzleRSSwizzleAnalyze" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/04/safeSwizzleRSSwizzleAnalyze/" class="article-date">
  <time datetime="2017-12-04T06:08:16.000Z" itemprop="datePublished">2017-12-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Hook/">Hook</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/04/safeSwizzleRSSwizzleAnalyze/">Method Swizzling 的正确途径</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>iOS 平台开发，有时会使用到Method Swizzling,  但Method Swizzling 在使用过程中有许多需要注意的问题，本文将介绍将会产生的问题，并且分析 <a href="https://github.com/rabovik/RSSwizzle" target="_blank" rel="noopener">RSSwizzle</a> 是如何解决这些问题的。</p>
<h2 id="在Objective-C-中方法交换有什么危险"><a href="#在Objective-C-中方法交换有什么危险" class="headerlink" title="在Objective-C 中方法交换有什么危险"></a>在Objective-C 中方法交换有什么危险</h2><p><a href="https://stackoverflow.com/questions/5339276/what-are-the-dangers-of-method-swizzling-in-objective-c?answertab=active#tab-top" target="_blank" rel="noopener">What are the Dangers of Method Swizzling in Objective C?</a><br>stackoverflow 上的这个回答十分精彩。</p>
<pre><code>- Method swizzling 并不是原子操作
- 改变了不是我们自己代码的行为
- 有可能出现命名冲突
- Swizzling 改变方法的参数
- Swizzles 顺序问题
- 难于理解
- 难于Debug</code></pre><h3 id="Swizzling-改变方法的参数-例子"><a href="#Swizzling-改变方法的参数-例子" class="headerlink" title="Swizzling 改变方法的参数 例子"></a>Swizzling 改变方法的参数 例子</h3><p>使用<code>method_exchangeImplementations</code>更改方法的实现，会导致一个问题，origin_imp 如果使用了 _cmd 参数，hook之后的_cmd 是不符合预期的。</p>
<p>hook <code>touchesBegan</code> 过的同学应该遇到这种问题。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br></pre></td></tr></table></figure>

<p>这个函数里面 调用了 <code>forwardTouchMethod</code> , 反汇编后类似这种。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    forwardTouchMethod(<span class="keyword">self</span>, _cmd, touches, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> forwardTouchMethod(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="built_in">NSSet</span> *touches, <span class="built_in">UIEvent</span> *event) &#123;</span><br><span class="line">  <span class="comment">// The responder chain is used to figure out where to send the next touch</span></span><br><span class="line">    <span class="built_in">UIResponder</span> *nextResponder = [<span class="keyword">self</span> nextResponder];</span><br><span class="line">    <span class="keyword">if</span> (nextResponder &amp;&amp; nextResponder != <span class="keyword">self</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Not all touches are forwarded - so we filter here.</span></span><br><span class="line">        <span class="built_in">NSMutableSet</span> *filteredTouches = [<span class="built_in">NSMutableSet</span> set];</span><br><span class="line">        [touches enumerateObjectsUsingBlock:^(<span class="built_in">UITouch</span> *touch, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Checks every touch for forwarding requirements.</span></span><br><span class="line">            <span class="keyword">if</span> ([touch _wantsForwardingFromResponder:<span class="keyword">self</span> toNextResponder:nextResponder withEvent:event]) &#123;</span><br><span class="line">                [filteredTouches addObject:touch];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// This is interesting legacy behavior. Before iOS 5, all touches are forwarded (and this is logged)</span></span><br><span class="line">                <span class="keyword">if</span> (!_UIApplicationLinkedOnOrAfter(<span class="number">12</span>)) &#123;</span><br><span class="line">                    [filteredTouches addObject:touch];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Log old behavior</span></span><br><span class="line">                    <span class="keyword">static</span> <span class="built_in">BOOL</span> didLog = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!didLog) &#123;</span><br><span class="line">                        <span class="built_in">NSLog</span>(<span class="string">@"Pre-iOS 5.0 touch delivery method forwarding relied upon. Forwarding -%@ to %@."</span>, <span class="built_in">NSStringFromSelector</span>(_cmd), nextResponder);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// here we basically call [nextResponder touchesBegan:filteredTouches event:event];</span></span><br><span class="line">        [nextResponder performSelector:_cmd withObject:filteredTouches withObject:event];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们exchange了 imp, <code>[nextResponder performSelector:_cmd withObject:filteredTouches withObject:event];</code> 是没有相应的实现的，<strong>_cmd</strong> 就变成了 我们替换的 sel. 显然，nextResponder没有实现相应的方法，就会crash。</p>
<h4 id="正确的hook方式"><a href="#正确的hook方式" class="headerlink" title="正确的hook方式"></a><strong>正确的hook方式</strong></h4><p><strong>方案一:</strong><br>直接替换 method 的 IMP.<br><code>method_setImplementation</code>, 在新的IMP中调用原始的 IMP.</p>
<h2 id="RSSwizzle"><a href="#RSSwizzle" class="headerlink" title="RSSwizzle"></a>RSSwizzle</h2><p><strong>RSSwizzle 实现方式</strong><br>    1. 根据block生成NEW IMP<br>    2. replace 目标方法的实现<br>    3. block可以获取原来的IMP</p>
<p><strong>核心交换代码</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> swizzle(Class classToSwizzle,</span><br><span class="line">                    SEL selector,</span><br><span class="line">                    RSSwizzleImpFactoryBlock factoryBlock)</span><br><span class="line">&#123;</span><br><span class="line">    Method method = class_getInstanceMethod(classToSwizzle, selector);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSCAssert</span>(<span class="literal">NULL</span> != method,</span><br><span class="line">              <span class="string">@"Selector %@ not found in %@ methods of class %@."</span>,</span><br><span class="line">              <span class="built_in">NSStringFromSelector</span>(selector),</span><br><span class="line">              class_isMetaClass(classToSwizzle) ? <span class="string">@"class"</span> : <span class="string">@"instance"</span>,</span><br><span class="line">              classToSwizzle);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSCAssert</span>(blockIsAnImpFactoryBlock(factoryBlock),</span><br><span class="line">             <span class="string">@"Wrong type of implementation factory block."</span>);</span><br><span class="line">    </span><br><span class="line">    __block OSSpinLock lock = OS_SPINLOCK_INIT;</span><br><span class="line">    <span class="comment">// To keep things thread-safe, we fill in the originalIMP later,</span></span><br><span class="line">    <span class="comment">// with the result of the class_replaceMethod call below.</span></span><br><span class="line">    __block IMP originalIMP = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This block will be called by the client to get original implementation and call it.</span></span><br><span class="line">    RSSWizzleImpProvider originalImpProvider = ^IMP&#123;</span><br><span class="line">        <span class="comment">// It's possible that another thread can call the method between the call to</span></span><br><span class="line">        <span class="comment">// class_replaceMethod and its return value being set.</span></span><br><span class="line">        <span class="comment">// So to be sure originalIMP has the right value, we need a lock.</span></span><br><span class="line">        OSSpinLockLock(&amp;lock);</span><br><span class="line">        IMP imp = originalIMP;</span><br><span class="line">        OSSpinLockUnlock(&amp;lock);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == imp)&#123;</span><br><span class="line">            <span class="comment">// If the class does not implement the method</span></span><br><span class="line">            <span class="comment">// we need to find an implementation in one of the superclasses.</span></span><br><span class="line">            Class superclass = class_getSuperclass(classToSwizzle);</span><br><span class="line">            imp = method_getImplementation(class_getInstanceMethod(superclass,selector));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> imp;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    RSSwizzleInfo *swizzleInfo = [RSSwizzleInfo new];</span><br><span class="line">    swizzleInfo.selector = selector;</span><br><span class="line">    swizzleInfo.impProviderBlock = originalImpProvider;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// We ask the client for the new implementation block.</span></span><br><span class="line">    <span class="comment">// We pass swizzleInfo as an argument to factory block, so the client can</span></span><br><span class="line">    <span class="comment">// call original implementation from the new implementation.</span></span><br><span class="line">    <span class="keyword">id</span> newIMPBlock = factoryBlock(swizzleInfo);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *methodType = method_getTypeEncoding(method);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSCAssert</span>(blockIsCompatibleWithMethodType(newIMPBlock,methodType),</span><br><span class="line">             <span class="string">@"Block returned from factory is not compatible with method type."</span>);</span><br><span class="line">    </span><br><span class="line">    IMP newIMP = imp_implementationWithBlock(newIMPBlock);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Atomically replace the original method with our new implementation.</span></span><br><span class="line">    <span class="comment">// This will ensure that if someone else's code on another thread is messing</span></span><br><span class="line">    <span class="comment">// with the class' method list too, we always have a valid method at all times.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If the class does not implement the method itself then</span></span><br><span class="line">    <span class="comment">// class_replaceMethod returns NULL and superclasses's implementation will be used.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// We need a lock to be sure that originalIMP has the right value in the</span></span><br><span class="line">    <span class="comment">// originalImpProvider block above.</span></span><br><span class="line">    OSSpinLockLock(&amp;lock);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// originIMP get value from here</span></span><br><span class="line">    originalIMP = class_replaceMethod(classToSwizzle, selector, newIMP, methodType);</span><br><span class="line">    OSSpinLockUnlock(&amp;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>具体过程解析</strong></p>
<p><strong>如果hook的方法在hook的类中有实现</strong><br>    1. block生成新的IMP<br>    2. 替换IMP, 这时候拿到原始的ORIGINIMP<br>    3. block接受了一个RSSwizzleInfo参数，从参数中可以拿到当时保存的获得IMP的block<br>    4. 由于block中存储的是originIMP ，所以获得的是原始的实现</p>
<p><strong>如果hook的方法在子类中无实现</strong><br>    1. block生成新的IMP<br>    2. 替换IMP（由于没有实现，相当于add了IMP）, 原始的实现为nil<br>    3. block 中我们调用calloriginIMP,这个方法实际调用了一个block originalImpProvider<br>    4. 这个block的从父类找到相应的实现（注意，这里实际上是在 调用方法 时才会触发）</p>
<p>这种情况是调用时，动态获得 当时的方法实现，所以可以避免hook顺序带来的问题。</p>
<h3 id="那么影响Swizzle的结果到底是是什么呢？"><a href="#那么影响Swizzle的结果到底是是什么呢？" class="headerlink" title="那么影响Swizzle的结果到底是是什么呢？"></a>那么影响Swizzle的结果到底是是什么呢？</h3><p>Swizzle实现方式本质上就是改变方法的IMP 为 NewIMP, 并调用原先的originIMP</p>
<p>只hook一个是没问题，但是涉及到多次hook, 并且hook的方法可能为一个时， 他们的顺序就会导致不同的结果，因为顺序不同，Swizzle时，Method 相应的 IMP 不相同。<br>这里我们更关注，父子类+hook 同一个方法产生的问题。</p>
<p><strong>那么RSSwizzle  怎么解决问题的呢？</strong></p>
<p>父类有method, 子类没有实现method.<br>我们有如下的IMP:<code>superIMP</code>,<code>superNewIMP</code>,<code>subNewIMp</code><br>此时，我们Swizzle 父类的method 为 superNewIMP<br>Swizzle子类的method 为 subNewIMp</p>
<p><strong>首先关注我们期望的调用顺序</strong><br>    1. subNewIMP<br>    2. superNewIMP<br>    3. superIMP</p>
<p><strong>我们先hook父类，再hook子类后，的调用顺序</strong><br>    1. subNewImp<br>    2. superNewIMP<br>    3. superIMp</p>
<p><strong>先hook子类再hook父类</strong><br>    1. subNewIMP<br>    2. superIMP</p>
<p><strong>为什么会有差异?</strong><br>因为当我们在hook子类方法时，原先的方法实现是不同的。</p>
<p><strong>解决问题</strong><br>那就要保证，即使hook的顺序不同，也能正确取到相应的IMP<br>那我们保证，子类在调用相应方法的时候，取到的IMP是父类当前的IMP就可以(这样就和Swizzle的时间顺序没有了关系)</p>
<h2 id="RSSwizzle-加锁，保证线程安全"><a href="#RSSwizzle-加锁，保证线程安全" class="headerlink" title="RSSwizzle 加锁，保证线程安全"></a>RSSwizzle 加锁，保证线程安全</h2><p><strong><code>originalImpProvider</code> 的代码</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RSSWizzleImpProvider originalImpProvider = ^IMP&#123;</span><br><span class="line">    OSSpinLockLock(&amp;lock);</span><br><span class="line">    IMP imp = originalIMP;</span><br><span class="line">    OSSpinLockUnlock(&amp;lock);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == imp)&#123;</span><br><span class="line">        Class superclass = class_getSuperclass(classToSwizzle);</span><br><span class="line">        imp = method_getImplementation(class_getInstanceMethod(superclass,selector));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Swizzle 方法的某个部分</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OSSpinLockLock(&amp;lock);</span><br><span class="line">originalIMP = class_replaceMethod(classToSwizzle, selector, newIMP, methodType);</span><br><span class="line">OSSpinLockUnlock(&amp;lock);</span><br></pre></td></tr></table></figure>

<p>这两个方法有个共享变量 originalIMP，这就意味着，可能会出现线程安全问题。再仔细看下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OSSpinLockLock(&amp;lock);</span><br><span class="line">IMP imp = originalIMP;</span><br><span class="line">OSSpinLockUnlock(&amp;lock);</span><br><span class="line">if (NULL == imp)&#123;</span><br></pre></td></tr></table></figure>
<p>这个共享变量，和条件判断相关。敏锐的同学一眼就能看出来，在不加锁的情况下，当不同的线程对 这两段代码进行执行的时候，就会出现，即使<code>if (NULL == imp){</code>通过了，但实际上，另一条线程执行了<code>class_replaceMethod()</code>。这时就会出现问题。</p>
<p>在加锁之后，在同一时间段内，只有一个线程能访问改变这个变量的代码。避免了共享变量导致的线程安全问题。</p>
<h2 id="采用Block添加实现，没有命名冲突问题"><a href="#采用Block添加实现，没有命名冲突问题" class="headerlink" title="采用Block添加实现，没有命名冲突问题"></a>采用Block添加实现，没有命名冲突问题</h2><p>连命名的机会都没有…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RSSwizzleInstanceMethod(classToSwizzle,</span><br><span class="line">                        @selector(calculate:),</span><br><span class="line">                        RSSWReturnType(int),</span><br><span class="line">                        RSSWArguments(int number),</span><br><span class="line">                        RSSWReplacement(</span><br><span class="line">&#123;</span><br><span class="line">    // The following code will be used as the new implementation.</span><br><span class="line"></span><br><span class="line">    // Calling original implementation.</span><br><span class="line">    int res = RSSWCallOriginal(number);</span><br><span class="line">    // Returning modified return value.</span><br><span class="line">    return res + 1;</span><br><span class="line">&#125;), 0, NULL);</span><br></pre></td></tr></table></figure>

<h2 id="采用block-添加实现，只是改变了原来的IMP-，Selector没有改变，实现的-cmd并没有改变"><a href="#采用block-添加实现，只是改变了原来的IMP-，Selector没有改变，实现的-cmd并没有改变" class="headerlink" title="采用block 添加实现，只是改变了原来的IMP ，Selector没有改变，实现的_cmd并没有改变"></a>采用block 添加实现，只是改变了原来的IMP ，Selector没有改变，实现的<code>_cmd</code>并没有改变</h2><p>参数<code>_cmd</code>是当前方法的selector</p>
<p>swizzle method 可能会导致的<code>_cmd</code> 参数改变，例如<br>我们有<code>originMethod</code>和<code>newMethod</code>,他们分别对应着 <code>OriginIMP</code>,和<code>NewIMP</code>.<br>当我们交换方法实现后:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">originmethod -&gt; NewIMP</span><br><span class="line">newMethod -&gt; OriginIMP</span><br></pre></td></tr></table></figure>
<p>要想调用原来的实现，我们需要调用 <code>newMethod</code> 这就导致了 相同的IMP 但是<code>_cmd</code> 却改变了 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/04/safeSwizzleRSSwizzleAnalyze/" data-id="ck8hkauuv0018otjhe5gc6fpt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-dyld3withappstart" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/27/dyld3withappstart/" class="article-date">
  <time datetime="2017-10-27T12:25:33.000Z" itemprop="datePublished">2017-10-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/27/dyld3withappstart/">链接和App启动速度优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近看了链接相关的知识，结合 WWDC 2篇Session 和 iOS 启动优化 做一下总结.</p>
<h2 id="1-链接相关的基础知识"><a href="#1-链接相关的基础知识" class="headerlink" title="1 链接相关的基础知识"></a>1 链接相关的基础知识</h2><h3 id="1-1-从main-c到一个可执行目标文件"><a href="#1-1-从main-c到一个可执行目标文件" class="headerlink" title="1.1 从main.c到一个可执行目标文件"></a>1.1 从main.c到一个可执行目标文件</h3><p>我们的源程序main.c 经过C预处理器 翻译成一个ASCII中间文件 main.i,接下来 驱动程序运行C编译器，它将main.i翻译成一个ASCII汇编语言文件main.s,然后驱动程序运行汇编器，它讲main.s翻译成一个可重定位目标文件main.o,链接器程序将main.o和一些必要的系统目标文件组合起来,创建一个可执行目标文件。在运行时,main.o还可以和一些共享目标文件链接。</p>
<p><strong>预处理</strong></p>
<p>在该阶段，编译器将上述代码中的stdio.h编译进来，并且用户可以使用gcc的选项”-E”进行查看，该选项的作用是让gcc在预处理结束后停止编译过程。预处理阶段主要处理#include和#define，它把</p>
<ol>
<li>#include包含进来的.h 文件插入到#include所在的位置</li>
<li>把源程序中使用到的用#define定义的宏用实际的字符串代替</li>
</ol>
<p>hello.c</p>
<p><code>gcc -E hello.c -o hello.i</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Hello world!\n"</span>);  </span><br><span class="line">  </span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/JunyiXie/JunyiXie.github.io/blob/master/2017/10/27/dyld3withappstart/demo/hello.i" target="_blank" rel="noopener">hello.i</a></p>
<p><strong>编译阶段</strong></p>
<p>接下来进行的是编译阶段，在这个阶段中，Gcc首先要检查代码的规范性、是否有语法错误等，以确定代码的实际要做的工作，在检查无误后，Gcc把代码翻译成汇编语言。用户可以使用”-S”选项来进行查看，该选项只进行编译而不进行汇编，生成汇编代码。</p>
<p><code>gcc -S hello.c -o hello.s</code></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">	.section</span>	__TEXT,__text,regular,pure_instructions</span><br><span class="line"><span class="meta">	.macosx_version_min</span> <span class="number">10</span>, <span class="number">12</span></span><br><span class="line"><span class="meta">	.globl</span>	_main</span><br><span class="line"><span class="meta">	.p2align</span>	<span class="number">4</span>, <span class="number">0x90</span></span><br><span class="line"><span class="symbol">_main:</span>                                  ## @main</span><br><span class="line"><span class="meta">	.cfi_startproc</span></span><br><span class="line">## BB#<span class="number">0</span>:</span><br><span class="line">	pushq	%rbp</span><br><span class="line"><span class="symbol">Lcfi0:</span></span><br><span class="line"><span class="meta">	.cfi_def_cfa_offset</span> <span class="number">16</span></span><br><span class="line"><span class="symbol">Lcfi1:</span></span><br><span class="line"><span class="meta">	.cfi_offset</span> %rbp, -<span class="number">16</span></span><br><span class="line">	<span class="keyword">movq</span>	%rsp, %rbp</span><br><span class="line"><span class="symbol">Lcfi2:</span></span><br><span class="line"><span class="meta">	.cfi_def_cfa_register</span> %rbp</span><br><span class="line">	subq	<span class="number">$16</span>, %rsp</span><br><span class="line">	leaq	L_<span class="number">.</span><span class="keyword">str</span>(%rip), %rdi</span><br><span class="line">	movl	<span class="number">$0</span>, -<span class="number">4</span>(%rbp)</span><br><span class="line">	movb	<span class="number">$0</span>, %al</span><br><span class="line">	callq	_printf</span><br><span class="line">	xorl	%ecx, %ecx</span><br><span class="line">	movl	%eax, -<span class="number">8</span>(%rbp)          ## <span class="number">4</span>-<span class="built_in">byte</span> Spill</span><br><span class="line">	movl	%ecx, %eax</span><br><span class="line">	addq	<span class="number">$16</span>, %rsp</span><br><span class="line">	popq	%rbp</span><br><span class="line">	retq</span><br><span class="line"><span class="meta">	.cfi_endproc</span></span><br><span class="line"></span><br><span class="line"><span class="meta">	.section</span>	__TEXT,__cstring,cstring_literals</span><br><span class="line"><span class="symbol">L_.str:</span>                                 ## @.str</span><br><span class="line"><span class="meta">	.asciz</span>	<span class="string">"Hello world! \n"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">.subsections_via_symbols</span></span><br></pre></td></tr></table></figure>

<p><strong>汇编阶段</strong></p>
<p>汇编阶段把<code>.s</code>文件翻译成二进制机器指令文件<code>.o</code>，如命令gcc -c hello.s -o hello.o，其中-c告诉gcc进行汇编处理。这步生成的文件是二进制文件，直接用文本工具打开看到的将是乱码，我们需要反汇编工具如IDA的帮助才能读懂它</p>
<p><img src="idahello" alt="IDAhello.s"></p>
<p><strong>链接阶段</strong></p>
<p>在编译之后，就进入到了链接阶段。我们<code>hello.c</code> 中是没有定义<code>printf</code>的。我们需要把<code>hello.o</code>中的<code>printf</code>符号和它的定义相关联，重定位hello.o和相关的模块，生成一个可执行目标文件.此时我们的<code>printf</code>符号就能正常调用了.</p>
<p>链接使用<code>ld</code>工具.如果没有特别的指定,gcc会到系统默认的搜索路径<code>/usr/lib</code>下进行查找,找到合适的函数库，进行链接.</p>
<p><code>gcc hello.o -o hello.out</code> 生成可执行文件</p>
<p><code>./hello.out</code> 运行可执行文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello world!</span><br></pre></td></tr></table></figure>


<h3 id="1-2-链接的分类"><a href="#1-2-链接的分类" class="headerlink" title="1.2 链接的分类"></a>1.2 链接的分类</h3><ol>
<li>静态链接</li>
<li>动态链接</li>
</ol>
<p><strong>静态链接</strong><br>像Linux LD程序这样的静态链接器以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的，可以加载和运行的可执行目标文件为输出。</p>
<p><strong>动态链接</strong><br>共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链接.由一个叫做动态链接器的程序来执行的。</p>
<h3 id="1-3-链接的任务"><a href="#1-3-链接的任务" class="headerlink" title="1.3 链接的任务"></a>1.3 链接的任务</h3><ol>
<li><p>符号解析<br>目标文件定义和引用符号，符号解析的目的是将每个符号引用正好和一个符号定义关联起来</p>
</li>
<li><p>重定位<br>编译器和链接器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，是他们指向这个内存位置。</p>
</li>
</ol>
<p><strong>可重定位目标文件</strong></p>
<p>链接器是以可重定位目标文件作为输入的，要想理解链接的过程，首先应该了解可重定位目标文件。</p>
<table>
<thead>
<tr>
<th>setion</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>ELF头</td>
<td>系统的字的大小，字节顺序，ELF头的大小，目标文件的类型，机器类型，节头部表的文件偏移，节头部表中条目的大小和数量</td>
</tr>
<tr>
<td>.text</td>
<td>已编译程序的机器代码</td>
</tr>
<tr>
<td>.rodata</td>
<td>只读数据</td>
</tr>
<tr>
<td>.data</td>
<td>已初始化的全局和静态C变量</td>
</tr>
<tr>
<td>.bss</td>
<td>未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量</td>
</tr>
<tr>
<td>.symtab</td>
<td>一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。</td>
</tr>
<tr>
<td>.rel.text</td>
<td>重定位条目，一个.text节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这个位置。</td>
</tr>
<tr>
<td>.rel.data</td>
<td>重定位条目，被模块引用或定义的所有全局变量的重定位信息。</td>
</tr>
<tr>
<td>.debug</td>
<td>一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的C源文件。</td>
</tr>
<tr>
<td>.line</td>
<td>原始C源程序中的行号和.text节中机器指令间的映射。</td>
</tr>
<tr>
<td>.strtab</td>
<td>一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。字符串表就是以null结尾的字符串的序列。</td>
</tr>
<tr>
<td>节头目表</td>
<td>不同节的位置和大小。</td>
</tr>
</tbody></table>
<p>我们在链接中做的工作主要是：<br>符号解析<code>.text</code>,<code>.data</code>段的符号引用，重定位目标文件。</p>
<p><strong>符号和符号表</strong></p>
<p>在我们的一个可重定位目标模块中，通常会使用在当前模块和其他模块中定义的函数和全局变量，我们称之为符号。每个可重定位目标模块都有一个符号表，它包含m定义和引用符号的信息。</p>
<p><strong>ELF符号表条目</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> name;</span><br><span class="line">    <span class="keyword">char</span> type:<span class="number">4</span>,binding:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">char</span> reserved;<span class="comment">//没用</span></span><br><span class="line">    <span class="keyword">short</span> section;</span><br><span class="line">    <span class="keyword">long</span> value;</span><br><span class="line">    <span class="keyword">long</span> <span class="built_in">size</span>;</span><br><span class="line">&#125;Elf64_Symbol;</span><br></pre></td></tr></table></figure>

<ul>
<li>Name: 字符串表中的字节偏移</li>
<li>Value:符号的地址</li>
<li>Size:目标的大小</li>
<li>Type:函数或者是数据</li>
<li>Bingding:符号是本地的还是全局的</li>
</ul>
<p>使用nm命令我们可以看到：<br><code>$ nm mymalloc.o</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                 U ___real_free</span><br><span class="line">                 U ___real_malloc</span><br><span class="line">0000000000000050 T ___wrap_free</span><br><span class="line">0000000000000000 T ___wrap_malloc</span><br><span class="line">                 U _printf</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">___wrap_free,___wrap_malloc 是已定义的符号，在text段，有相应的内存地址.</span><br><span class="line">___real_free,_printf,___real_malloc 是未定义的符号</span><br></pre></td></tr></table></figure>


<p><strong>符号解析</strong></p>
<p>模块引用了符号，我们需要将符号和一个确定的符号定义关联起来，这样我们的程序才可以正常的执行下去。<br>对于引用和定义在相同模块中的局部符号，符号解析是很简单明了的。<br>但是当编译器遇到不是在当前模块中定义的符号时，只能假设该符号已经在其他模块中定义，生成一个链接器符号表条目，把它交给链接器处理。</p>
<p><strong>重定位</strong></p>
<p>一但链接器完成了符号解析这一步，就把代码中的每个符号引用和正好一个符号定义关联起来（即它的一个输入目标模块中的一个），此时，链接器就知道它的输入目标模块中的代码节和数据节的确切大小。现在就可以开始重定位步骤，在这个步骤中重定位将合并输入模块，并为每个符号分配运行时地址。</p>
<p><strong>重定位由两步组成：</strong></p>
<ol>
<li>重定位节和符号定义 <ul>
<li>链接器将所有相同类型的节合并为同一类型的新的聚合节。</li>
<li>链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成后，程序中的每条指令和全局变量都有唯一的运行时内存地址了。</li>
</ul>
</li>
<li>重定位节中的符号引用<ul>
<li>链接器依赖可重定位条目的数据结构，修改代码节和数据节中对每个符号的引用，使它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目标模块中成为可重定位条目的数据结构。</li>
</ul>
</li>
</ol>
<p><strong>可重定位条目</strong></p>
<p>当汇编器生成一个目标模块时，它并不知道数据和代码最终放在内存中的什么位置。他也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。所以，无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。</p>
<p>代码的可重定位条目在<code>.rel.text</code>节中，已初始化数据的重定位条目放在<code>.rel.data</code>中.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">long</span> offset;<span class="comment">// 需要被修改引用的节偏移</span></span><br><span class="line">	<span class="keyword">long</span> type:<span class="number">32</span>,symbol:<span class="number">32</span>;<span class="comment">// type:如何修改新的引用,symbol:标示被修改引用应该指向的符号</span></span><br><span class="line">	<span class="keyword">long</span> addend;<span class="comment">// 一些类型的重定位要使用它对被修改引用的值做偏移调整</span></span><br><span class="line">&#125;Elf64_Rela;</span><br></pre></td></tr></table></figure>

<p><strong>两种基本的重定位类型</strong>：</p>
<ol>
<li>PC 相对地址引用 一个PC相对地址就是 距程序计数器(PC)的当前运行值的偏移量</li>
<li>绝对地址引用 </li>
</ol>
<h3 id="1-4-动态链接共享库"><a href="#1-4-动态链接共享库" class="headerlink" title="1.4 动态链接共享库"></a>1.4 动态链接共享库</h3><p>静态库有一些明显的缺点，比如：</p>
<ol>
<li>静态库更新后需要显式地将他们的程序与更新了的库重新链接。</li>
<li>静态库的代码会被复制到每个运行进程的文本段中。</li>
</ol>
<p><strong>共享库，动态链接</strong><br>共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链接.由一个叫做动态链接器的程序来执行的。</p>
<p><strong>共享库的共享方式</strong></p>
<ol>
<li>给定文件系统中一个库只有一个.so文件。</li>
<li>内存中，一个共享库的.text节的一个副本可以被不同的正在运行的进程共享。</li>
</ol>
<p><strong>共享库的链接时机</strong></p>
<ol>
<li>在运行时由动态链接器练链接和加载</li>
<li>在调用程序被加载和开始执行时</li>
<li>根据需要在程序调用 dlopen 库的函数时</li>
</ol>
<p><strong>PIC 借助GOT,PLT实现</strong><br>第一次调用外部函数：<br>    1. 调用外部符号，程序进入相应的PLT条目<br>    2. 把 调用的 ID压入栈后，跳转到PLT[0]<br>    3. PLT[0]通过GOT[1]间接的把动态链接器的一个参数压入栈中，然后通过GOT[2]间接的跳转进动态链接器中。动态链接器使用两个栈条目来确定 外部函数的 远行时为止，用这个地址重写GOT[4],再把控制权传给 函数。</p>
<p>后续再次调用：<br>    1. 控制传递到PLT相应条目<br>    2. 通过相应的GOT条目直接转移控制到 函数</p>
<p>PLT[0]: 特殊条目，它跳转到动态链接器中<br>GOT[0]和GOT[1]包含动态链接器在解析函数地址时会使用的信息。<br>GOT[2]是动态链接器在ld-linux.so模块中的入口点。</p>
<h3 id="1-4-加载可执行目标文件"><a href="#1-4-加载可执行目标文件" class="headerlink" title="1.4 加载可执行目标文件"></a>1.4 加载可执行目标文件</h3><p>加载器将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。</p>
<p><strong>需要注意的是：</strong></p>
<ol>
<li>由于.data段有对齐要求，所以代码段和数据段之间是有间隙的</li>
<li>链接器会使用ASLR技术,每次区域运行时区域的地址都会改变，但是相对地址不会改变。</li>
</ol>
<p><strong>Linux下的加载</strong></p>
<ol>
<li>父shell进程生成一个子进程，它是父进程的一个复制</li>
<li>子进程通过execve系统调用启动加载器</li>
<li>加载器删除子进程现有的虚拟内存段，并创建一组新的代码，数据，堆和栈段</li>
<li>将虚拟地址空间中的页映射到可执行文件的页大小的片（chunk） ，新的代码和数据段被初始化为可执行文件的内容</li>
<li>加载器跳转到_start地址，最终会调用应用程序的main 函数。</li>
</ol>
<p>注意：除了一些头部信息，在加载过程中没有任何从磁盘到内存的数据复制。直到CPU引用一个被映射的虚拟页时才会进行复制，此时，操作系统利用它的页面调度机制，自动将页面从磁盘传送到内存。</p>
<h2 id="2-Apple-App-Start-And-Dyld"><a href="#2-Apple-App-Start-And-Dyld" class="headerlink" title="2 Apple App Start And Dyld"></a>2 Apple App Start And Dyld</h2><h3 id="2-1-dyld"><a href="#2-1-dyld" class="headerlink" title="2.1 dyld"></a>2.1 dyld</h3><p>当内核完成映射进程的工作后会将名字为dyld的Mach-O文件映射到进程中的随机地址，它将PC寄存器设为dyld的地址并运行.</p>
<p><strong>Fix-ups</strong><br>由于代码签名，我们无法修改<code>__TEXT</code>段的内容,我们可以通过PIC（Position Independent Code）将<code>dyld</code>修改的引用的地址存储到<code>__DATA</code>中. 在Linux中是通过<code>GOT(Global Offset Table)</code>和<code>PLT(Procedure Linkage Table)</code>实现的.</p>
<p><strong>dyld的时间线：</strong><br>Load dylibs -&gt; Rebase -&gt; Bind -&gt; ObjC -&gt; Initalizers</p>
<p><strong>Load</strong></p>
<ul>
<li>Load dylibs:dylibs映射到内存上。</li>
</ul>
<p><strong>Rebase和Binding</strong></p>
<p>Rebase：在镜像内部调整指针的指向. Binding：将指针指向镜像外部的内容</p>
<ul>
<li>Rebase和Binding:使用PIC技术重定位<code>__DATA</code>中对应<code>__TEXT</code>中符号的指针</li>
</ul>
<p>可以通过命令行查看 rebase 和 bind 相关的资源指针：<br><code>xcrun dyldinfo -rebase -bind -lazy_bind xxx.app/xxx</code><br>诸如此类的输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__DATA  __la_symbol_ptr  0x1000341C8 0x04C3 libobjc          _objc_setAssociatedObject</span><br><span class="line">__DATA  __la_symbol_ptr  0x1000341D0 0x04E4 libobjc          _objc_setProperty_nonatomic_copy</span><br><span class="line">__DATA  __la_symbol_ptr  0x1000341D8 0x050C libobjc          _objc_storeStrong</span><br><span class="line">__DATA  __la_symbol_ptr  0x1000341E0 0x0525 libobjc          _objc_storeWeak</span><br><span class="line">__DATA  __la_symbol_ptr  0x1000341E8 0x053C libobjc          _objc_unsafeClaimAutoreleasedReturnValue</span><br><span class="line">__DATA  __la_symbol_ptr  0x1000341F0 0x056C libSystem        _pow</span><br><span class="line">__DATA  __la_symbol_ptr  0x1000341F8 0x0578 libSystem        _sin</span><br><span class="line">__DATA  __la_symbol_ptr  0x100034200 0x0584 libSystem        _sinf</span><br><span class="line">__DATA  __la_symbol_ptr  0x100034208 0x0591 libswiftCore     _swift_getObjCClassMetadata</span><br><span class="line">__DATA  __la_symbol_ptr  0x100034210 0x05B4 libswiftCore     _swift_getObjectType</span><br><span class="line">__DATA  __la_symbol_ptr  0x100034218 0x05D0 libswiftCore     _swift_unknownRelease</span><br><span class="line">__DATA  __la_symbol_ptr  0x100034220 0x05ED libswiftCore     _swift_unknownRetain</span><br></pre></td></tr></table></figure>





<p><strong>ObjC Runtime</strong></p>
<ul>
<li>ObjC  数据结构中有class DATA structure 有很多指针，例如指向 methods 和 super 的指针。这些指针的Fixed-up是通过 rebasing 和 binding.可以说我们类中method_list中的很多信息都是通过 Fix-ups 来维护的</li>
<li>因为Objc的动态性,Objc 可以通过类名来实例化对象, 这意味着 ObjC runtime 需要维护 一张哈希表，负责<code>class name</code>和<code>class</code>的映射.因此当你加载dylib的时候，dylib中定义的类都会被注册到表中。</li>
<li>更新类定义 没有C++中易碎的基类问题，因为 Fix-ups已经更新了<code>__DATA</code> 因此类中ivar相对于类实例起始地址的offset也被更新了.</li>
<li>ObjC 可以定义类别，类别可以改变 类的方法,但是 类别的定义可能和类不在同一个 image 中，在加载过程中，也需要做Fix-up,修复方法的指针. 将category中的method 加到class method_list 的前面，这样我们 在OC 运行时顺序查找方法表，先找的是 category 定义的方法.</li>
<li>ObjC 的 selector 是唯一的</li>
</ul>
<p><strong>Initializers</strong></p>
<ul>
<li>C++ 为静态创建的对象生成初始化器</li>
<li>Objc <code>+load</code> 方法，已经废弃,建议使用 <code>+initialize</code></li>
</ul>
<h3 id="2-2-启动调用顺序"><a href="#2-2-启动调用顺序" class="headerlink" title="2.2 启动调用顺序"></a>2.2 启动调用顺序</h3><p>initialize -&gt; dyld -&gt; main() -&gt; UIApplicationMain()</p>
<h2 id="3-dyld3"><a href="#3-dyld3" class="headerlink" title="3 dyld3"></a>3 dyld3</h2><p>在WWDC 2017 上，苹果宣布已经使用 dyld3 来作为系统app的动态链接器</p>
<p><strong>dyld3可以分成三个部分</strong></p>
<ol>
<li>一个进程外的 mach-o 分析器和编译器 处理可能影响启动速度的searchpath @rpaths 和 环境变量，解析mach-o二进制文件，完成符号解析的工作.</li>
<li>一个进程内的引擎 执行启动收尾处理 验证启动收尾，映射动态链接库</li>
<li>一个启动收尾缓存服务  系统程序收尾被直接加入到共享缓存，使用这个工具在系统中运行和分析每个mach-o文件，将它们放入共享缓存，使它映射到缓存中，所有dylib都使用它来启动. 对于第三方程序，在程序安装或系统更新时，生成启动收尾处理（因为系统库那时已经发生更改）</li>
</ol>
<p><strong>为什么启动收尾可以提高启动速度?</strong><br>通过启动收尾，缓存了 符号相对于库中的偏移位置， 这就避免了以后启动程序进程再次进行符号链接的时间消耗。直接从磁盘读取缓存的启动收尾，验证是否正确即可.</p>
<h2 id="4-优化方案"><a href="#4-优化方案" class="headerlink" title="4 优化方案"></a>4 优化方案</h2><p>App 的启动时间: dylib和App可执行文件的加载时间 + - (BOOL)Application:(UIApplication *)Application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions执行时间.</p>
<p><strong>加载images</strong></p>
<ul>
<li>使用更少的非系统dylibs 合并多个dylibs 使用静态库</li>
</ul>
<p><strong>Rebase/Binding</strong></p>
<ul>
<li>减少Objc 类数量，减少selector数量，减少C++虚函数数量，使用Swift struct</li>
</ul>
<p><strong>Initializer</strong><br>Explict Initializer</p>
<ul>
<li>使用 <code>+initialize</code> 而不是 <code>+load</code></li>
<li>不要使用 <strong>atribute</strong>((constructor)) 将方法显式标记为初始化器,而是让初始化方法调用时才执行.可以使用 <code>dispatch_once()</code>,<code>pthread_once()</code>,<code>std::once()</code></li>
</ul>
<p>Implict Initializer</p>
<ul>
<li>在调用的地方使用初始化器</li>
<li>只用简单值类型赋值（POD:Plain Old Data），这样静态链接器会预先计算 __DATA 中的数据，无需再进行 fix-up 工作</li>
<li>使用编译器 warning 标志 -Wglobal-constructors 来发现隐式初始化代码。</li>
<li>苹果还建议更多使用 Swift。Swift 在设计上能避免很多 C、C++ 和 OC 的陷阱；Swift 没有初始化过程；Swift 也不允许不对齐的结构体。这些都对启动时间的优化有一定帮助</li>
</ul>
<h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5 参考"></a>5 参考</h2><blockquote>
<p><a href="https://developer.apple.com/videos/play/wwdc2017/413/" target="_blank" rel="noopener">2017 WWDC Session 413</a></p>
</blockquote>
<blockquote>
<p><a href="https://developer.apple.com/videos/play/wwdc2016/406/" target="_blank" rel="noopener">2016 WWDC Session 406</a></p>
</blockquote>
<blockquote>
<p>《深入理解计算机系统》</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/27/dyld3withappstart/" data-id="ck8hkauun000rotjhawyaf68e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-理解HTTPS" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/26/%E7%90%86%E8%A7%A3HTTPS/" class="article-date">
  <time datetime="2017-09-26T06:47:47.000Z" itemprop="datePublished">2017-09-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/26/%E7%90%86%E8%A7%A3HTTPS/">理解HTTPS</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Monday, 25 September 2017<br>7:36 PM</p>
<blockquote>
<p>文章围绕的问题：</p>
</blockquote>
<ol>
<li>如何解决窃听风险？</li>
<li>如何解决篡改风险？</li>
<li>如何解决冒充风险？</li>
<li>什么是数字证书？</li>
<li>CA证书的验证</li>
<li>什么是签名？</li>
</ol>
<h2 id="HTTPS-简介"><a href="#HTTPS-简介" class="headerlink" title="HTTPS 简介"></a>HTTPS 简介</h2><p>超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。这个协议由网景公司（Netscape）在1994年首次提出，随后扩展到互联网上。</p>
<blockquote>
<p><a href="https://zh.wikipedia.org/zh-cn/超文本传输安全协议" target="_blank" rel="noopener">wikipedia https</a><br>简单的图示<br><img src="https://github.com/JunyiXie/JunyiXie.github.io/raw/master/2017/09/26/%E7%90%86%E8%A7%A3HTTPS/https.png" alt="HTTPS"></p>
</blockquote>
<p><strong>HTTP+加密+认证+完整性保护 = HTTPS.</strong><br> 通常，http直接和tcp通信。当使用ssl/tls时，则演变成先和ssl/tls通信，再由ssl/tls和tcp通讯，因此，https其实就是身披ssl/tls保护外衣的http.</p>
<p> <strong>HTTPS 四次握手的过程</strong></p>
<ol>
<li><p>客户端发出请求<br>在这一步，客户端主要向服务器提供以下信息。<br>（1） 支持的协议版本，比如TLS 1.0版。<br>（2） 一个客户端生成的随机数，稍后用于生成”对话密钥”。<br>（3） 支持的加密方法，比如RSA公钥加密。<br>（4） 支持的压缩方法。</p>
</li>
<li><p>服务器回应<br>服务器收到客户端请求后，向客户端发出回应，这叫severHello.包含如下内容<br>（1）确认使用的加密通信协议版本<br>（2）一个服务器生成的随机数<br>（3）确认使用的加密方法，比如RSA<br>（4）服务器证书</p>
</li>
<li><p>客户端回应<br>客户端验证证书，如果证书没有问题，客户端就会从证书中取出服务器的public-key。向服务器发送下面三项消息。<br>（1）一个随机数。该随机数用服务器public-key加密，防止被窃听<br>（2）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。<br>（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项也是前面发送的所有内容的hash值，用来供服务器校检。</p>
</li>
<li><p>服务器的最后回应<br>服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的“会话密钥”。然后向客户端最后发送下面消息。<br>（1）编码改变通知。表示随后的信息都将用双方商定的加密方法和密钥发送。<br>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash, 用来供服务器校检。</p>
</li>
</ol>
<h2 id="HTTPS-解决了-HTTP-在安全性方面的哪些问题"><a href="#HTTPS-解决了-HTTP-在安全性方面的哪些问题" class="headerlink" title="HTTPS 解决了 HTTP 在安全性方面的哪些问题"></a>HTTPS 解决了 HTTP 在安全性方面的哪些问题</h2><p><strong>HTTP 通信的风险</strong></p>
<ol>
<li>窃听风险：第三方可以获知通信内容</li>
<li>篡改风险：第三方可以修改通信内容</li>
<li>冒充风险：第三方可以冒充他人身份参与通信</li>
</ol>
<p><strong>如何解决这些风险? SSL/TSL 协议</strong></p>
<ol>
<li>加密传播，第三方无法窃听</li>
<li>具有校验机制，一旦被篡改，通信双方会立刻发现</li>
</ol>
<p><strong>SSL/TSL协议有两个问题</strong></p>
<ol>
<li><p>如何保证public-key不被篡改？</p>
<ul>
<li>可信任的第三方认证证书，证书中有public-key</li>
<li>那如何保证证书的可信任性？</li>
</ul>
</li>
<li><p>publick-key计算量太大，如何减少耗用的时间？</p>
<ul>
<li>解决方法：每一次对话（session），客户端和服务器端都生成一个”对话密钥”（session key），用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。</li>
</ul>
</li>
</ol>
<p><strong>上面对HTTPS的介绍 看不懂没关系，下面来了解一些相关的概念</strong></p>
<h2 id="SSL，数字证书，签名，RSA"><a href="#SSL，数字证书，签名，RSA" class="headerlink" title="SSL，数字证书，签名，RSA"></a>SSL，数字证书，签名，RSA</h2><p><strong>SSL/TLS协议的基本过程</strong><br> （1）客户端向服务器索要并验证public-key<br> （2） 双方协商生成“对话密钥”<br> （3）双方采用“对话密钥”进行加密通信</p>
<p> <strong>如何验证数字证书？</strong></p>
<ol>
<li>读取证书发布机构</li>
<li>在操作系统中受信任的发布机构中查找</li>
<li>从证书中取出publick-key对证书的指纹和指纹算法用这个public-key进行解密，然后用这个指纹算法计算证书指纹，然后与证书中的指纹进行对比。</li>
<li>如果一致，说明证书是CA发布的</li>
</ol>
<p><strong>证书如何证明服务器身份</strong><br> 在使用证书之前，通信中，可能出现对方的身份无法确定。<br> 使用证书之后，CA是可信的，通过对证书进行校检，确认证书的合法性，证书合法后，则</p>
<ol>
<li>客户端向服务器发送随机字符串</li>
<li>服务器加密</li>
<li>客户端用证书中的public-key解密，结果一致，则可以证明服务器是证书上的服务器。</li>
</ol>
<p> <strong>RSA</strong><br> RSA是一种公钥密码体制<br> RSA密码体制是一种公钥密码体制，公钥公开，私钥保密，它的加密解密算法是公开的。 由公钥加密的内容可以并且只能由私钥进行解密，并且由私钥加密的内容可以并且只能由公钥进行解密。也就是说，RSA的这一对公钥、私钥都可以用来加密和解密，并且一方加密的内容可以由并且只能由对方进行解密。</p>
<p> 重点：自己保留private-key, 只有private-key加密的内容，才能用public-key解密，这是保证别人无法伪造private-key持有者的重要保障。<strong>也就是说，是无法伪造RSA加密后内容的。</strong></p>
<p> <strong>RSA加密算法在通信过程中起到的作用主要有两个：</strong></p>
<ol>
<li><p>因为私钥只有“服务器”拥有，因此“客户”可以通过判断对方是否有私钥来判断对方是否是“服务器”</p>
</li>
<li><p>客户端通过RSA的掩护，安全的和服务器商量好一个对称加密算法和密钥来保证后面通信过程内容的安全。</p>
<p><strong>签名</strong><br>签名就是在信息的后面再加上一段内容，可以证明信息没有修改过。<br>一般对信息进行hash计算得到一个hash值。在把信息发送时，把签名和签名算法一起发送出去。接收方在接受信息后，用签名算法计算hash值，与签名进行比较。</p>
</li>
</ol>
<ul>
<li><p>报文Hash生成摘要信息Digest,用private-key 加密生成签名</p>
</li>
<li><p>客户端用public-key揭秘签名</p>
</li>
<li><p>客户端对报文做同样的hash处理，和上一步得到的结果进行对比</p>
<p>为了防止他人修改信息内容时，也对hash值进行修改，hash值和算法都会加密，以保证这个hash值不被修改。</p>
</li>
<li><p>加密算法，加密算法后，对方无法根据内容得到相应的hash值，这样就无法伪造内容。</p>
</li>
<li><p>加密hash值，加密后，则可以给接收方一个用来验证的值。</p>
<p>使用rsa加密算法，可以保证签名和hash算法不被他人更改。</p>
</li>
</ul>
<p> <strong>数字证书</strong><br> 数字证书简称CA，它由权威机构给某网站颁发的一种认可凭证，这个凭证是被大家（浏览器）所认可的<br> <strong>为什么需要数字证书？</strong><br> 避免他人冒充服务器</p>
<blockquote>
<p><a href="https://zh.wikipedia.org/wiki/中间人攻击" target="_blank" rel="noopener">中间人攻击</a></p>
</blockquote>
<p> 数字证书一般由证书认证机构颁发，证书里面包含了真实服务器的public-key和网站的其他信息，数字证书机构用自己的private-key加密后发给浏览器，浏览器使用数字证书机构的publick-key揭秘后得到真实服务器的publick-key。</p>
<p><strong>为什么一定要用三个随机数，来生成”会话密钥”</strong></p>
<blockquote>
<p>至于为什么一定要用三个随机数，来生成”会话密钥”，dog250解释得很好：<br>“不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。<br>对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。<br>pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。”</p>
</blockquote>
<h3 id="详细过程图"><a href="#详细过程图" class="headerlink" title="详细过程图"></a>详细过程图</h3><p> <img src="https://github.com/JunyiXie/JunyiXie.github.io/raw/master/2017/09/26/%E7%90%86%E8%A7%A3HTTPS/https_detail.png" alt="https_detail"><br> 注  ：</p>
<ol>
<li><p>双方都进行hash验证</p>
<ul>
<li>服务端知道hash是否正确后，需要让客户端知道自己是否验证正确，客户端也需要验证一次hash，避免服务器造假。</li>
</ul>
</li>
<li><p>D是最后HTTP使用的密钥</p>
<blockquote>
<p>参考文章<br>•    SSL/TLS协议运行机制的概述 <a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a><br>•    图解SSL <a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html</a><br>•    数字证书 <a href="https://blog.cnbluebox.com/blog/2014/03/24/shu-zi-zheng-shu/" target="_blank" rel="noopener">https://blog.cnbluebox.com/blog/2014/03/24/shu-zi-zheng-shu/</a><br>•    数字证书原理 <a href="http://blog.sae.sina.com.cn/archives/4939" target="_blank" rel="noopener">http://blog.sae.sina.com.cn/archives/4939</a><br>•    图解HTTPS <a href="http://www.jianshu.com/p/51cc23843756" target="_blank" rel="noopener">http://www.jianshu.com/p/51cc23843756</a></p>
</blockquote>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/09/26/%E7%90%86%E8%A7%A3HTTPS/" data-id="ck8hkauuy001eotjh99k0364r" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/APM/">APM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hook/">Hook</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A0%94%E5%8F%91%E6%B5%81%E7%A8%8B/">研发流程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/">设计架构</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/04/01/MachOObjC/">MachO（一） ObjC类结构的加载</a>
          </li>
        
          <li>
            <a href="/2020/03/25/DobbyRead/">Dobby源码学习（一） Inline Hook</a>
          </li>
        
          <li>
            <a href="/2020/03/19/cocoapods-new-feature/">cocoapods 新feature 开发 Example, On Demand Resource</a>
          </li>
        
          <li>
            <a href="/2020/03/04/lazybind/">dyld(2) lazy bind 和 dyld_stub_binder</a>
          </li>
        
          <li>
            <a href="/2020/03/03/macholinkedit/">dyld(1) MachO Linkedit 段</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 junyixie<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>