<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>xiejunyi Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="xiejunyi Blog">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;page&#x2F;2&#x2F;index.html">
<meta property="og:site_name" content="xiejunyi Blog">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="xiejunyi Blog" type="application/atom+xml">
  
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  <link rel="stylesheet" href="/css/styles.css">
  

</head>

<body>
  <nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">xiejunyi Blog</h1>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          
  
    <article id="post-sharedlibraryandpic" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/15/sharedlibraryandpic/">fishhook与共享库和PIC</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2018/01/15/sharedlibraryandpic/" class="article-date"><time datetime="2018-01-14T16:35:39.000Z" itemprop="datePublished">2018-01-15</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Hook/">Hook</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>fishhook是不能hook同一个library内的符号调用的，在某个issus的解答如下。</p>
<blockquote>
<p>People have had issues with socket and/or connect in the past. One problem is that fishhook can only hook external calls, which means function calls within the same library generally cannot be hooked. In this case, calls to socket and connect from within the same library (libSystem) cannot be hooked. With the simulator, the system libraries are broken out into many sub-libraries, including libsystem_networking. With many sub-libraries, this means function calls from one sub-library to another can be hooked on the simulator, but on device where there’s just a single libSystem, those same calls are within the same library and cannot be hooked.</p>
</blockquote>
<p>这是由于fishhook利用 Macho-O dyld link 的 dynamically rebinding symbols实现所导致的。</p>
<p>这边文章就围绕这个话题来展开，解释一下la_symbol_ptr存在的原因。由于Mac OS 上使用 stubs, la_symbol_ptrs, stub_helper来实现延迟绑定的原理和Linux ELF差不多，这里就使用ELF的实现来解释。</p>
<h2 id="PIC位置无关代码的引入"><a href="#PIC位置无关代码的引入" class="headerlink" title="PIC位置无关代码的引入"></a>PIC位置无关代码的引入</h2><p>设想一个场景，因为Linux/Mac os使用的是虚拟内存系统，这意味着共享库引用的外部符号地址在不同进程的虚拟内存中是不同的，对应到物理内存中TEXT段也不同，所以必须拷贝多份。这显然是不可以接受的，内存中存在了大量拷贝，浪费RAM资源。</p>
<p>如果我们共享库对外部引用是位置无关的就好了，就不会存在这个问题。</p>
<h3 id="GOT-全局偏移表"><a href="#GOT-全局偏移表" class="headerlink" title="GOT 全局偏移表"></a>GOT 全局偏移表</h3><p>这时利用DATA段读写的特性，DATA段会在内存中有多份拷贝，并且DATA段和TEXT段的距离不变，在DATA段存储变化的地址，TEXT段使用指向DATA段对应位置的引用。这就解决了TEXT段共享的问题。这里我们引入了一个全局偏移量表，GOT。动态链接器会重定位GOT中的每个条目，使得它包含正确的绝对地址。</p>
<h3 id="PIC函数调用-和-PLT过程链接表"><a href="#PIC函数调用-和-PLT过程链接表" class="headerlink" title="PIC函数调用 和 PLT过程链接表"></a>PIC函数调用 和 PLT过程链接表</h3><p>使用GOT这种方式，我们每次调用函数都需要额外的三条指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">        call L1</span><br><span class="line">L1:   popl %ebx </span><br><span class="line">        addl $PROCOFF, %ebx</span><br><span class="line">        call *(%ebx)</span><br></pre></td></tr></table></figure>
<ol>
<li>将PC的值移到 ebx中</li>
<li>ebx 指向GOT中适当的条目</li>
</ol>
<p>这样的效率未免有些低。于是引入了 延迟绑定的技术，将过程地址的绑定推迟到第一次调用该过程时。第一次调用过程的运行时开销很大，但是其后的每次调用都只会花费一条指令和一个间接地存储器引用。</p>
<p><strong>过程</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call 8048464</span><br></pre></td></tr></table></figure>
<p>调用相应的PLT条目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jmp *0x8049684</span><br><span class="line">pushl $0x8</span><br><span class="line">jmp 8048444</span><br></pre></td></tr></table></figure>
<p>跳转到addvec</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/15/sharedlibraryandpic/" data-id="ck3g0y6zb0015qy36furh1n6v" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-In-depthUnderStandingOfThreadSafety" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/24/In-depthUnderStandingOfThreadSafety/">理解线程安全</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/12/24/In-depthUnderStandingOfThreadSafety/" class="article-date"><time datetime="2017-12-24T07:29:03.000Z" itemprop="datePublished">2017-12-24</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="线程安全问题的来源"><a href="#线程安全问题的来源" class="headerlink" title="线程安全问题的来源"></a>线程安全问题的来源</h2><blockquote>
<p>线程安全是编程中的术语，指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。</p>
</blockquote>
<p>可以看到这一切的诱因就是因为共享变量。如果我们的线程执行过程中，没有相互影响，就不会出现问题。</p>
<p>当我们的线程访问共享变量时，我们无法预测操作系统是否将为我们的线程选择一个正确的顺序。这就尴尬了！</p>
<p>对多个线程对资源的访问，我们称之为 竞争。</p>
<p>由于两个或者多个进程竞争使用不能被同时访问的资源，使得这些进程有可能因为时间上推进的先后原因而出现问题，这叫做竞争条件（Race Condition）。</p>
<p><strong>竞争条件分为两类</strong></p>
<ol>
<li>Mutex 不能被多个进程同时使用的资源</li>
<li>Synchronization 两个或多个进程彼此指针存在内在的制约关系</li>
</ol>
<ul>
<li>消费者生产者问题就是同步问题，它需要调度对共享资源的访问，是  Synchronization。</li>
<li>读者写者问题是互斥问题的一个概括。</li>
</ul>
<p><strong>消费者生产者问题</strong></p>
<blockquote>
<p>因为插入和取出项目都涉及更新共享变量，所以我们必须保证对缓冲区的访问是互斥的。但是只保证互斥访问是不够的，我们还需要调度对缓冲区的访问。如果缓冲区是满的，那么生产者必须等待直到有一个槽位变为可用。与之相似，如果缓冲区是空的，那么消费者必须等待直到有一个项目变为可用。</p>
</blockquote>
<p><strong>读者-写者问题</strong></p>
<blockquote>
<p>读者写者问题是互斥问题的一个概括。一组并发的线程要访问一个共享对象。写者必须拥有对对象独占的访问。</p>
</blockquote>
<h2 id="如何保证线程安全"><a href="#如何保证线程安全" class="headerlink" title="如何保证线程安全"></a>如何保证线程安全</h2><p>在我们需要访问共享变量的情况下，我们需要保证线程执行顺序的正确性。或者我们尽量避免使用共享变量。</p>
<p><strong>进度图</strong><br>如果我们用 纵横坐标分别表示两个进程执行的指令顺序，那么操作共享变量的指令会构成一个二维的不安全区，当两条线程的执行轨迹会同时访问不安全区时，我们就认为执行是不安全的。(局限性：无法描述多处理器并发执行)</p>
<p>我们可以选择安全的轨迹线，或者使用信号量实现互斥。</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>思考一下，锁做了什么？</p>
<p>lock是在执行多线程时用于强行限制资源访问的同步机制，即用于在并发控制中保证对互斥要求的满足.<br>对于竞争条件中的 Mutex 我们可以使用互斥锁处理。Synchronization 可以使用条件锁。<br>使用lock是可以保证线程安全的，但不能保证线程的执行顺序。</p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>原子性（Atomic），一个事务包含多个操作，这些操作要么全部执行，要么全都不执行。</p>
<p>OC 中一个很经典的面试题是， property 设置 atomic 能保证线程安全吗？<br>很多人都回答可以，这是压根没理解线程安全的体现。<br><strong>原子性不能保证线程安全</strong><br>原子性可以保证写操作一小块代码段是互斥的，但是并不能保证线程安全。</p>
<p>设置atomic之后，只是保证了 属性的赋值操作是互斥的，可惜只是该属性..<br>不能保证我们整个代码的线程安全。</p>
<p>考虑一段代码.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.a = <span class="number">0</span>;<span class="comment">//1</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.a == <span class="number">0</span>) &#123;</span><br><span class="line">    print(<span class="string">"safe"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    print(<span class="string">"unsafe"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 self.a = 0; 执行完毕后</p>
<p>处理机调度，切换到另一个线程执行</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.b = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>再次切换为原先的线程<br>此时，结果是<br><strong>unsafe.</strong><br>我们原先的值被其他线程篡改了。并不能保证线程安全。</p>
<p>会想一下 那经典的 进度图，原子性无法阻止多个线程访问不安全区。</p>
<p>加锁之后，就保证 代码块 不会被多个进程访问，保证了线程安全。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lock();</span><br><span class="line"><span class="keyword">self</span>.a = <span class="number">0</span>;<span class="comment">//1</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.a == <span class="number">0</span>) &#123;</span><br><span class="line">    print(<span class="string">"safe"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    print(<span class="string">"unsafe"</span>);</span><br><span class="line">&#125;</span><br><span class="line">unlock();</span><br></pre></td></tr></table></figure>


<h2 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h2><p>不可变性，这个跟线程安全关系大吗？<br>显然，我们对共享变量的访问，会导致线程安全问题是因为我们对其进行了写操作。不可变可以避免代码编写中因为疏忽导致的问题。真正处理线程安全的时候，你遇到的，会是可变的共享变量！<br>所以，这个对线程安全问题，没有用处。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/24/In-depthUnderStandingOfThreadSafety/" data-id="ck3g0y6yp0007qy366l3kca81" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-safeSwizzleRSSwizzleAnalyze" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/04/safeSwizzleRSSwizzleAnalyze/">Method Swizzling 的正确途径</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/12/04/safeSwizzleRSSwizzleAnalyze/" class="article-date"><time datetime="2017-12-04T06:08:16.000Z" itemprop="datePublished">2017-12-04</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Hook/">Hook</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>iOS 平台开发，有时会使用到Method Swizzling,  但Method Swizzling 在使用过程中有许多需要注意的问题，本文将介绍将会产生的问题，并且分析 <a href="https://github.com/rabovik/RSSwizzle" target="_blank" rel="noopener">RSSwizzle</a> 是如何解决这些问题的。</p>
<h2 id="在Objective-C-中方法交换有什么危险"><a href="#在Objective-C-中方法交换有什么危险" class="headerlink" title="在Objective-C 中方法交换有什么危险"></a>在Objective-C 中方法交换有什么危险</h2><p><a href="https://stackoverflow.com/questions/5339276/what-are-the-dangers-of-method-swizzling-in-objective-c?answertab=active#tab-top" target="_blank" rel="noopener">What are the Dangers of Method Swizzling in Objective C?</a><br>stackoverflow 上的这个回答十分精彩。</p>
<pre><code>- Method swizzling 并不是原子操作
- 改变了不是我们自己代码的行为
- 有可能出现命名冲突
- Swizzling 改变方法的参数
- Swizzles 顺序问题
- 难于理解
- 难于Debug</code></pre><h3 id="Swizzling-改变方法的参数-例子"><a href="#Swizzling-改变方法的参数-例子" class="headerlink" title="Swizzling 改变方法的参数 例子"></a>Swizzling 改变方法的参数 例子</h3><p>使用<code>method_exchangeImplementations</code>更改方法的实现，会导致一个问题，origin_imp 如果使用了 _cmd 参数，hook之后的_cmd 是不符合预期的。</p>
<p>hook <code>touchesBegan</code> 过的同学应该遇到这种问题。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br></pre></td></tr></table></figure>

<p>这个函数里面 调用了 <code>forwardTouchMethod</code> , 反汇编后类似这种。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    forwardTouchMethod(<span class="keyword">self</span>, _cmd, touches, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> forwardTouchMethod(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="built_in">NSSet</span> *touches, <span class="built_in">UIEvent</span> *event) &#123;</span><br><span class="line">  <span class="comment">// The responder chain is used to figure out where to send the next touch</span></span><br><span class="line">    <span class="built_in">UIResponder</span> *nextResponder = [<span class="keyword">self</span> nextResponder];</span><br><span class="line">    <span class="keyword">if</span> (nextResponder &amp;&amp; nextResponder != <span class="keyword">self</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Not all touches are forwarded - so we filter here.</span></span><br><span class="line">        <span class="built_in">NSMutableSet</span> *filteredTouches = [<span class="built_in">NSMutableSet</span> set];</span><br><span class="line">        [touches enumerateObjectsUsingBlock:^(<span class="built_in">UITouch</span> *touch, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Checks every touch for forwarding requirements.</span></span><br><span class="line">            <span class="keyword">if</span> ([touch _wantsForwardingFromResponder:<span class="keyword">self</span> toNextResponder:nextResponder withEvent:event]) &#123;</span><br><span class="line">                [filteredTouches addObject:touch];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// This is interesting legacy behavior. Before iOS 5, all touches are forwarded (and this is logged)</span></span><br><span class="line">                <span class="keyword">if</span> (!_UIApplicationLinkedOnOrAfter(<span class="number">12</span>)) &#123;</span><br><span class="line">                    [filteredTouches addObject:touch];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Log old behavior</span></span><br><span class="line">                    <span class="keyword">static</span> <span class="built_in">BOOL</span> didLog = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!didLog) &#123;</span><br><span class="line">                        <span class="built_in">NSLog</span>(<span class="string">@"Pre-iOS 5.0 touch delivery method forwarding relied upon. Forwarding -%@ to %@."</span>, <span class="built_in">NSStringFromSelector</span>(_cmd), nextResponder);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// here we basically call [nextResponder touchesBegan:filteredTouches event:event];</span></span><br><span class="line">        [nextResponder performSelector:_cmd withObject:filteredTouches withObject:event];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们exchange了 imp, <code>[nextResponder performSelector:_cmd withObject:filteredTouches withObject:event];</code> 是没有相应的实现的，<strong>_cmd</strong> 就变成了 我们替换的 sel. 显然，nextResponder没有实现相应的方法，就会crash。</p>
<h4 id="正确的hook方式"><a href="#正确的hook方式" class="headerlink" title="正确的hook方式"></a><strong>正确的hook方式</strong></h4><p><strong>方案一:</strong><br>直接替换 method 的 IMP.<br><code>method_setImplementation</code>, 在新的IMP中调用原始的 IMP.</p>
<h2 id="RSSwizzle"><a href="#RSSwizzle" class="headerlink" title="RSSwizzle"></a>RSSwizzle</h2><p><strong>RSSwizzle 实现方式</strong><br>    1. 根据block生成NEW IMP<br>    2. replace 目标方法的实现<br>    3. block可以获取原来的IMP</p>
<p><strong>核心交换代码</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> swizzle(Class classToSwizzle,</span><br><span class="line">                    SEL selector,</span><br><span class="line">                    RSSwizzleImpFactoryBlock factoryBlock)</span><br><span class="line">&#123;</span><br><span class="line">    Method method = class_getInstanceMethod(classToSwizzle, selector);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSCAssert</span>(<span class="literal">NULL</span> != method,</span><br><span class="line">              <span class="string">@"Selector %@ not found in %@ methods of class %@."</span>,</span><br><span class="line">              <span class="built_in">NSStringFromSelector</span>(selector),</span><br><span class="line">              class_isMetaClass(classToSwizzle) ? <span class="string">@"class"</span> : <span class="string">@"instance"</span>,</span><br><span class="line">              classToSwizzle);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSCAssert</span>(blockIsAnImpFactoryBlock(factoryBlock),</span><br><span class="line">             <span class="string">@"Wrong type of implementation factory block."</span>);</span><br><span class="line">    </span><br><span class="line">    __block OSSpinLock lock = OS_SPINLOCK_INIT;</span><br><span class="line">    <span class="comment">// To keep things thread-safe, we fill in the originalIMP later,</span></span><br><span class="line">    <span class="comment">// with the result of the class_replaceMethod call below.</span></span><br><span class="line">    __block IMP originalIMP = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This block will be called by the client to get original implementation and call it.</span></span><br><span class="line">    RSSWizzleImpProvider originalImpProvider = ^IMP&#123;</span><br><span class="line">        <span class="comment">// It's possible that another thread can call the method between the call to</span></span><br><span class="line">        <span class="comment">// class_replaceMethod and its return value being set.</span></span><br><span class="line">        <span class="comment">// So to be sure originalIMP has the right value, we need a lock.</span></span><br><span class="line">        OSSpinLockLock(&amp;lock);</span><br><span class="line">        IMP imp = originalIMP;</span><br><span class="line">        OSSpinLockUnlock(&amp;lock);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == imp)&#123;</span><br><span class="line">            <span class="comment">// If the class does not implement the method</span></span><br><span class="line">            <span class="comment">// we need to find an implementation in one of the superclasses.</span></span><br><span class="line">            Class superclass = class_getSuperclass(classToSwizzle);</span><br><span class="line">            imp = method_getImplementation(class_getInstanceMethod(superclass,selector));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> imp;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    RSSwizzleInfo *swizzleInfo = [RSSwizzleInfo new];</span><br><span class="line">    swizzleInfo.selector = selector;</span><br><span class="line">    swizzleInfo.impProviderBlock = originalImpProvider;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// We ask the client for the new implementation block.</span></span><br><span class="line">    <span class="comment">// We pass swizzleInfo as an argument to factory block, so the client can</span></span><br><span class="line">    <span class="comment">// call original implementation from the new implementation.</span></span><br><span class="line">    <span class="keyword">id</span> newIMPBlock = factoryBlock(swizzleInfo);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *methodType = method_getTypeEncoding(method);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSCAssert</span>(blockIsCompatibleWithMethodType(newIMPBlock,methodType),</span><br><span class="line">             <span class="string">@"Block returned from factory is not compatible with method type."</span>);</span><br><span class="line">    </span><br><span class="line">    IMP newIMP = imp_implementationWithBlock(newIMPBlock);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Atomically replace the original method with our new implementation.</span></span><br><span class="line">    <span class="comment">// This will ensure that if someone else's code on another thread is messing</span></span><br><span class="line">    <span class="comment">// with the class' method list too, we always have a valid method at all times.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If the class does not implement the method itself then</span></span><br><span class="line">    <span class="comment">// class_replaceMethod returns NULL and superclasses's implementation will be used.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// We need a lock to be sure that originalIMP has the right value in the</span></span><br><span class="line">    <span class="comment">// originalImpProvider block above.</span></span><br><span class="line">    OSSpinLockLock(&amp;lock);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// originIMP get value from here</span></span><br><span class="line">    originalIMP = class_replaceMethod(classToSwizzle, selector, newIMP, methodType);</span><br><span class="line">    OSSpinLockUnlock(&amp;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>具体过程解析</strong></p>
<p><strong>如果hook的方法在hook的类中有实现</strong><br>    1. block生成新的IMP<br>    2. 替换IMP, 这时候拿到原始的ORIGINIMP<br>    3. block接受了一个RSSwizzleInfo参数，从参数中可以拿到当时保存的获得IMP的block<br>    4. 由于block中存储的是originIMP ，所以获得的是原始的实现</p>
<p><strong>如果hook的方法在子类中无实现</strong><br>    1. block生成新的IMP<br>    2. 替换IMP（由于没有实现，相当于add了IMP）, 原始的实现为nil<br>    3. block 中我们调用calloriginIMP,这个方法实际调用了一个block originalImpProvider<br>    4. 这个block的从父类找到相应的实现（注意，这里实际上是在 调用方法 时才会触发）</p>
<p>这种情况是调用时，动态获得 当时的方法实现，所以可以避免hook顺序带来的问题。</p>
<h3 id="那么影响Swizzle的结果到底是是什么呢？"><a href="#那么影响Swizzle的结果到底是是什么呢？" class="headerlink" title="那么影响Swizzle的结果到底是是什么呢？"></a>那么影响Swizzle的结果到底是是什么呢？</h3><p>Swizzle实现方式本质上就是改变方法的IMP 为 NewIMP, 并调用原先的originIMP</p>
<p>只hook一个是没问题，但是涉及到多次hook, 并且hook的方法可能为一个时， 他们的顺序就会导致不同的结果，因为顺序不同，Swizzle时，Method 相应的 IMP 不相同。<br>这里我们更关注，父子类+hook 同一个方法产生的问题。</p>
<p><strong>那么RSSwizzle  怎么解决问题的呢？</strong></p>
<p>父类有method, 子类没有实现method.<br>我们有如下的IMP:<code>superIMP</code>,<code>superNewIMP</code>,<code>subNewIMp</code><br>此时，我们Swizzle 父类的method 为 superNewIMP<br>Swizzle子类的method 为 subNewIMp</p>
<p><strong>首先关注我们期望的调用顺序</strong><br>    1. subNewIMP<br>    2. superNewIMP<br>    3. superIMP</p>
<p><strong>我们先hook父类，再hook子类后，的调用顺序</strong><br>    1. subNewImp<br>    2. superNewIMP<br>    3. superIMp</p>
<p><strong>先hook子类再hook父类</strong><br>    1. subNewIMP<br>    2. superIMP</p>
<p><strong>为什么会有差异?</strong><br>因为当我们在hook子类方法时，原先的方法实现是不同的。</p>
<p><strong>解决问题</strong><br>那就要保证，即使hook的顺序不同，也能正确取到相应的IMP<br>那我们保证，子类在调用相应方法的时候，取到的IMP是父类当前的IMP就可以(这样就和Swizzle的时间顺序没有了关系)</p>
<h2 id="RSSwizzle-加锁，保证线程安全"><a href="#RSSwizzle-加锁，保证线程安全" class="headerlink" title="RSSwizzle 加锁，保证线程安全"></a>RSSwizzle 加锁，保证线程安全</h2><p><strong><code>originalImpProvider</code> 的代码</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RSSWizzleImpProvider originalImpProvider = ^IMP&#123;</span><br><span class="line">    OSSpinLockLock(&amp;lock);</span><br><span class="line">    IMP imp = originalIMP;</span><br><span class="line">    OSSpinLockUnlock(&amp;lock);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == imp)&#123;</span><br><span class="line">        Class superclass = class_getSuperclass(classToSwizzle);</span><br><span class="line">        imp = method_getImplementation(class_getInstanceMethod(superclass,selector));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Swizzle 方法的某个部分</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OSSpinLockLock(&amp;lock);</span><br><span class="line">originalIMP = class_replaceMethod(classToSwizzle, selector, newIMP, methodType);</span><br><span class="line">OSSpinLockUnlock(&amp;lock);</span><br></pre></td></tr></table></figure>

<p>这两个方法有个共享变量 originalIMP，这就意味着，可能会出现线程安全问题。再仔细看下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OSSpinLockLock(&amp;lock);</span><br><span class="line">IMP imp = originalIMP;</span><br><span class="line">OSSpinLockUnlock(&amp;lock);</span><br><span class="line">if (NULL == imp)&#123;</span><br></pre></td></tr></table></figure>
<p>这个共享变量，和条件判断相关。敏锐的同学一眼就能看出来，在不加锁的情况下，当不同的线程对 这两段代码进行执行的时候，就会出现，即使<code>if (NULL == imp){</code>通过了，但实际上，另一条线程执行了<code>class_replaceMethod()</code>。这时就会出现问题。</p>
<p>在加锁之后，在同一时间段内，只有一个线程能访问改变这个变量的代码。避免了共享变量导致的线程安全问题。</p>
<h2 id="采用Block添加实现，没有命名冲突问题"><a href="#采用Block添加实现，没有命名冲突问题" class="headerlink" title="采用Block添加实现，没有命名冲突问题"></a>采用Block添加实现，没有命名冲突问题</h2><p>连命名的机会都没有…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RSSwizzleInstanceMethod(classToSwizzle,</span><br><span class="line">                        @selector(calculate:),</span><br><span class="line">                        RSSWReturnType(int),</span><br><span class="line">                        RSSWArguments(int number),</span><br><span class="line">                        RSSWReplacement(</span><br><span class="line">&#123;</span><br><span class="line">    // The following code will be used as the new implementation.</span><br><span class="line"></span><br><span class="line">    // Calling original implementation.</span><br><span class="line">    int res = RSSWCallOriginal(number);</span><br><span class="line">    // Returning modified return value.</span><br><span class="line">    return res + 1;</span><br><span class="line">&#125;), 0, NULL);</span><br></pre></td></tr></table></figure>

<h2 id="采用block-添加实现，只是改变了原来的IMP-，Selector没有改变，实现的-cmd并没有改变"><a href="#采用block-添加实现，只是改变了原来的IMP-，Selector没有改变，实现的-cmd并没有改变" class="headerlink" title="采用block 添加实现，只是改变了原来的IMP ，Selector没有改变，实现的_cmd并没有改变"></a>采用block 添加实现，只是改变了原来的IMP ，Selector没有改变，实现的<code>_cmd</code>并没有改变</h2><p>参数<code>_cmd</code>是当前方法的selector</p>
<p>swizzle method 可能会导致的<code>_cmd</code> 参数改变，例如<br>我们有<code>originMethod</code>和<code>newMethod</code>,他们分别对应着 <code>OriginIMP</code>,和<code>NewIMP</code>.<br>当我们交换方法实现后:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">originmethod -&gt; NewIMP</span><br><span class="line">newMethod -&gt; OriginIMP</span><br></pre></td></tr></table></figure>
<p>要想调用原来的实现，我们需要调用 <code>newMethod</code> 这就导致了 相同的IMP 但是<code>_cmd</code> 却改变了 </p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/04/safeSwizzleRSSwizzleAnalyze/" data-id="ck3g0y6zb0013qy3632ttc091" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-ioshookanalysis" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/30/ioshookanalysis/">iOS Hook 方案解析</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/11/30/ioshookanalysis/" class="article-date"><time datetime="2017-11-30T03:37:13.000Z" itemprop="datePublished">2017-11-30</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Hook/">Hook</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>最近研究了一下iOS平台上几个hook框架的hook方案，写文记录一下分析的过程</strong></p>
<h2 id="现有hook框架"><a href="#现有hook框架" class="headerlink" title="现有hook框架"></a>现有hook框架</h2><ol>
<li>AnyMethodLog</li>
<li>Aspects</li>
</ol>
<h2 id="AnyMethodLog-hook-方案分析"><a href="#AnyMethodLog-hook-方案分析" class="headerlink" title="AnyMethodLog hook 方案分析"></a>AnyMethodLog hook 方案分析</h2><p>Hook 代码 </p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//替换方法</span></span><br><span class="line"><span class="built_in">BOOL</span> qhd_replaceMethod(Class cls, SEL originSelector, <span class="keyword">char</span> *returnType) &#123;</span><br><span class="line">    Method originMethod = class_getInstanceMethod(cls, originSelector);</span><br><span class="line">    <span class="keyword">if</span> (originMethod == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *originTypes = method_getTypeEncoding(originMethod);</span><br><span class="line">    IMP msgForwardIMP = _objc_msgForward;</span><br><span class="line"><span class="meta">#if !defined(__arm64__)</span></span><br><span class="line">    <span class="keyword">if</span> (qhd_isStructType(returnType)) &#123;</span><br><span class="line">        <span class="comment">//Reference JSPatch:</span></span><br><span class="line">        <span class="comment">//In some cases that returns struct, we should use the '_stret' API:</span></span><br><span class="line">        <span class="comment">//http://sealiesoftware.com/blog/archive/2008/10/30/objc_explain_objc_msgSend_stret.html</span></span><br><span class="line">        <span class="comment">//NSMethodSignature knows the detail but has no API to return, we can only get the info from debugDescription.</span></span><br><span class="line">        <span class="built_in">NSMethodSignature</span> *methodSignature = [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:originTypes];</span><br><span class="line">        <span class="keyword">if</span> ([methodSignature.debugDescription rangeOfString:<span class="string">@"is special struct return? YES"</span>].location != <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">            msgForwardIMP = (IMP)_objc_msgForward_stret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    </span><br><span class="line">    IMP originIMP = method_getImplementation(originMethod);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (originIMP == <span class="literal">nil</span> || originIMP == msgForwardIMP) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把原方法的IMP换成_objc_msgForward，使之触发forwardInvocation方法</span></span><br><span class="line">    class_replaceMethod(cls, originSelector, msgForwardIMP, originTypes);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把方法forwardInvocation的IMP换成qhd_forwardInvocation</span></span><br><span class="line">    class_replaceMethod(cls, <span class="keyword">@selector</span>(forwardInvocation:), (IMP)qhd_forwardInvocation, <span class="string">"v@:@"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建一个新方法，IMP就是原方法的原来的IMP，那么只要在qhd_forwardInvocation调用新方法即可</span></span><br><span class="line">    SEL newSelecotr = qhd_createNewSelector(originSelector);</span><br><span class="line">    <span class="built_in">BOOL</span> isAdd = class_addMethod(cls, newSelecotr, originIMP, originTypes);</span><br><span class="line">    <span class="keyword">if</span> (!isAdd) &#123;</span><br><span class="line">        DEV_LOG(<span class="string">@"class_addMethod fail"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>阐述一下具体的过程:</strong></p>
<ol>
<li><p>如何让方法每次都走_objc_msgForward呢？把原来的 sel的IMP改成_objc_msgForward.</p>
</li>
<li><p>这时我们需要保存原来的 IMP 然后hook forwardInvocation … 换成自己的实现，调用原来的IMP和新增的代码</p>
</li>
</ol>
<p>从代码很明显的可以看出，这是利用OC的消息转发机制，选择了合适的时机，进行打桩。<br>相较于传统的Swizzle方法，这种方法打主桩，是有可行性的。<br>并且在ForwardInvocation: 处理，虽然相较其余两个转发机制调用的方法的消耗大，但是更灵活一些，最切合问题。</p>
<h2 id="Aspects"><a href="#Aspects" class="headerlink" title="Aspects"></a>Aspects</h2><p>Aspects 的代码我看的比较仔细，相对于AnyMethodLog, Aspects 对Hook的处理更成熟，各种情况都做了考虑，这里来重点分析下。</p>
<p>相较于AnyMethodLog, Aspects 不仅可以hook类，也可以对实例进行hook, 粒度更小，适用的场景更加多样化。</p>
<p>这是Aspects Hook 的代码，可以看到对实例和类的处理是不同的。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Class aspect_hookClass(<span class="built_in">NSObject</span> *<span class="keyword">self</span>, <span class="built_in">NSError</span> **error) &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(<span class="keyword">self</span>);</span><br><span class="line">	Class statedClass = <span class="keyword">self</span>.class;</span><br><span class="line">	Class baseClass = object_getClass(<span class="keyword">self</span>);</span><br><span class="line">	<span class="built_in">NSString</span> *className = <span class="built_in">NSStringFromClass</span>(baseClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Already subclassed</span></span><br><span class="line">	<span class="keyword">if</span> ([className hasSuffix:AspectsSubclassSuffix]) &#123;</span><br><span class="line">		<span class="keyword">return</span> baseClass;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We swizzle a class object, not a single object.</span></span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span> (class_isMetaClass(baseClass)) &#123;</span><br><span class="line">        <span class="keyword">return</span> aspect_swizzleClassInPlace((Class)<span class="keyword">self</span>);</span><br><span class="line">        <span class="comment">// Probably a KVO'ed class. Swizzle in place. Also swizzle meta classes in place.</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (statedClass != baseClass) &#123;</span><br><span class="line">        <span class="keyword">return</span> aspect_swizzleClassInPlace(baseClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Default case. Create dynamic subclass.</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *subclassName = [className stringByAppendingString:AspectsSubclassSuffix].UTF8String;</span><br><span class="line">	Class subclass = objc_getClass(subclassName);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (subclass == <span class="literal">nil</span>) &#123;</span><br><span class="line">		subclass = objc_allocateClassPair(baseClass, subclassName, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (subclass == <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *errrorDesc = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"objc_allocateClassPair failed to allocate class %s."</span>, subclassName];</span><br><span class="line">            AspectError(AspectErrorFailedToAllocateClassPair, errrorDesc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		aspect_swizzleForwardInvocation(subclass);</span><br><span class="line">		aspect_hookedGetClass(subclass, statedClass);</span><br><span class="line">		aspect_hookedGetClass(object_getClass(subclass), statedClass);</span><br><span class="line">		objc_registerClassPair(subclass);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	object_setClass(<span class="keyword">self</span>, subclass);</span><br><span class="line">	<span class="keyword">return</span> subclass;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">先看看对实例的处理</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```objectivec</span><br><span class="line">		subclass = objc_allocateClassPair(baseClass, subclassName, <span class="number">0</span>);</span><br><span class="line">		aspect_swizzleForwardInvocation(subclass);</span><br><span class="line">		aspect_hookedGetClass(subclass, statedClass);</span><br><span class="line">		aspect_hookedGetClass(object_getClass(subclass), statedClass);</span><br><span class="line">		objc_registerClassPair(subclass);</span><br><span class="line">	    object_setClass(<span class="keyword">self</span>, subclass);</span><br></pre></td></tr></table></figure>

<p>熟悉kvo原理的同学，一眼就应该看明白了，这是做了什么事情。<br>这里可谓是相当巧妙的避免了父类和子类实例hook相同的IMP可能导致的循环调用问题。(下一部分会说明如何避免的)</p>
<p>对类的hook和AnyMethodLog十分类似。就不再多阐述了。网上相关介绍 使用 forwardInvocation+hook类 的资料很多。</p>
<p>Aspects和AnyMethodLog都是利用了forwardInvocation进行处理，这是一致的。</p>
<h2 id="现行Hook方案的问题"><a href="#现行Hook方案的问题" class="headerlink" title="现行Hook方案的问题"></a>现行Hook方案的问题</h2><p>自己经常hook的同学可能会发现，在hook时，会出现调用循环的问题。</p>
<p>无论是AnyMethodLog 和 Aspects 都无法同时hook 父类和子类的同一个方法到一个相同的IMP上。为什么呢？</p>
<p>思考一下为什么会出现循环调用？ 那必定是，调用方又被调用者调用了一次，在iOS Hook 中，如果我们hook 了 父类和子类的同一个方法，让他们拥有相同的实现，就会出现这种问题。</p>
<blockquote>
<p>看一下阿里🌟的阐述，我觉得还是很清晰的<br><a href="http://satanwoo.github.io/2017/09/24/mainthreadchecker1/" target="_blank" rel="noopener">基于桥的全量方法Hook方案 - 探究苹果主线程检查实现</a><br>假设我们现在对UIView、UIButton都Hook了initWithFrame:这个方法，在调用[[UIView alloc] initWithFrame:]和[[UIButton alloc] initWithFrame:]都会定向到C函数qhd_forwardInvocation中，在UIView调用的时候没问题。但是在UIButton调用的时候，由于其内部实现获取了super initWithFrame:，就产生了循环定向的问题。 </p>
</blockquote>
<p>Aspects 中，Hook 之前，是要对能否hook 进行检查了，对于类，有严格的限制，对于实例则没有限制。</p>
<p>类为什么要限制，上面已经阐释了，那么实例为什么可以呢？</p>
<p>这就是 实例Hook 实现方式所产生的结果。</p>
<p><strong>来理一下实例hook怎么实现的：</strong></p>
<ol>
<li>生成子类</li>
<li>hook 子类的forwardInvocation(这是一系列操作，不过这个尤为重要)</li>
<li>对实例的类信息进行伪装</li>
</ol>
<p>如果我们有 ClassA 的 实例 a, SubClassA 的 实例 suba.<br>对他们进行hook <code>viewdidload</code> 方法, 那么会生成两个子类，我们记为prefix_ClassA, prefix_SubClassA,我们对forwardInvocation IMP的替换，实际上是在这两个类上进行的。</p>
<p>当方法调用时:<br>suba -&gt; forwardInvocation(我们替换的IMP) -&gt;self viewdidload(SubClassA 的IMP) -&gt; super viewdidload(ClassA的实现)<br>这显然不会导致循环的问题。</p>
<p>如果不采用对生成的子类hook，就会出现问题，可以过一遍方法调用的流程。</p>
<p>总之，还是父类子类的相同方法是否是同一个IMP的核心问题。</p>
<p>随后，Aspects 做了 如果是真正的消息转发响应的处理，有兴趣的同学可以看一下。<br>JSPatch 的方法替换也是利用了 forwardInvocation进行处理。</p>
<h2 id="方法混写和ISA混写"><a href="#方法混写和ISA混写" class="headerlink" title="方法混写和ISA混写"></a>方法混写和ISA混写</h2><p>今天无意在 feiox 留给我的书上发现了这个定义。<br>再把 Aspects 和 AnyMethodLog 的实现相结合，发现书上说的真的贴切。</p>
<ul>
<li><strong>方法混写</strong><ul>
<li>影响一个类的所有实例</li>
<li>高度透明，所有对象的类都不变</li>
<li>需要特殊的覆盖方法实现</li>
</ul>
</li>
<li><strong>ISA混写</strong><ul>
<li>只影响目标实例</li>
<li>对象的类会变化(不过可以通过覆盖class方法隐藏)</li>
<li>覆盖方法使用标准的子类技术实现的</li>
</ul>
</li>
</ul>
<h2 id="实战中犯过的错误"><a href="#实战中犯过的错误" class="headerlink" title="实战中犯过的错误"></a>实战中犯过的错误</h2><ol>
<li>父子类  使用category  hook 同一个方法，并且hook的新方法名还是一样的</li>
</ol>
<p>// TableViewSetDelegate call<br>// tableView.setdelegate -&gt; scrollView.setdelegate</p>
<p>// HOOK<br>// TableView.hmd_set -&gt; TABLEOriginSETIMP<br>// TableView.set -&gt; TABLEhmdSETIMP<br>// ScrollView.hmd_set -&gt; SCROLLoriginSETIMP<br>// ScrollView.set -&gt; SCROLLhmd_setIMP</p>
<p>// tableView.setdelegate -&gt; TABLEhmdSETIMP -&gt; TABLOEriginSETIMP -&gt; ScrollView.hmd_set -&gt; TABLEOriginSETIMP</p>
<p>// tableview category TABLEOriginSETIMP 覆盖了 UIScrollView category  hmd_set 的实现</p>
<p>// 导致 ScrollView.hmd_set 和 TableView.hmd_set 指向了 同一个 IMP</p>
<p><img src="callStack.png" alt="callstack"></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/30/ioshookanalysis/" data-id="ck3g0y6z4000mqy36dzha59m4" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-dyld3withappstart" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/27/dyld3withappstart/">链接和App启动速度优化</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/10/27/dyld3withappstart/" class="article-date"><time datetime="2017-10-27T12:25:33.000Z" itemprop="datePublished">2017-10-27</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>最近看了链接相关的知识，结合 WWDC 2篇Session 和 iOS 启动优化 做一下总结.</p>
<h2 id="1-链接相关的基础知识"><a href="#1-链接相关的基础知识" class="headerlink" title="1 链接相关的基础知识"></a>1 链接相关的基础知识</h2><h3 id="1-1-从main-c到一个可执行目标文件"><a href="#1-1-从main-c到一个可执行目标文件" class="headerlink" title="1.1 从main.c到一个可执行目标文件"></a>1.1 从main.c到一个可执行目标文件</h3><p>我们的源程序main.c 经过C预处理器 翻译成一个ASCII中间文件 main.i,接下来 驱动程序运行C编译器，它将main.i翻译成一个ASCII汇编语言文件main.s,然后驱动程序运行汇编器，它讲main.s翻译成一个可重定位目标文件main.o,链接器程序将main.o和一些必要的系统目标文件组合起来,创建一个可执行目标文件。在运行时,main.o还可以和一些共享目标文件链接。</p>
<p><strong>预处理</strong></p>
<p>在该阶段，编译器将上述代码中的stdio.h编译进来，并且用户可以使用gcc的选项”-E”进行查看，该选项的作用是让gcc在预处理结束后停止编译过程。预处理阶段主要处理#include和#define，它把</p>
<ol>
<li>#include包含进来的.h 文件插入到#include所在的位置</li>
<li>把源程序中使用到的用#define定义的宏用实际的字符串代替</li>
</ol>
<p>hello.c</p>
<p><code>gcc -E hello.c -o hello.i</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Hello world!\n"</span>);  </span><br><span class="line">  </span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/JunyiXie/JunyiXie.github.io/blob/master/2017/10/27/dyld3withappstart/demo/hello.i" target="_blank" rel="noopener">hello.i</a></p>
<p><strong>编译阶段</strong></p>
<p>接下来进行的是编译阶段，在这个阶段中，Gcc首先要检查代码的规范性、是否有语法错误等，以确定代码的实际要做的工作，在检查无误后，Gcc把代码翻译成汇编语言。用户可以使用”-S”选项来进行查看，该选项只进行编译而不进行汇编，生成汇编代码。</p>
<p><code>gcc -S hello.c -o hello.s</code></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">	.section</span>	__TEXT,__text,regular,pure_instructions</span><br><span class="line"><span class="meta">	.macosx_version_min</span> <span class="number">10</span>, <span class="number">12</span></span><br><span class="line"><span class="meta">	.globl</span>	_main</span><br><span class="line"><span class="meta">	.p2align</span>	<span class="number">4</span>, <span class="number">0x90</span></span><br><span class="line"><span class="symbol">_main:</span>                                  ## @main</span><br><span class="line"><span class="meta">	.cfi_startproc</span></span><br><span class="line">## BB#<span class="number">0</span>:</span><br><span class="line">	pushq	%rbp</span><br><span class="line"><span class="symbol">Lcfi0:</span></span><br><span class="line"><span class="meta">	.cfi_def_cfa_offset</span> <span class="number">16</span></span><br><span class="line"><span class="symbol">Lcfi1:</span></span><br><span class="line"><span class="meta">	.cfi_offset</span> %rbp, -<span class="number">16</span></span><br><span class="line">	<span class="keyword">movq</span>	%rsp, %rbp</span><br><span class="line"><span class="symbol">Lcfi2:</span></span><br><span class="line"><span class="meta">	.cfi_def_cfa_register</span> %rbp</span><br><span class="line">	subq	<span class="number">$16</span>, %rsp</span><br><span class="line">	leaq	L_<span class="number">.</span><span class="keyword">str</span>(%rip), %rdi</span><br><span class="line">	movl	<span class="number">$0</span>, -<span class="number">4</span>(%rbp)</span><br><span class="line">	movb	<span class="number">$0</span>, %al</span><br><span class="line">	callq	_printf</span><br><span class="line">	xorl	%ecx, %ecx</span><br><span class="line">	movl	%eax, -<span class="number">8</span>(%rbp)          ## <span class="number">4</span>-<span class="built_in">byte</span> Spill</span><br><span class="line">	movl	%ecx, %eax</span><br><span class="line">	addq	<span class="number">$16</span>, %rsp</span><br><span class="line">	popq	%rbp</span><br><span class="line">	retq</span><br><span class="line"><span class="meta">	.cfi_endproc</span></span><br><span class="line"></span><br><span class="line"><span class="meta">	.section</span>	__TEXT,__cstring,cstring_literals</span><br><span class="line"><span class="symbol">L_.str:</span>                                 ## @.str</span><br><span class="line"><span class="meta">	.asciz</span>	<span class="string">"Hello world! \n"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">.subsections_via_symbols</span></span><br></pre></td></tr></table></figure>

<p><strong>汇编阶段</strong></p>
<p>汇编阶段把<code>.s</code>文件翻译成二进制机器指令文件<code>.o</code>，如命令gcc -c hello.s -o hello.o，其中-c告诉gcc进行汇编处理。这步生成的文件是二进制文件，直接用文本工具打开看到的将是乱码，我们需要反汇编工具如IDA的帮助才能读懂它</p>
<p><img src="idahello" alt="IDAhello.s"></p>
<p><strong>链接阶段</strong></p>
<p>在编译之后，就进入到了链接阶段。我们<code>hello.c</code> 中是没有定义<code>printf</code>的。我们需要把<code>hello.o</code>中的<code>printf</code>符号和它的定义相关联，重定位hello.o和相关的模块，生成一个可执行目标文件.此时我们的<code>printf</code>符号就能正常调用了.</p>
<p>链接使用<code>ld</code>工具.如果没有特别的指定,gcc会到系统默认的搜索路径<code>/usr/lib</code>下进行查找,找到合适的函数库，进行链接.</p>
<p><code>gcc hello.o -o hello.out</code> 生成可执行文件</p>
<p><code>./hello.out</code> 运行可执行文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello world!</span><br></pre></td></tr></table></figure>


<h3 id="1-2-链接的分类"><a href="#1-2-链接的分类" class="headerlink" title="1.2 链接的分类"></a>1.2 链接的分类</h3><ol>
<li>静态链接</li>
<li>动态链接</li>
</ol>
<p><strong>静态链接</strong><br>像Linux LD程序这样的静态链接器以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的，可以加载和运行的可执行目标文件为输出。</p>
<p><strong>动态链接</strong><br>共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链接.由一个叫做动态链接器的程序来执行的。</p>
<h3 id="1-3-链接的任务"><a href="#1-3-链接的任务" class="headerlink" title="1.3 链接的任务"></a>1.3 链接的任务</h3><ol>
<li><p>符号解析<br>目标文件定义和引用符号，符号解析的目的是将每个符号引用正好和一个符号定义关联起来</p>
</li>
<li><p>重定位<br>编译器和链接器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，是他们指向这个内存位置。</p>
</li>
</ol>
<p><strong>可重定位目标文件</strong></p>
<p>链接器是以可重定位目标文件作为输入的，要想理解链接的过程，首先应该了解可重定位目标文件。</p>
<table>
<thead>
<tr>
<th>setion</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>ELF头</td>
<td>系统的字的大小，字节顺序，ELF头的大小，目标文件的类型，机器类型，节头部表的文件偏移，节头部表中条目的大小和数量</td>
</tr>
<tr>
<td>.text</td>
<td>已编译程序的机器代码</td>
</tr>
<tr>
<td>.rodata</td>
<td>只读数据</td>
</tr>
<tr>
<td>.data</td>
<td>已初始化的全局和静态C变量</td>
</tr>
<tr>
<td>.bss</td>
<td>未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量</td>
</tr>
<tr>
<td>.symtab</td>
<td>一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。</td>
</tr>
<tr>
<td>.rel.text</td>
<td>重定位条目，一个.text节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这个位置。</td>
</tr>
<tr>
<td>.rel.data</td>
<td>重定位条目，被模块引用或定义的所有全局变量的重定位信息。</td>
</tr>
<tr>
<td>.debug</td>
<td>一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的C源文件。</td>
</tr>
<tr>
<td>.line</td>
<td>原始C源程序中的行号和.text节中机器指令间的映射。</td>
</tr>
<tr>
<td>.strtab</td>
<td>一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。字符串表就是以null结尾的字符串的序列。</td>
</tr>
<tr>
<td>节头目表</td>
<td>不同节的位置和大小。</td>
</tr>
</tbody></table>
<p>我们在链接中做的工作主要是：<br>符号解析<code>.text</code>,<code>.data</code>段的符号引用，重定位目标文件。</p>
<p><strong>符号和符号表</strong></p>
<p>在我们的一个可重定位目标模块中，通常会使用在当前模块和其他模块中定义的函数和全局变量，我们称之为符号。每个可重定位目标模块都有一个符号表，它包含m定义和引用符号的信息。</p>
<p><strong>ELF符号表条目</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> name;</span><br><span class="line">    <span class="keyword">char</span> type:<span class="number">4</span>,binding:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">char</span> reserved;<span class="comment">//没用</span></span><br><span class="line">    <span class="keyword">short</span> section;</span><br><span class="line">    <span class="keyword">long</span> value;</span><br><span class="line">    <span class="keyword">long</span> <span class="built_in">size</span>;</span><br><span class="line">&#125;Elf64_Symbol;</span><br></pre></td></tr></table></figure>

<ul>
<li>Name: 字符串表中的字节偏移</li>
<li>Value:符号的地址</li>
<li>Size:目标的大小</li>
<li>Type:函数或者是数据</li>
<li>Bingding:符号是本地的还是全局的</li>
</ul>
<p>使用nm命令我们可以看到：<br><code>$ nm mymalloc.o</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                 U ___real_free</span><br><span class="line">                 U ___real_malloc</span><br><span class="line">0000000000000050 T ___wrap_free</span><br><span class="line">0000000000000000 T ___wrap_malloc</span><br><span class="line">                 U _printf</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">___wrap_free,___wrap_malloc 是已定义的符号，在text段，有相应的内存地址.</span><br><span class="line">___real_free,_printf,___real_malloc 是未定义的符号</span><br></pre></td></tr></table></figure>


<p><strong>符号解析</strong></p>
<p>模块引用了符号，我们需要将符号和一个确定的符号定义关联起来，这样我们的程序才可以正常的执行下去。<br>对于引用和定义在相同模块中的局部符号，符号解析是很简单明了的。<br>但是当编译器遇到不是在当前模块中定义的符号时，只能假设该符号已经在其他模块中定义，生成一个链接器符号表条目，把它交给链接器处理。</p>
<p><strong>重定位</strong></p>
<p>一但链接器完成了符号解析这一步，就把代码中的每个符号引用和正好一个符号定义关联起来（即它的一个输入目标模块中的一个），此时，链接器就知道它的输入目标模块中的代码节和数据节的确切大小。现在就可以开始重定位步骤，在这个步骤中重定位将合并输入模块，并为每个符号分配运行时地址。</p>
<p><strong>重定位由两步组成：</strong></p>
<ol>
<li>重定位节和符号定义 <ul>
<li>链接器将所有相同类型的节合并为同一类型的新的聚合节。</li>
<li>链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成后，程序中的每条指令和全局变量都有唯一的运行时内存地址了。</li>
</ul>
</li>
<li>重定位节中的符号引用<ul>
<li>链接器依赖可重定位条目的数据结构，修改代码节和数据节中对每个符号的引用，使它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目标模块中成为可重定位条目的数据结构。</li>
</ul>
</li>
</ol>
<p><strong>可重定位条目</strong></p>
<p>当汇编器生成一个目标模块时，它并不知道数据和代码最终放在内存中的什么位置。他也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。所以，无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。</p>
<p>代码的可重定位条目在<code>.rel.text</code>节中，已初始化数据的重定位条目放在<code>.rel.data</code>中.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">long</span> offset;<span class="comment">// 需要被修改引用的节偏移</span></span><br><span class="line">	<span class="keyword">long</span> type:<span class="number">32</span>,symbol:<span class="number">32</span>;<span class="comment">// type:如何修改新的引用,symbol:标示被修改引用应该指向的符号</span></span><br><span class="line">	<span class="keyword">long</span> addend;<span class="comment">// 一些类型的重定位要使用它对被修改引用的值做偏移调整</span></span><br><span class="line">&#125;Elf64_Rela;</span><br></pre></td></tr></table></figure>

<p><strong>两种基本的重定位类型</strong>：</p>
<ol>
<li>PC 相对地址引用 一个PC相对地址就是 距程序计数器(PC)的当前运行值的偏移量</li>
<li>绝对地址引用 </li>
</ol>
<h3 id="1-4-动态链接共享库"><a href="#1-4-动态链接共享库" class="headerlink" title="1.4 动态链接共享库"></a>1.4 动态链接共享库</h3><p>静态库有一些明显的缺点，比如：</p>
<ol>
<li>静态库更新后需要显式地将他们的程序与更新了的库重新链接。</li>
<li>静态库的代码会被复制到每个运行进程的文本段中。</li>
</ol>
<p><strong>共享库，动态链接</strong><br>共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链接.由一个叫做动态链接器的程序来执行的。</p>
<p><strong>共享库的共享方式</strong></p>
<ol>
<li>给定文件系统中一个库只有一个.so文件。</li>
<li>内存中，一个共享库的.text节的一个副本可以被不同的正在运行的进程共享。</li>
</ol>
<p><strong>共享库的链接时机</strong></p>
<ol>
<li>在运行时由动态链接器练链接和加载</li>
<li>在调用程序被加载和开始执行时</li>
<li>根据需要在程序调用 dlopen 库的函数时</li>
</ol>
<p><strong>PIC 借助GOT,PLT实现</strong><br>第一次调用外部函数：<br>    1. 调用外部符号，程序进入相应的PLT条目<br>    2. 把 调用的 ID压入栈后，跳转到PLT[0]<br>    3. PLT[0]通过GOT[1]间接的把动态链接器的一个参数压入栈中，然后通过GOT[2]间接的跳转进动态链接器中。动态链接器使用两个栈条目来确定 外部函数的 远行时为止，用这个地址重写GOT[4],再把控制权传给 函数。</p>
<p>后续再次调用：<br>    1. 控制传递到PLT相应条目<br>    2. 通过相应的GOT条目直接转移控制到 函数</p>
<p>PLT[0]: 特殊条目，它跳转到动态链接器中<br>GOT[0]和GOT[1]包含动态链接器在解析函数地址时会使用的信息。<br>GOT[2]是动态链接器在ld-linux.so模块中的入口点。</p>
<h3 id="1-4-加载可执行目标文件"><a href="#1-4-加载可执行目标文件" class="headerlink" title="1.4 加载可执行目标文件"></a>1.4 加载可执行目标文件</h3><p>加载器将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。</p>
<p><strong>需要注意的是：</strong></p>
<ol>
<li>由于.data段有对齐要求，所以代码段和数据段之间是有间隙的</li>
<li>链接器会使用ASLR技术,每次区域运行时区域的地址都会改变，但是相对地址不会改变。</li>
</ol>
<p><strong>Linux下的加载</strong></p>
<ol>
<li>父shell进程生成一个子进程，它是父进程的一个复制</li>
<li>子进程通过execve系统调用启动加载器</li>
<li>加载器删除子进程现有的虚拟内存段，并创建一组新的代码，数据，堆和栈段</li>
<li>将虚拟地址空间中的页映射到可执行文件的页大小的片（chunk） ，新的代码和数据段被初始化为可执行文件的内容</li>
<li>加载器跳转到_start地址，最终会调用应用程序的main 函数。</li>
</ol>
<p>注意：除了一些头部信息，在加载过程中没有任何从磁盘到内存的数据复制。直到CPU引用一个被映射的虚拟页时才会进行复制，此时，操作系统利用它的页面调度机制，自动将页面从磁盘传送到内存。</p>
<h2 id="2-Apple-App-Start-And-Dyld"><a href="#2-Apple-App-Start-And-Dyld" class="headerlink" title="2 Apple App Start And Dyld"></a>2 Apple App Start And Dyld</h2><h3 id="2-1-dyld"><a href="#2-1-dyld" class="headerlink" title="2.1 dyld"></a>2.1 dyld</h3><p>当内核完成映射进程的工作后会将名字为dyld的Mach-O文件映射到进程中的随机地址，它将PC寄存器设为dyld的地址并运行.</p>
<p><strong>Fix-ups</strong><br>由于代码签名，我们无法修改<code>__TEXT</code>段的内容,我们可以通过PIC（Position Independent Code）将<code>dyld</code>修改的引用的地址存储到<code>__DATA</code>中. 在Linux中是通过<code>GOT(Global Offset Table)</code>和<code>PLT(Procedure Linkage Table)</code>实现的.</p>
<p><strong>dyld的时间线：</strong><br>Load dylibs -&gt; Rebase -&gt; Bind -&gt; ObjC -&gt; Initalizers</p>
<p><strong>Load</strong></p>
<ul>
<li>Load dylibs:dylibs映射到内存上。</li>
</ul>
<p><strong>Rebase和Binding</strong></p>
<p>Rebase：在镜像内部调整指针的指向. Binding：将指针指向镜像外部的内容</p>
<ul>
<li>Rebase和Binding:使用PIC技术重定位<code>__DATA</code>中对应<code>__TEXT</code>中符号的指针</li>
</ul>
<p>可以通过命令行查看 rebase 和 bind 相关的资源指针：<br><code>xcrun dyldinfo -rebase -bind -lazy_bind xxx.app/xxx</code><br>诸如此类的输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__DATA  __la_symbol_ptr  0x1000341C8 0x04C3 libobjc          _objc_setAssociatedObject</span><br><span class="line">__DATA  __la_symbol_ptr  0x1000341D0 0x04E4 libobjc          _objc_setProperty_nonatomic_copy</span><br><span class="line">__DATA  __la_symbol_ptr  0x1000341D8 0x050C libobjc          _objc_storeStrong</span><br><span class="line">__DATA  __la_symbol_ptr  0x1000341E0 0x0525 libobjc          _objc_storeWeak</span><br><span class="line">__DATA  __la_symbol_ptr  0x1000341E8 0x053C libobjc          _objc_unsafeClaimAutoreleasedReturnValue</span><br><span class="line">__DATA  __la_symbol_ptr  0x1000341F0 0x056C libSystem        _pow</span><br><span class="line">__DATA  __la_symbol_ptr  0x1000341F8 0x0578 libSystem        _sin</span><br><span class="line">__DATA  __la_symbol_ptr  0x100034200 0x0584 libSystem        _sinf</span><br><span class="line">__DATA  __la_symbol_ptr  0x100034208 0x0591 libswiftCore     _swift_getObjCClassMetadata</span><br><span class="line">__DATA  __la_symbol_ptr  0x100034210 0x05B4 libswiftCore     _swift_getObjectType</span><br><span class="line">__DATA  __la_symbol_ptr  0x100034218 0x05D0 libswiftCore     _swift_unknownRelease</span><br><span class="line">__DATA  __la_symbol_ptr  0x100034220 0x05ED libswiftCore     _swift_unknownRetain</span><br></pre></td></tr></table></figure>





<p><strong>ObjC Runtime</strong></p>
<ul>
<li>ObjC  数据结构中有class DATA structure 有很多指针，例如指向 methods 和 super 的指针。这些指针的Fixed-up是通过 rebasing 和 binding.可以说我们类中method_list中的很多信息都是通过 Fix-ups 来维护的</li>
<li>因为Objc的动态性,Objc 可以通过类名来实例化对象, 这意味着 ObjC runtime 需要维护 一张哈希表，负责<code>class name</code>和<code>class</code>的映射.因此当你加载dylib的时候，dylib中定义的类都会被注册到表中。</li>
<li>更新类定义 没有C++中易碎的基类问题，因为 Fix-ups已经更新了<code>__DATA</code> 因此类中ivar相对于类实例起始地址的offset也被更新了.</li>
<li>ObjC 可以定义类别，类别可以改变 类的方法,但是 类别的定义可能和类不在同一个 image 中，在加载过程中，也需要做Fix-up,修复方法的指针. 将category中的method 加到class method_list 的前面，这样我们 在OC 运行时顺序查找方法表，先找的是 category 定义的方法.</li>
<li>ObjC 的 selector 是唯一的</li>
</ul>
<p><strong>Initializers</strong></p>
<ul>
<li>C++ 为静态创建的对象生成初始化器</li>
<li>Objc <code>+load</code> 方法，已经废弃,建议使用 <code>+initialize</code></li>
</ul>
<h3 id="2-2-启动调用顺序"><a href="#2-2-启动调用顺序" class="headerlink" title="2.2 启动调用顺序"></a>2.2 启动调用顺序</h3><p>initialize -&gt; dyld -&gt; main() -&gt; UIApplicationMain()</p>
<h2 id="3-dyld3"><a href="#3-dyld3" class="headerlink" title="3 dyld3"></a>3 dyld3</h2><p>在WWDC 2017 上，苹果宣布已经使用 dyld3 来作为系统app的动态链接器</p>
<p><strong>dyld3可以分成三个部分</strong></p>
<ol>
<li>一个进程外的 mach-o 分析器和编译器 处理可能影响启动速度的searchpath @rpaths 和 环境变量，解析mach-o二进制文件，完成符号解析的工作.</li>
<li>一个进程内的引擎 执行启动收尾处理 验证启动收尾，映射动态链接库</li>
<li>一个启动收尾缓存服务  系统程序收尾被直接加入到共享缓存，使用这个工具在系统中运行和分析每个mach-o文件，将它们放入共享缓存，使它映射到缓存中，所有dylib都使用它来启动. 对于第三方程序，在程序安装或系统更新时，生成启动收尾处理（因为系统库那时已经发生更改）</li>
</ol>
<p><strong>为什么启动收尾可以提高启动速度?</strong><br>通过启动收尾，缓存了 符号相对于库中的偏移位置， 这就避免了以后启动程序进程再次进行符号链接的时间消耗。直接从磁盘读取缓存的启动收尾，验证是否正确即可.</p>
<h2 id="4-优化方案"><a href="#4-优化方案" class="headerlink" title="4 优化方案"></a>4 优化方案</h2><p>App 的启动时间: dylib和App可执行文件的加载时间 + - (BOOL)Application:(UIApplication *)Application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions执行时间.</p>
<p><strong>加载images</strong></p>
<ul>
<li>使用更少的非系统dylibs 合并多个dylibs 使用静态库</li>
</ul>
<p><strong>Rebase/Binding</strong></p>
<ul>
<li>减少Objc 类数量，减少selector数量，减少C++虚函数数量，使用Swift struct</li>
</ul>
<p><strong>Initializer</strong><br>Explict Initializer</p>
<ul>
<li>使用 <code>+initialize</code> 而不是 <code>+load</code></li>
<li>不要使用 <strong>atribute</strong>((constructor)) 将方法显式标记为初始化器,而是让初始化方法调用时才执行.可以使用 <code>dispatch_once()</code>,<code>pthread_once()</code>,<code>std::once()</code></li>
</ul>
<p>Implict Initializer</p>
<ul>
<li>在调用的地方使用初始化器</li>
<li>只用简单值类型赋值（POD:Plain Old Data），这样静态链接器会预先计算 __DATA 中的数据，无需再进行 fix-up 工作</li>
<li>使用编译器 warning 标志 -Wglobal-constructors 来发现隐式初始化代码。</li>
<li>苹果还建议更多使用 Swift。Swift 在设计上能避免很多 C、C++ 和 OC 的陷阱；Swift 没有初始化过程；Swift 也不允许不对齐的结构体。这些都对启动时间的优化有一定帮助</li>
</ul>
<h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5 参考"></a>5 参考</h2><blockquote>
<p><a href="https://developer.apple.com/videos/play/wwdc2017/413/" target="_blank" rel="noopener">2017 WWDC Session 413</a></p>
</blockquote>
<blockquote>
<p><a href="https://developer.apple.com/videos/play/wwdc2016/406/" target="_blank" rel="noopener">2016 WWDC Session 406</a></p>
</blockquote>
<blockquote>
<p>《深入理解计算机系统》</p>
</blockquote>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/27/dyld3withappstart/" data-id="ck3g0y6z8000wqy36at937hzj" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-理解HTTPS" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/26/%E7%90%86%E8%A7%A3HTTPS/">理解HTTPS</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/09/26/%E7%90%86%E8%A7%A3HTTPS/" class="article-date"><time datetime="2017-09-26T06:47:47.000Z" itemprop="datePublished">2017-09-26</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>Monday, 25 September 2017<br>7:36 PM</p>
<blockquote>
<p>文章围绕的问题：</p>
</blockquote>
<ol>
<li>如何解决窃听风险？</li>
<li>如何解决篡改风险？</li>
<li>如何解决冒充风险？</li>
<li>什么是数字证书？</li>
<li>CA证书的验证</li>
<li>什么是签名？</li>
</ol>
<h2 id="HTTPS-简介"><a href="#HTTPS-简介" class="headerlink" title="HTTPS 简介"></a>HTTPS 简介</h2><p>超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。这个协议由网景公司（Netscape）在1994年首次提出，随后扩展到互联网上。</p>
<blockquote>
<p><a href="https://zh.wikipedia.org/zh-cn/超文本传输安全协议" target="_blank" rel="noopener">wikipedia https</a><br>简单的图示<br><img src="https://github.com/JunyiXie/JunyiXie.github.io/raw/master/2017/09/26/%E7%90%86%E8%A7%A3HTTPS/https.png" alt="HTTPS"></p>
</blockquote>
<p><strong>HTTP+加密+认证+完整性保护 = HTTPS.</strong><br> 通常，http直接和tcp通信。当使用ssl/tls时，则演变成先和ssl/tls通信，再由ssl/tls和tcp通讯，因此，https其实就是身披ssl/tls保护外衣的http.</p>
<p> <strong>HTTPS 四次握手的过程</strong></p>
<ol>
<li><p>客户端发出请求<br>在这一步，客户端主要向服务器提供以下信息。<br>（1） 支持的协议版本，比如TLS 1.0版。<br>（2） 一个客户端生成的随机数，稍后用于生成”对话密钥”。<br>（3） 支持的加密方法，比如RSA公钥加密。<br>（4） 支持的压缩方法。</p>
</li>
<li><p>服务器回应<br>服务器收到客户端请求后，向客户端发出回应，这叫severHello.包含如下内容<br>（1）确认使用的加密通信协议版本<br>（2）一个服务器生成的随机数<br>（3）确认使用的加密方法，比如RSA<br>（4）服务器证书</p>
</li>
<li><p>客户端回应<br>客户端验证证书，如果证书没有问题，客户端就会从证书中取出服务器的public-key。向服务器发送下面三项消息。<br>（1）一个随机数。该随机数用服务器public-key加密，防止被窃听<br>（2）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。<br>（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项也是前面发送的所有内容的hash值，用来供服务器校检。</p>
</li>
<li><p>服务器的最后回应<br>服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的“会话密钥”。然后向客户端最后发送下面消息。<br>（1）编码改变通知。表示随后的信息都将用双方商定的加密方法和密钥发送。<br>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash, 用来供服务器校检。</p>
</li>
</ol>
<h2 id="HTTPS-解决了-HTTP-在安全性方面的哪些问题"><a href="#HTTPS-解决了-HTTP-在安全性方面的哪些问题" class="headerlink" title="HTTPS 解决了 HTTP 在安全性方面的哪些问题"></a>HTTPS 解决了 HTTP 在安全性方面的哪些问题</h2><p><strong>HTTP 通信的风险</strong></p>
<ol>
<li>窃听风险：第三方可以获知通信内容</li>
<li>篡改风险：第三方可以修改通信内容</li>
<li>冒充风险：第三方可以冒充他人身份参与通信</li>
</ol>
<p><strong>如何解决这些风险? SSL/TSL 协议</strong></p>
<ol>
<li>加密传播，第三方无法窃听</li>
<li>具有校验机制，一旦被篡改，通信双方会立刻发现</li>
</ol>
<p><strong>SSL/TSL协议有两个问题</strong></p>
<ol>
<li><p>如何保证public-key不被篡改？</p>
<ul>
<li>可信任的第三方认证证书，证书中有public-key</li>
<li>那如何保证证书的可信任性？</li>
</ul>
</li>
<li><p>publick-key计算量太大，如何减少耗用的时间？</p>
<ul>
<li>解决方法：每一次对话（session），客户端和服务器端都生成一个”对话密钥”（session key），用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。</li>
</ul>
</li>
</ol>
<p><strong>上面对HTTPS的介绍 看不懂没关系，下面来了解一些相关的概念</strong></p>
<h2 id="SSL，数字证书，签名，RSA"><a href="#SSL，数字证书，签名，RSA" class="headerlink" title="SSL，数字证书，签名，RSA"></a>SSL，数字证书，签名，RSA</h2><p><strong>SSL/TLS协议的基本过程</strong><br> （1）客户端向服务器索要并验证public-key<br> （2） 双方协商生成“对话密钥”<br> （3）双方采用“对话密钥”进行加密通信</p>
<p> <strong>如何验证数字证书？</strong></p>
<ol>
<li>读取证书发布机构</li>
<li>在操作系统中受信任的发布机构中查找</li>
<li>从证书中取出publick-key对证书的指纹和指纹算法用这个public-key进行解密，然后用这个指纹算法计算证书指纹，然后与证书中的指纹进行对比。</li>
<li>如果一致，说明证书是CA发布的</li>
</ol>
<p><strong>证书如何证明服务器身份</strong><br> 在使用证书之前，通信中，可能出现对方的身份无法确定。<br> 使用证书之后，CA是可信的，通过对证书进行校检，确认证书的合法性，证书合法后，则</p>
<ol>
<li>客户端向服务器发送随机字符串</li>
<li>服务器加密</li>
<li>客户端用证书中的public-key解密，结果一致，则可以证明服务器是证书上的服务器。</li>
</ol>
<p> <strong>RSA</strong><br> RSA是一种公钥密码体制<br> RSA密码体制是一种公钥密码体制，公钥公开，私钥保密，它的加密解密算法是公开的。 由公钥加密的内容可以并且只能由私钥进行解密，并且由私钥加密的内容可以并且只能由公钥进行解密。也就是说，RSA的这一对公钥、私钥都可以用来加密和解密，并且一方加密的内容可以由并且只能由对方进行解密。</p>
<p> 重点：自己保留private-key, 只有private-key加密的内容，才能用public-key解密，这是保证别人无法伪造private-key持有者的重要保障。<strong>也就是说，是无法伪造RSA加密后内容的。</strong></p>
<p> <strong>RSA加密算法在通信过程中起到的作用主要有两个：</strong></p>
<ol>
<li><p>因为私钥只有“服务器”拥有，因此“客户”可以通过判断对方是否有私钥来判断对方是否是“服务器”</p>
</li>
<li><p>客户端通过RSA的掩护，安全的和服务器商量好一个对称加密算法和密钥来保证后面通信过程内容的安全。</p>
<p><strong>签名</strong><br>签名就是在信息的后面再加上一段内容，可以证明信息没有修改过。<br>一般对信息进行hash计算得到一个hash值。在把信息发送时，把签名和签名算法一起发送出去。接收方在接受信息后，用签名算法计算hash值，与签名进行比较。</p>
</li>
</ol>
<ul>
<li><p>报文Hash生成摘要信息Digest,用private-key 加密生成签名</p>
</li>
<li><p>客户端用public-key揭秘签名</p>
</li>
<li><p>客户端对报文做同样的hash处理，和上一步得到的结果进行对比</p>
<p>为了防止他人修改信息内容时，也对hash值进行修改，hash值和算法都会加密，以保证这个hash值不被修改。</p>
</li>
<li><p>加密算法，加密算法后，对方无法根据内容得到相应的hash值，这样就无法伪造内容。</p>
</li>
<li><p>加密hash值，加密后，则可以给接收方一个用来验证的值。</p>
<p>使用rsa加密算法，可以保证签名和hash算法不被他人更改。</p>
</li>
</ul>
<p> <strong>数字证书</strong><br> 数字证书简称CA，它由权威机构给某网站颁发的一种认可凭证，这个凭证是被大家（浏览器）所认可的<br> <strong>为什么需要数字证书？</strong><br> 避免他人冒充服务器</p>
<blockquote>
<p><a href="https://zh.wikipedia.org/wiki/中间人攻击" target="_blank" rel="noopener">中间人攻击</a></p>
</blockquote>
<p> 数字证书一般由证书认证机构颁发，证书里面包含了真实服务器的public-key和网站的其他信息，数字证书机构用自己的private-key加密后发给浏览器，浏览器使用数字证书机构的publick-key揭秘后得到真实服务器的publick-key。</p>
<p><strong>为什么一定要用三个随机数，来生成”会话密钥”</strong></p>
<blockquote>
<p>至于为什么一定要用三个随机数，来生成”会话密钥”，dog250解释得很好：<br>“不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。<br>对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。<br>pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。”</p>
</blockquote>
<h3 id="详细过程图"><a href="#详细过程图" class="headerlink" title="详细过程图"></a>详细过程图</h3><p> <img src="https://github.com/JunyiXie/JunyiXie.github.io/raw/master/2017/09/26/%E7%90%86%E8%A7%A3HTTPS/https_detail.png" alt="https_detail"><br> 注  ：</p>
<ol>
<li><p>双方都进行hash验证</p>
<ul>
<li>服务端知道hash是否正确后，需要让客户端知道自己是否验证正确，客户端也需要验证一次hash，避免服务器造假。</li>
</ul>
</li>
<li><p>D是最后HTTP使用的密钥</p>
<blockquote>
<p>参考文章<br>•    SSL/TLS协议运行机制的概述 <a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a><br>•    图解SSL <a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html</a><br>•    数字证书 <a href="https://blog.cnbluebox.com/blog/2014/03/24/shu-zi-zheng-shu/" target="_blank" rel="noopener">https://blog.cnbluebox.com/blog/2014/03/24/shu-zi-zheng-shu/</a><br>•    数字证书原理 <a href="http://blog.sae.sina.com.cn/archives/4939" target="_blank" rel="noopener">http://blog.sae.sina.com.cn/archives/4939</a><br>•    图解HTTPS <a href="http://www.jianshu.com/p/51cc23843756" target="_blank" rel="noopener">http://www.jianshu.com/p/51cc23843756</a></p>
</blockquote>
</li>
</ol>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/09/26/%E7%90%86%E8%A7%A3HTTPS/" data-id="ck3g0y6zd001aqy36andderdf" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Objective-C-深入理解中的消息机制和方法调用" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/01/Objective-C-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%92%8C%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/">Objective-C 深入理解中的消息机制和方法调用</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/05/01/Objective-C-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%92%8C%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/" class="article-date"><time datetime="2017-05-01T06:09:25.000Z" itemprop="datePublished">2017-05-01</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="objc-msgSend-的背后"><a href="#objc-msgSend-的背后" class="headerlink" title="objc_msgSend 的背后"></a>objc_msgSend 的背后</h2><p>在Objective-C中，消息在Runtime的时候才绑定到方法实现。编译器把</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[receiver message]</span><br></pre></td></tr></table></figure>
<p>转换成</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(receiver, selector)</span><br></pre></td></tr></table></figure>

<p>这个messaging function 做了动态绑定所有的工作</p>
<ul>
<li>首先找到selector 指定的 方法实现.相同的方法可以在不同的类中有不同的实现。被找到的方法实现取决于消息的接受者(类)。</li>
<li>然后调用方法实现，并传递方法所需的参数.</li>
<li>最后，将所调用方法的返回值 作为自身的返回值.</li>
</ul>
<p>消息传递的关键在于 编译器为每个class和object建立的 结构体.每个类的结构体包含着两个必备的元素:</p>
<ul>
<li>一个指向父类的指针</li>
<li>一个 class dispatch table.表中包含了method selectors 和 特定class相应方法实现的地址</li>
</ul>
<p>实例中有一个isa指针，isa指向实例的class structure.</p>
<p>如图所示 通过isa指针，描述了类的继承关系<br><img src="messaging1.gif" alt="message1"></p>
<h3 id="消息传递的过程"><a href="#消息传递的过程" class="headerlink" title="消息传递的过程"></a>消息传递的过程</h3><ol>
<li>当一个消息被发送给一个对象，messaging function<strong>跟随对象的isa指针</strong>找到他的class structure,在dispatch table中寻找method selector.</li>
<li>如果没有找到selector,objc_msgsend 跟随该<strong>类实例的isa</strong>找到父类，尝试在父类的dispatch table中寻找selector</li>
<li>重复步骤2,直到isa指向NSObject Class为止。</li>
</ol>
<p><strong>一但objc_msgsend定位到了selector,该函数,调用dispatch table中的方法，并将其传递给接收对象的数据结构。</strong></p>
<p>这是Runtime中选择所需方法实现的实现方式.在面向对象编程的术语中，这些methods和messages 是动态绑定的。</p>
<p><strong>为了加速消息传递的过程，runtime 系统缓存了使用过的 selectors 和 方法实现的地址。</strong></p>
<p>每个class都有特定的cache.并且它可以包含 继承的selector和 定义在类中的方法。</p>
<p>在OC编程中，你向对象发送消息是因为该对象实现了相应的方法，并且你希望调用该方法。<br>在搜索dispatch tables之前，消息传递机制通常会<strong>首先检查接受方法的对象的cache</strong>。如果方法的selector在缓存中，调用method所需的时间仅仅比function call 稍微慢一点点<br>一但程序预热cache之后，大多数消息调用都能从cache中找到。为了存放更多的方法，Cache会动态的增长。 </p>
<h2 id="深入理解消息转发过程"><a href="#深入理解消息转发过程" class="headerlink" title="深入理解消息转发过程"></a>深入理解消息转发过程</h2><p>以下是文档的中文翻译：</p>
<h3 id="resolveInstanceMethod"><a href="#resolveInstanceMethod" class="headerlink" title="resolveInstanceMethod:"></a>resolveInstanceMethod:</h3><p>resolveInstanceMethod: 和 resolveClassMethod: 方法允许你为一个给定的 selector 动态的提供方法的实现。<br>OC 方法在底层的C函数的实现中需要至少两个参数：self 和 _cmd。使用 class_addMethod 函数，你能够添加一个函数到一个类来作为方法使用。</p>
<h3 id="forwardingTargetForSelector"><a href="#forwardingTargetForSelector" class="headerlink" title="forwardingTargetForSelector:"></a>forwardingTargetForSelector:</h3><p>如果一个对象实现了这个方法，并且返回了一个非空（以及非 self）的结果，返回的对象会用来作为一个新的接收对象，随后消息会被重新派发给这个新对象。（很明显，如果你在这个方法中返回了self，那这段代码将会坠入无限循环。）<br>如果你这段方法在一个非 root 的类中实现，并且如果这个类根据给定的selector什么都不作返回，那么你应该返回一个 执行父类的实现后返回的结果。<br>这个方法为对象在开销大的多的 forwardInvocation:  方法接管之前提供了一次转发未知消息的机会。这对你只是想简单的重新定位消息到另一个对象是非常有用的，并且相对普通转发更快一个数量级。如果转发的目的是捕捉到NSInvocation，或者操作参数，亦或者是在转发过程中返回一个值，那这个方法就没有用了。</p>
<h3 id="forwardInvocation"><a href="#forwardInvocation" class="headerlink" title="forwardInvocation:"></a>forwardInvocation:</h3><p>当对象接受到一条自己不能响应的消息时，运行时会给接收者一次机会来把消息委托给另一个接收者。他委托的消息是通过NSInvocation对象来表示的，然后将这个对象作为 forwardInvocation: 的参数。接收者收到 forwardInvocation: 这条消息后可以选择转发这个NSInvacation对象给其他接收对象。（如果这个接收对象也不能响应这条消息，他也会给一次转发这条消息的机会。）<br>因此 forwardInvocation: 允许在两个对象之间通过某个消息来建立关系。转发给其他对象的这种行为，从某种意义上来说，他“继承”了他所转发给的对象的一些特征。注意为了响应这个你无法识别的方法，你除了 forwardInvocation: 方法外，还必须重写 methodSignatureForSelector:  方法。在转发消息的机制中会从 methodSignatureForSelector: 方法来创建NSInvocation对象。所以你必须为给定的 selector 提供一个合适的 method signature ，可以通过预先设置一个或者向另一个对象请求一个。</p>
<h3 id="forwardInvocation，forwardingTargetForSelector-的差异"><a href="#forwardInvocation，forwardingTargetForSelector-的差异" class="headerlink" title="forwardInvocation，forwardingTargetForSelector  的差异"></a>forwardInvocation，forwardingTargetForSelector  的差异</h3><p><strong>相较于 forwardingTargetForSelector 只能拿到 selector 来说， forwardInvocation 借助于invocation 可以获得参数和返回值等信息。</strong></p>
<h4 id="NSInvocation文档翻译"><a href="#NSInvocation文档翻译" class="headerlink" title="NSInvocation文档翻译"></a>NSInvocation文档翻译</h4><p>NSInvocation:NSInvocation对象用于在对象之间和应用程序之间存储和转发消息，主要由NSTimer对象和分布式对象系统来完成。 NSInvocation对象包含Objective-C消息的所有元素：目标，选择器，参数和返回值。每个元素都可以直接设置，并在调度NSInvocation对象时自动设置返回值。</p>
<p>一个NSInvocation对象可以重复地分派给不同的目标;它的参数可以针对不同结果的调度时进行修改;甚至它的选择器可以变为另一个具有相同的方法签名（参数和返回类型）。这种灵活性使得NSInvocation对重复发送具有许多参数和变体的消息有用;而不是为每条消息重新输入一个稍微不同的表达式，每次在将其分派到新目标之前，都需要根据需要修改NSInvocation对象。</p>
<p>NSInvocation不支持具有可变数量的参数或联合参数的方法的调用。您应该使用invocationWithMethodSignature：类方法来创建NSInvocation对象;你不应该使用alloc和init来创建这些对象。</p>
<p>此类不保留默认包含的调用的参数。如果这些对象可能在创建NSInvocation实例和使用它的时间之间消失，则应该自己保留对象或调用retainArguments方法以使调用对象保留它们本身。</p>
<p>总结一下：可以拿到参数和返回值,可以改selecter(方法签名相同),可以把消息分发给多个对象。相较于 forwardingTargetForSelector 只能拿到selector 灵活了很多。</p>
<h4 id="forwardingTargetForSelector-相较于-forwardInvocation-的优点"><a href="#forwardingTargetForSelector-相较于-forwardInvocation-的优点" class="headerlink" title="forwardingTargetForSelector 相较于 forwardInvocation 的优点"></a>forwardingTargetForSelector 相较于 forwardInvocation 的优点</h4><p>This method gives an object a chance to redirect an unknown message sent to it before the much more expensive forwardInvocation: machinery takes over. This is useful when you simply want to redirect messages to another object and can be an order of magnitude faster than regular forwarding. It is not useful where the goal of the forwarding is to capture the NSInvocation, or manipulate the arguments or return value during the forwarding.</p>
<p>简而言之，只做简单的消息转发时， 它比forwardInvocation 对性能的消耗要少。</p>
<p><strong>我们需要注意</strong></p>
<ol>
<li>forwardInvocation，forwardingTargetForSelector 都会给指定的对象 再走一次 objc_msgsend流程。</li>
<li>forwardInvocation 相较于 forwardingTargetForSelector  消耗更大</li>
<li>forwardInvocation 可以拿到参数和返回值,可以改selecter(方法签名相同),可以把消息分发给多个对象。相较于 forwardingTargetForSelector 只能拿到selector 灵活了很多。</li>
</ol>
<h2 id="来看看C-中的方法调度机制"><a href="#来看看C-中的方法调度机制" class="headerlink" title="来看看C++中的方法调度机制"></a>来看看C++中的方法调度机制</h2><p><strong>直接调度</strong><br>直接调度是最快的一种。它不仅有最少的汇编指令，而且编译器也可以做各种智能优化，比如内联代码，许多其它本文不会涉及的东西。直接调度也常常被称为静态调度。</p>
<p><strong>表调度</strong><br>表调度是编译型语言中最常见的动态行为的实现方式。表调度在类声明中为每一个方法用一个函数指针的数组。大多数语言称之为“虚表”。每一个子类都有它自己的一张父类表的拷贝，表中每个被覆盖的方法都是不同于父类的函数指针。当子类添加新的方法的时候，这些方法就被追加到这个数组的后面。然后在运行时就会访问这个表来决定执行哪个方法。</p>
<h3 id="V-Table-和-dispatch-table-的不同之处"><a href="#V-Table-和-dispatch-table-的不同之处" class="headerlink" title="V-Table 和 dispatch table 的不同之处"></a>V-Table 和 dispatch table 的不同之处</h3><p><strong>这里的虚表 与 Objective-C 中的dispatch table 完全是两个概念.</strong><br>虚表包含了当前类和父类的函数指针。<br>dispatch table 仅仅包含了当前类的selector和MethodIMP的地址。 </p>
<h3 id="其实-Objective-C-中也有-V-Table"><a href="#其实-Objective-C-中也有-V-Table" class="headerlink" title="其实 Objective-C 中也有 V-Table"></a>其实 Objective-C 中也有 V-Table</h3><p>其实OC中也有V-Table 它用来存放 最常调用的方法来加速程序的性能。这些方法直接通过V-table 调用。（执行msg_send()会花费更多的时间)<br>每一个对象都有一个vtable point 指向 一些方法的IMP.<br><a href="https://opensource.apple.com/source/objc4/objc4-437/runtime/objc-runtime-new.m" target="_blank" rel="noopener">objc-runtime-new.m</a></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* vtable dispatch</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* Every class gets a vtable pointer. The vtable is an array of IMPs.</span></span><br><span class="line"><span class="comment">* The selectors represented in the vtable are the same for all classes</span></span><br><span class="line"><span class="comment">*   (i.e. no class has a bigger or smaller vtable).</span></span><br><span class="line"><span class="comment">* Each vtable index has an associated trampoline which dispatches to </span></span><br><span class="line"><span class="comment">*   the IMP at that index for the receiver class's vtable (after </span></span><br><span class="line"><span class="comment">*   checking for NULL). Dispatch fixup uses these trampolines instead </span></span><br><span class="line"><span class="comment">*   of objc_msgSend.</span></span><br><span class="line"><span class="comment">* Fragility: The vtable size and list of selectors is chosen at launch </span></span><br><span class="line"><span class="comment">*   time. No compiler-generated code depends on any particular vtable </span></span><br><span class="line"><span class="comment">*   configuration, or even the use of vtable dispatch at all.</span></span><br><span class="line"><span class="comment">* Memory size: If a class's vtable is identical to its superclass's </span></span><br><span class="line"><span class="comment">*   (i.e. the class overrides none of the vtable selectors), then </span></span><br><span class="line"><span class="comment">*   the class points directly to its superclass's vtable. This means </span></span><br><span class="line"><span class="comment">*   selectors to be included in the vtable should be chosen so they are </span></span><br><span class="line"><span class="comment">*   (1) frequently called, but (2) not too frequently overridden. In </span></span><br><span class="line"><span class="comment">*   particular, -dealloc is a bad choice.</span></span><br><span class="line"><span class="comment">* Forwarding: If a class doesn't implement some vtable selector, that </span></span><br><span class="line"><span class="comment">*   selector's IMP is set to objc_msgSend in that class's vtable.</span></span><br><span class="line"><span class="comment">* +initialize: Each class keeps the default vtable (which always </span></span><br><span class="line"><span class="comment">*   redirects to objc_msgSend) until its +initialize is completed.</span></span><br><span class="line"><span class="comment">*   Otherwise, the first message to a class could be a vtable dispatch, </span></span><br><span class="line"><span class="comment">*   and the vtable trampoline doesn't include +initialize checking.</span></span><br><span class="line"><span class="comment">* Changes: Categories, addMethod, and setImplementation all force vtable </span></span><br><span class="line"><span class="comment">*   reconstruction for the class and all of its subclasses, if the </span></span><br><span class="line"><span class="comment">*   vtable selectors are affected.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> defaultVtable[] = &#123;</span><br><span class="line">    <span class="string">"allocWithZone:"</span>, </span><br><span class="line">    <span class="string">"alloc"</span>, </span><br><span class="line">    <span class="string">"class"</span>, </span><br><span class="line">    <span class="string">"self"</span>, </span><br><span class="line">    <span class="string">"isKindOfClass:"</span>, </span><br><span class="line">    <span class="string">"respondsToSelector:"</span>, </span><br><span class="line">    <span class="string">"isFlipped"</span>, </span><br><span class="line">    <span class="string">"length"</span>, </span><br><span class="line">    <span class="string">"objectForKey:"</span>, </span><br><span class="line">    <span class="string">"count"</span>, </span><br><span class="line">    <span class="string">"objectAtIndex:"</span>, </span><br><span class="line">    <span class="string">"isEqualToString:"</span>, </span><br><span class="line">    <span class="string">"isEqual:"</span>, </span><br><span class="line">    <span class="string">"retain"</span>, </span><br><span class="line">    <span class="string">"release"</span>, </span><br><span class="line">    <span class="string">"autorelease"</span>, </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> defaultVtableGC[] = &#123;</span><br><span class="line">    <span class="string">"allocWithZone:"</span>, </span><br><span class="line">    <span class="string">"alloc"</span>, </span><br><span class="line">    <span class="string">"class"</span>, </span><br><span class="line">    <span class="string">"self"</span>, </span><br><span class="line">    <span class="string">"isKindOfClass:"</span>, </span><br><span class="line">    <span class="string">"respondsToSelector:"</span>, </span><br><span class="line">    <span class="string">"isFlipped"</span>, </span><br><span class="line">    <span class="string">"length"</span>, </span><br><span class="line">    <span class="string">"objectForKey:"</span>, </span><br><span class="line">    <span class="string">"count"</span>, </span><br><span class="line">    <span class="string">"objectAtIndex:"</span>, </span><br><span class="line">    <span class="string">"isEqualToString:"</span>, </span><br><span class="line">    <span class="string">"isEqual:"</span>, </span><br><span class="line">    <span class="string">"hash"</span>, </span><br><span class="line">    <span class="string">"addObject:"</span>, </span><br><span class="line">    <span class="string">"countByEnumeratingWithState:objects:count:"</span>, </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/01/Objective-C-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%92%8C%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/" data-id="ck3g0y6yq0009qy361mvu1p0u" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Cocoa-深入理解KVO" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/20/Cocoa-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3KVO/">Cocoa 深入理解KVO</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/04/20/Cocoa-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3KVO/" class="article-date"><time datetime="2017-04-20T04:44:52.000Z" itemprop="datePublished">2017-04-20</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>深入理解KVO<br>……</p>
        
          <p class="article-more-link">
            <a class="btn btn-primary" href="/2017/04/20/Cocoa-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3KVO/#more">Read More</a>
          </p>
        
      
    </div>

    

    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/20/Cocoa-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3KVO/" data-id="ck3g0y6yh0003qy36ffkd38tb" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-深入Objc-Runtime" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/06/%E6%B7%B1%E5%85%A5Objc-Runtime/">理解 Objc Runtime</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/02/06/%E6%B7%B1%E5%85%A5Objc-Runtime/" class="article-date"><time datetime="2017-02-06T07:03:59.000Z" itemprop="datePublished">2017-02-06</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Runtime-是什么"><a href="#Runtime-是什么" class="headerlink" title="Runtime 是什么"></a>Runtime 是什么</h2><p>一个用C和汇编语言写的Runtime库,来动态 创建类和对象、进行消息传递和转发。<br>（在运行时执行部分编译后的代码）</p>
<h2 id="Objective-C"><a href="#Objective-C" class="headerlink" title="Objective-C"></a>Objective-C</h2><p>Objective-C 扩展了 C 语言，并加入了面向对象特性和 Smalltalk 式的消息传递机制。而这个扩展的核心是一个用 C 和 编译语言 写的 Runtime 库。它是 Objective-C 面向对象和动态机制的基石。</p>
<p>Objective-C 是一个动态语言，这意味着它不仅需要一个编译器，也需要一个运行时系统来动态 创建类和对象、进行消息传递和转发。理解 Objective-C 的 Runtime 机制可以帮我们更好的了解这个语言，适当的时候还能对语言进行扩展，从系统层面解决项目中的一些设计或技术问题。 Runtime的核心是 - 消息传递 （Messaging）。(动态调度)</p>
<h2 id="Runtime-原理的概述"><a href="#Runtime-原理的概述" class="headerlink" title="Runtime 原理的概述"></a>Runtime 原理的概述</h2><p>Objective-C的是一个运行时面向语言，这意味着当它可能在运行时决定如何实现而不是在编译期。 这给你很大的灵活性，你可以根据需要将消息重定向到适当的对象，或者甚至有意交换方法实现等。如果我们将它与C语言进行对比。</p>
<p>在很多语言，比如 C ，调用一个方法其实就是跳到内存中的某一点并开始执行一段代码。没有任何动态的特性，因为这在编译时就决定好了。而在 Objective-C 中，[object foo] 语法并不会立即执行 foo 这个方法的代码。它是在运行时给 object 发送一条叫 foo 的消息。这个消息，也许会由 object 来处理，也许会被转发给另一个对象，或者不予理睬假装没收到这个消息。多条不同的消息也可以对应同一个方法实现。这些都是在程序运行的时候决定的。</p>
<h3 id="什么是Objective-C运行时？"><a href="#什么是Objective-C运行时？" class="headerlink" title="什么是Objective-C运行时？"></a>什么是Objective-C运行时？</h3><p>Objective-C运行时是一个运行库，它是一个主要在C＆Assembler中编写的库，它将面向对象的功能添加到C中以创建Objective-C。 这意味着它加载类信息，所有方法调度，方法转发等。Objective-C运行时本质上创建所有支持结构，使面向对象的编程与Objective-C可能。</p>
<h3 id="Objective-C-类和对象"><a href="#Objective-C-类和对象" class="headerlink" title="Objective-C 类和对象"></a>Objective-C 类和对象</h3><p>Objective-c类本身也是对象，而运行时通过创建Meta类处理这一点。 当你发送一个消息，如[NSObject alloc]，你实际上是发送一个消息到类对象，该类对象需要是一个MetaClass的实例，它本身是根元类的实例。 而如果你说NSObject的子类，你的类指向NSObject作为它的超类。 然而，所有元类都指向根元类作为它们的超类。 所有的元类都只有它们响应的消息的方法列表的类方法。 所以当你发送消息到类对象，如[NSObject alloc]，然后objc_msgSend（）实际上通过元类查看它的响应，然后如果它找到一个方法，操作类对象。</p>
<h4 id="为什么Objective-C的对象都要继承-NSObject"><a href="#为什么Objective-C的对象都要继承-NSObject" class="headerlink" title="为什么Objective-C的对象都要继承 NSObject"></a>为什么Objective-C的对象都要继承 NSObject</h4><p>最初当你开始Cocoa开发，你可能没注意到我们的类一直都恪守着继承自NSObject的写法，有一件事你甚至没有意识到，发生在你身上的是将对象设置为使用Objective-C运行时。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyObject *object = [[MyObject alloc] init];</span><br></pre></td></tr></table></figure>

<p>执行的第一个消息是+ alloc。 如果你看看文档，它说“新实例的isa实例变量被初始化为描述类的数据结构;所有其他实例变量的内存设置为0” 所以通过继承NSObject类，我们不仅继承了一些伟大的属性，而且我们继承了在内存中容易地分配和创建我们的对象的能力.</p>
<h3 id="那么什么是类缓存？-（objc-cache-cache）"><a href="#那么什么是类缓存？-（objc-cache-cache）" class="headerlink" title="那么什么是类缓存？ （objc_cache * cache）"></a>那么什么是类缓存？ （objc_cache * cache）</h3><p>你或许在源码中发现了 Cache cache;</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    uint32_t version;</span><br><span class="line">    uint32_t info;</span><br><span class="line">    uint32_t instance_size;</span><br><span class="line">    <span class="keyword">struct</span> old_ivar_list *ivars;</span><br><span class="line">    <span class="keyword">struct</span> old_method_list **methodLists;</span><br><span class="line">    Cache cache;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看看它是什么样的结构体:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_cache &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask <span class="comment">/* total = mask + 1 */</span>                 OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> occupied                                    OBJC2_UNAVAILABLE;</span><br><span class="line">    Method buckets[<span class="number">1</span>]                                        OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到一个类中 有 一个存放方法列表的数据结构,那么它到底用来干嘛的呢?</p>
<p>一个 class 往往只有 20% 的函数会被经常调用，可能占总调用次数的 80% 。每个消息都需要遍历一次 objc_method_list 并不合理。如果把经常被调用的函数缓存下来，那可以大大提高函数查询的效率。这也就是 objc_class 中另一个重要成员 objc_cache 做的事情 - 再找到 foo 之后，把 foo 的 method_name 作为 key ，method_imp 作为 value 给存起来。当再次收到 foo 消息的时候，可以直接在 cache 里找到，避免去遍历 objc_method_list.<br>(Hash表的方法实现)</p>
<p>当Objective-C运行时通过跟踪它的isa指针检查对象时，它可以找到一个实现许多方法的对象。然而，你可能只调用它们的一小部分，并且每次查找时，搜索所有选择器的类分派表没有意义。所以类实现一个缓存，每当你搜索一个类分派表，并找到相应的选择器，它把它放入它的缓存。所以当objc_msgSend（）查找一个类的选择器，它首先搜索类缓存。这是基于这样的理论：如果你在类上调用一个消息，你可能以后再次调用该消息。所以如果我们考虑到这一点，这意味着如果我们有一个NSObject子类，名为MyObject并运行以下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyObject *obj = [[MyObject alloc] init];</span><br><span class="line"></span><br><span class="line">@implementation MyObject</span><br><span class="line">-(id)init &#123;</span><br><span class="line">    if(self = [super init])&#123;</span><br><span class="line">        [self setVarA:@”blah”];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>


<h2 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h2><blockquote>
<p>I’m sorry that I long ago coined the term “objects” for this topic because it gets many people to focus on the lesser idea. The big idea is “messaging” – that is what the kernal[sic] of Smalltalk is all about… The key in making great and growable systems is much more to design how its modules communicate rather than what their internal properties and behaviors should be.</p>
</blockquote>
<p>Alan Kay 曾多次强调 Smalltalk 的核心不是面向对象，面向对象只是 the lesser ideas，<strong>消息传递</strong> 才是 the big idea。</p>
<p>消息传递的关键藏于 objc_object 中的 isa 指针和 objc_class 中的 class dispatch table。</p>
<p>在 Objective-C 中，类、对象和方法都是一个 C 的结构体，从 objc/objc.h 头文件中，我们可以找到他们的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">    Class superclass;</span><br><span class="line">    const char *name;</span><br><span class="line">    uint32_t version;</span><br><span class="line">    uint32_t info;</span><br><span class="line">    uint32_t instance_size;</span><br><span class="line">    struct old_ivar_list *ivars;</span><br><span class="line">    struct old_method_list **methodLists;</span><br><span class="line">    Cache cache;</span><br><span class="line">    struct old_protocol_list *protocols;</span><br><span class="line">    // CLS_EXT only</span><br><span class="line">    const uint8_t *ivar_layout;</span><br><span class="line">    struct old_class_ext *ext;</span><br><span class="line">    /.../</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>struct objc_ivar_list <em>ivars            OBJC2_UNAVAILABLE;  // 该类的成员变量链表<br>struct objc_method_list *</em>methodLists   OBJC2_UNAVAILABLE;  // 方法定义的链表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct old_ivar_list &#123;</span><br><span class="line">    int ivar_count;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    int space;</span><br><span class="line">#endif</span><br><span class="line">    /* variable length structure */</span><br><span class="line">    struct old_ivar ivar_list[1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct old_method_list &#123;</span><br><span class="line">    void *obsolete;</span><br><span class="line"></span><br><span class="line">    int method_count;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    int space;</span><br><span class="line">#endif</span><br><span class="line">    /* variable length structure */</span><br><span class="line">    // 可变长的方法数组</span><br><span class="line">    struct old_method method_list[1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>objc_method_list 本质是一个有 objc_method 元素的可变长度的数组。一个 objc_method 结构体中有函数名，也就是SEL，有表示函数类型的字符串 (见 Type Encoding) ，以及函数的实现IMP。</p>
<blockquote>
<p>这里有一些你可能感兴趣的代码: Cache,protocol_List,class_extension</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_cache *Cache                             OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">#define CACHE_BUCKET_NAME(B)  ((B)-&gt;method_name)</span><br><span class="line">#define CACHE_BUCKET_IMP(B)   ((B)-&gt;method_imp)</span><br><span class="line">#define CACHE_BUCKET_VALID(B) (B)</span><br><span class="line">#ifndef __LP64__</span><br><span class="line">#define CACHE_HASH(sel, mask) (((uintptr_t)(sel)&gt;&gt;2) &amp; (mask))</span><br><span class="line">#else</span><br><span class="line">#define CACHE_HASH(sel, mask) (((unsigned int)((uintptr_t)(sel)&gt;&gt;3)) &amp; (mask))</span><br><span class="line">#endif</span><br><span class="line">struct objc_cache &#123;</span><br><span class="line">    unsigned int mask /* total = mask + 1 */                 OBJC2_UNAVAILABLE;</span><br><span class="line">    unsigned int occupied                                    OBJC2_UNAVAILABLE;</span><br><span class="line">    Method buckets[1]                                        OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct old_protocol_list &#123;</span><br><span class="line">    struct old_protocol_list *next;</span><br><span class="line">    long count;</span><br><span class="line">    struct old_protocol *list[1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct old_class_ext &#123;</span><br><span class="line">    uint32_t size;</span><br><span class="line">    const uint8_t *weak_ivar_layout;</span><br><span class="line">    struct old_property_list **propertyLists;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>好了 接下来让我们接触Runtime的核心机制，消息机制</strong></p>
<h3 id="消息发送的步骤"><a href="#消息发送的步骤" class="headerlink" title="消息发送的步骤"></a>消息发送的步骤</h3><ol>
<li>Check for ignored selectors (GC) and short-circuit.如果 selector 是需要被忽略的垃圾回收用到的方法，则将 IMP 结果设为 _objc_ignored_method，这是个汇编程序入口，可以理解为一个标记。(OSX)</li>
<li>Check for nil target.检查对象是否为nil<ul>
<li>If nil &amp; nil receiver handler configured, jump to handler</li>
<li>If nil &amp; no handler (default), cleanup and return.</li>
</ul>
</li>
<li>Search the class’s method cache for the method IMP 在cache 中查找IMP<ul>
<li>If found, jump to it.找到，跳转到相应的内存地址</li>
<li>Not found: lookup the method IMP in the class itself 未找到，在类的method_list中查找<ul>
<li>If found, jump to it.找到，跳转</li>
<li>If not found, jump to forwarding mechanism.未找到，进入消息分发的步骤</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="消息分发的步骤"><a href="#消息分发的步骤" class="headerlink" title="消息分发的步骤"></a>消息分发的步骤</h3><ul>
<li>在对象类的 dispatch table 中尝试找到该消息。如果找到了，跳到相应的函数IMP去执行实现代码；</li>
<li>如果没有找到，Runtime 会发送 +resolveInstanceMethod: 或者 +resolveClassMethod: 尝试去 resolve 这个消息；</li>
<li>如果 resolve 方法返回 NO，Runtime 就发送 -forwardingTargetForSelector: 允许你把这个消息转发给另一个对象；</li>
<li>如果没有新的目标对象返回， Runtime 就会发送 -methodSignatureForSelector: 和 -forwardInvocation: 消息。你可以发送 -invokeWithTarget: 消息来手动转发消息或者发送 -doesNotRecognizeSelector: 抛出异常。</li>
</ul>
<ol>
<li>resolveInstanceMethod/resolveClassMethod 方法解析，这里可以动态添加方法（添加了即可返回YES)</li>
<li>forwardingTargetForSelector 把Selector 转发给其他实例响应</li>
<li>methodSignatureForSelector,invokeWithTarget,doesNotRecognizeSelector 添加方法签名，让其他实例来处理方法的调用</li>
</ol>
<blockquote>
<p>关于objc_msgSend函数<br>事实上，在编译时你写的 Objective-C 函数调用的语法都会被翻译成一个 C 的函数调用 - objc_msgSend() 。</p>
</blockquote>
<p><strong>关于消息分发三个步骤的Example:</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  第一步</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功解析的实例方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> + (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span></span><br><span class="line"><span class="comment"> NSString *selectorString = NSStringFromSelector(sel);</span></span><br><span class="line"><span class="comment"> if ([selectorString isEqualToString:@"mysteriousMethod"]) &#123;</span></span><br><span class="line"><span class="comment"> class_addMethod(self.class, @selector(mysteriousMethod), (IMP)functionForMethod1, "@:");</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> return [super resolveInstanceMethod:sel];</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  在没有找到方法时，会先调用此方法，可用于动态添加方法</span></span><br><span class="line"><span class="comment">//  返回 YES 表示相应 selector 的实现已经被找到并添加到了类中，否则返回 NO</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  第二步</span></span><br><span class="line"><span class="comment">//  如果第一步的返回 NO 或者直接返回了 YES 而没有添加方法，该方法被调用</span></span><br><span class="line"><span class="comment">//  在这个方法中，我们可以指定一个可以返回一个可以响应该方法的对象</span></span><br><span class="line"><span class="comment">//  如果返回 self 就会死循环</span></span><br><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(aSelector == <span class="keyword">@selector</span>(xxx:))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.alternateObject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  第三步</span></span><br><span class="line"><span class="comment">//  如果 `forwardingTargetForSelector:` 返回了 nil，则该方法会被调用，系统会询问我们要一个合法的『类型编码(Type Encoding)』</span></span><br><span class="line"><span class="comment">//  若返回 nil，则不会进入下一步，而是无法处理消息</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="string">"v@:"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当实现了此方法后，-doesNotRecognizeSelector: 将不会被调用</span></span><br><span class="line"><span class="comment">// 如果要测试找不到方法，可以注释掉这一个方法</span></span><br><span class="line"><span class="comment">// 在这里进行消息转发</span></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    <span class="comment">// 我们还可以改变方法选择器</span></span><br><span class="line">    [anInvocation setSelector:<span class="keyword">@selector</span>(notFind)];</span><br><span class="line">    <span class="comment">// 改变方法选择器后，还需要指定接受者</span></span><br><span class="line">    [anInvocation invokeWithTarget:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)notFind &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"没有实现 -mysteriousMethod 方法，并且成功的转成了 -notFind 方法"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>你可能忽略了一个细节 V-Table</strong><br>如果你学过C++，你可能会了解到Hybrid vTable Dispatch（虚拟表分发）.<br>你可以参考我的这篇文章<a href="https://junyixie.github.io/2017/04/29/Swift-方法调用/" target="_blank" rel="noopener">iOS 调用机制</a></p>
<h3 id="Hybrid-vTable-Dispatch"><a href="#Hybrid-vTable-Dispatch" class="headerlink" title="Hybrid vTable Dispatch"></a>Hybrid vTable Dispatch</h3><p>新的 Objc-runtime-new.m 这样写到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* vtable dispatch</span><br><span class="line">*</span><br><span class="line">* Every class gets a vtable pointer. The vtable is an array of IMPs.</span><br><span class="line">* The selectors represented in the vtable are the same for all classes</span><br><span class="line">*   (i.e. no class has a bigger or smaller vtable).</span><br><span class="line">* Each vtable index has an associated trampoline which dispatches to</span><br><span class="line">*   the IMP at that index for the receiver class&apos;s vtable (after</span><br><span class="line">*   checking for NULL). Dispatch fixup uses these trampolines instead</span><br><span class="line">*   of objc_msgSend.</span><br><span class="line">* Fragility: The vtable size and list of selectors is chosen at launch</span><br><span class="line">*   time. No compiler-generated code depends on any particular vtable</span><br><span class="line">*   configuration, or even the use of vtable dispatch at all.</span><br><span class="line">* Memory size: If a class&apos;s vtable is identical to its superclass&apos;s</span><br><span class="line">*   (i.e. the class overrides none of the vtable selectors), then</span><br><span class="line">*   the class points directly to its superclass&apos;s vtable. This means</span><br><span class="line">*   selectors to be included in the vtable should be chosen so they are</span><br><span class="line">*   (1) frequently called, but (2) not too frequently overridden. In</span><br><span class="line">*   particular, -dealloc is a bad choice.</span><br><span class="line">* Forwarding: If a class doesn&apos;t implement some vtable selector, that</span><br><span class="line">*   selector&apos;s IMP is set to objc_msgSend in that class&apos;s vtable.</span><br><span class="line">* +initialize: Each class keeps the default vtable (which always</span><br><span class="line">*   redirects to objc_msgSend) until its +initialize is completed.</span><br><span class="line">*   Otherwise, the first message to a class could be a vtable dispatch,</span><br><span class="line">*   and the vtable trampoline doesn&apos;t include +initialize checking.</span><br><span class="line">* Changes: Categories, addMethod, and setImplementation all force vtable</span><br><span class="line">*   reconstruction for the class and all of its subclasses, if the</span><br><span class="line">*   vtable selectors are affected.</span><br><span class="line">**********************************************************************/</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">static const char * const defaultVtable[] = &#123;</span><br><span class="line">    &quot;allocWithZone:&quot;,</span><br><span class="line">    &quot;alloc&quot;,</span><br><span class="line">    &quot;class&quot;,</span><br><span class="line">    &quot;self&quot;,</span><br><span class="line">    &quot;isKindOfClass:&quot;,</span><br><span class="line">    &quot;respondsToSelector:&quot;,</span><br><span class="line">    &quot;isFlipped&quot;,</span><br><span class="line">    &quot;length&quot;,</span><br><span class="line">    &quot;objectForKey:&quot;,</span><br><span class="line">    &quot;count&quot;,</span><br><span class="line">    &quot;objectAtIndex:&quot;,</span><br><span class="line">    &quot;isEqualToString:&quot;,</span><br><span class="line">    &quot;isEqual:&quot;,</span><br><span class="line">    &quot;retain&quot;,</span><br><span class="line">    &quot;release&quot;,</span><br><span class="line">    &quot;autorelease&quot;,</span><br><span class="line">&#125;;</span><br><span class="line">static const char * const defaultVtableGC[] = &#123;</span><br><span class="line">    &quot;allocWithZone:&quot;,</span><br><span class="line">    &quot;alloc&quot;,</span><br><span class="line">    &quot;class&quot;,</span><br><span class="line">    &quot;self&quot;,</span><br><span class="line">    &quot;isKindOfClass:&quot;,</span><br><span class="line">    &quot;respondsToSelector:&quot;,</span><br><span class="line">    &quot;isFlipped&quot;,</span><br><span class="line">    &quot;length&quot;,</span><br><span class="line">    &quot;objectForKey:&quot;,</span><br><span class="line">    &quot;count&quot;,</span><br><span class="line">    &quot;objectAtIndex:&quot;,</span><br><span class="line">    &quot;isEqualToString:&quot;,</span><br><span class="line">    &quot;isEqual:&quot;,</span><br><span class="line">    &quot;hash&quot;,</span><br><span class="line">    &quot;addObject:&quot;,</span><br><span class="line">    &quot;countByEnumeratingWithState:objects:count:&quot;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Runtime 通过 vTable 的方式 加速调用类的常用方法。</strong></p>
<h2 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h2><p>但是category则完全不一样，它是在运行期决议的。<br>就category和extension的区别来看，我们可以推导出一个明显的事实，extension可以添加实例变量，而category是无法添加实例变量的（因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的）</p>
<h3 id="category和-load方法"><a href="#category和-load方法" class="headerlink" title="-category和+load方法"></a>-category和+load方法</h3><p>我们知道，在类和category中都可以有+load方法，那么有两个问题：<br>1)、在类的+load方法调用的时候，我们可以调用category中声明的方法么？<br>2)、这么些个+load方法，调用顺序是咋样的呢？</p>
<p>1)、可以调用，因为附加category到类的工作会先于+load方法的执行<br>2)、+load的执行顺序是先类，后category，而category的+load执行顺序是根据编译顺序决定的。</p>
<blockquote>
<p>部分内容引用和翻译自<br><a href="http://www.friday.com/bbum/2009/12/18/objc_msgsend-part-1-the-road-map/" target="_blank" rel="noopener">http://www.friday.com/bbum/2009/12/18/objc_msgsend-part-1-the-road-map/</a><br><a href="http://cocoasamurai.blogspot.com/2010/01/understanding-objective-c-runtime.html" target="_blank" rel="noopener">http://cocoasamurai.blogspot.com/2010/01/understanding-objective-c-runtime.html</a></p>
</blockquote>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/02/06/%E6%B7%B1%E5%85%A5Objc-Runtime/" data-id="ck3g0y6zc0018qy360c8h0edm" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-Objective-C-weak-关键字-实现-源码分析" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/01/Objective-C-weak-%E5%85%B3%E9%94%AE%E5%AD%97-%E5%AE%9E%E7%8E%B0-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Objective-C weak 关键字 实现 源码分析</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/02/01/Objective-C-weak-%E5%85%B3%E9%94%AE%E5%AD%97-%E5%AE%9E%E7%8E%B0-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="article-date"><time datetime="2017-02-01T13:01:53.000Z" itemprop="datePublished">2017-02-01</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="weak"><a href="#weak" class="headerlink" title="__weak"></a>__weak</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> __week obj1 = obj;</span><br></pre></td></tr></table></figure>
<p><strong>编译器的模拟代码</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> obj1;</span><br><span class="line">obj1 = <span class="number">0</span>;</span><br><span class="line">objc_storeWeak(&amp;obj1, obj);</span><br><span class="line">objc_storeWeak(&amp;obj1, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>


<p><strong>objc_storeWeak</strong><br>函数把第二参数的赋值对象的地址作为键值，将第一参数的附有__weak修饰的变量的地址注册到weak表中。<br>如果第二参数为0，则把变量的地址从weak表中删除。<br><strong>initWeak的实现</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_initWeak(<span class="keyword">id</span> *object, <span class="keyword">id</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    *object = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> objc_storeWeak(object, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>storeWeak是Objective-C的开源部分<br>让我们来看看storeWeak到底是怎么实现的</p>
<h3 id="objc-storeWeak"><a href="#objc-storeWeak" class="headerlink" title="objc_storeWeak"></a>objc_storeWeak</h3><p><strong>storeWeak的源码</strong><br>官方英文注释挺全的，可以直接理解~</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Clean up old value, if any.</span></span><br><span class="line"><span class="keyword">if</span> (HaveOld) &#123;</span><br><span class="line">    weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Assign new value, if any.</span></span><br><span class="line"><span class="keyword">if</span> (HaveNew) &#123;</span><br><span class="line">    newObj = (objc_object *)weak_register_no_lock(&amp;newTable-&gt;weak_table, </span><br><span class="line">                                                  (id)newObj, location, </span><br><span class="line">                                                  CrashIfDeallocating);</span><br><span class="line">    <span class="comment">// weak_register_no_lock returns nil if weak store should be rejected</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set is-weakly-referenced bit in refcount table.</span></span><br><span class="line">    <span class="keyword">if</span> (newObj  &amp;&amp;  !newObj-&gt;isTaggedPointer()) &#123;</span><br><span class="line">        newObj-&gt;setWeaklyReferenced_nolock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not set *location anywhere else. That would introduce a race.</span></span><br><span class="line">    *location = (id)newObj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// No new value. The storage is not changed.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>来看看storeWeak的实现</strong><br>获取oldObj/newObj</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (HaveOld) &#123;</span><br><span class="line">    oldObj = *location;</span><br><span class="line">    oldTable = &amp;SideTables()[oldObj];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    oldTable = nil;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (HaveNew) &#123;</span><br><span class="line">    newTable = &amp;SideTables()[newObj];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    newTable = nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是根据weak指针找到其指向的老的对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oldObj = *location;</span><br></pre></td></tr></table></figure>

<p>然后获取到与新旧对象相关的SideTable对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">oldTable = &amp;SideTables()[oldObj];</span><br><span class="line">newTable = &amp;SideTables()[newObj];</span><br></pre></td></tr></table></figure>
<p><strong>&amp;SideTables()[oldObj]</strong>这是什么鬼??<br>其时是 实现了一个类 StripedMap 重载了[]操作符<br>(c++: 哪里都能看到我 233)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[] (<span class="keyword">const</span> <span class="keyword">void</span> *p) &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">array</span>[indexForPointer(p)].value; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>下面要做的就是在老对象的weak表中移除指向信息，而在新对象的weak表中建立关联信息：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (HaveOld) &#123;</span><br><span class="line">    weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (HaveNew) &#123;</span><br><span class="line">    newObj = weak_register_no_lock(&amp;newTable-&gt;weak_table, newObj,location);</span><br><span class="line">    <span class="comment">// weak_register_no_lock returns NULL if weak store should be rejected</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来让弱引用指针指向新的对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*location = newObj;</span><br></pre></td></tr></table></figure>

<p>最后会返回这个新对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> newObj;</span><br></pre></td></tr></table></figure>
<p><strong>以上我们能发现weak的管理实际上跟weak_table有这千丝万缕的联系,接下来就对weak_table进行分析!</strong></p>
<h4 id="weakTable"><a href="#weakTable" class="headerlink" title="weakTable"></a>weakTable</h4><p>(关先上源码还是先总结…我思考了很久…。。。。)</p>
<ul>
<li>weak表是一个弱引用表，实现为一个weak_table_t结构体，存储了所有对象相关的的所有的弱引用信息</li>
<li>其中weak_entry_t是存储在弱引用表中的一个内部结构体，它负责维护和存储指向一个对象的所有弱引用hash表。</li>
<li>weak_entry_t中的referrers 存储了指向weak对象的所有变量</li>
</ul>
<p><strong>来张图直观感受一下:</strong><br><img src="weakTable.dot.pdf" alt="weakTable"></p>
<p>下面开始对这些结构体进行分析:</p>
<ul>
<li>SideTable是一个用C++实现的类，它的具体定义在NSObject.mm中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class SideTable &#123;</span><br><span class="line">private:</span><br><span class="line">    static uint8_t table_buf[SIDE_TABLE_STRIPE * SIDE_TABLE_SIZE];</span><br><span class="line">public:</span><br><span class="line">    RefcountMap refcnts;//引用计数表</span><br><span class="line">    weak_table_t weak_table;//弱引用表</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>weak表的结构定义:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The global weak references table. Stores object ids as keys,</span></span><br><span class="line"><span class="comment"> * and weak_entry_t structs as their values.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">weak_table_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">weak_entry_t</span> *weak_entries;</span><br><span class="line">    <span class="keyword">size_t</span>    num_entries;</span><br><span class="line">    <span class="keyword">uintptr_t</span> mask;</span><br><span class="line">    <span class="keyword">uintptr_t</span> max_hash_displacement;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是一张存储全局弱引用对象的表<br>object 的 ids 作为Hash表的keys<br>weak_entry_t 作为他们的值.</p>
<p>来看weak_entry_t的结构体    </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">weak_entry_t</span> &#123;</span></span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; referent;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">weak_referrer_t</span> *referrers;</span><br><span class="line">            <span class="keyword">uintptr_t</span>        out_of_line : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">uintptr_t</span>        num_refs : PTR_MINUS_1;</span><br><span class="line">            <span class="keyword">uintptr_t</span>        mask;</span><br><span class="line">            <span class="keyword">uintptr_t</span>        max_hash_displacement;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="comment">// out_of_line=0 is LSB of one of these (don't care which)</span></span><br><span class="line">            <span class="keyword">weak_referrer_t</span>  inline_referrers[WEAK_INLINE_COUNT];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>referrers: 所有指向 referent 的指针<br>referent: 指向内存上的weak对象的指针<br>weak_referrer_t: referent对象的地址</p>
<p><img src="referent%E5%85%B3%E7%B3%BB.png" alt="referent关系.png"></p>
<p>现在我们可以得出什么结论了呢</p>
<ol>
<li>OC中 弱引用变量的管理是利用 weak表(Hash表)来管理的</li>
<li>weak表中的weak_entries负责管理指向weak对象的变量</li>
</ol>
<h4 id="weak对象的释放"><a href="#weak对象的释放" class="headerlink" title="weak对象的释放"></a>weak对象的释放</h4><p>释放对象时，废弃谁都不持有的对象的同时，程序的动作是怎么样的呢？</p>
<ul>
<li>objc_release</li>
<li>因为引用计数为0所以执行dealloc</li>
<li>objc rootDealloc</li>
<li>objc dispose</li>
<li>objc destructInstance</li>
<li>objc clear dealloctaing</li>
</ul>
<p>对象被废弃时最后调用的objc_clear_deallocating函数的动作如下：<br>(1) 从weak表中获取废弃对象的地址为键值的记录。<br>(2) 将包含在记录中的所有附有__weak修饰符变量的地址，赋值为nil<br>(3) 从weak表中删除该记录。<br>(4) 从引用计数表中删除废弃对象的地址为键值的记录。</p>
<p><strong>由此可知，如果大量使用附有<strong>weak修饰符的变量，则会消耗相应的CPU资源。良策是只在需要避免循环引用时使用</strong>weak修饰符。</strong></p>
<h3 id="立即释放对象"><a href="#立即释放对象" class="headerlink" title="立即释放对象"></a>立即释放对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    id __weak obj = [[NSObject alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为该源码将自己生成并持有的对象赋值给附有__weak修饰符的变量中，所以自己不能持有该对象，这是会被释放并且废弃。</p>
<h3 id="使用附有-weak修饰符的变量，即是使用注册到autoreleasepool中的对象"><a href="#使用附有-weak修饰符的变量，即是使用注册到autoreleasepool中的对象" class="headerlink" title="使用附有__weak修饰符的变量，即是使用注册到autoreleasepool中的对象"></a>使用附有__weak修饰符的变量，即是使用注册到autoreleasepool中的对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    id __weak obj1 = obj;</span><br><span class="line">    NSLog(@&quot;%@&quot;,obj1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译器模拟的代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">id obj1;</span><br><span class="line">objc_initWeak(&amp;obj,obj);</span><br><span class="line">id tmp = objc_loadWeakRetained(&amp;obj);</span><br><span class="line">objc_autorelease(tmp);</span><br><span class="line">NSLog(@&quot;%@&quot;, tmp);</span><br><span class="line">objc_destoryWeak(&amp;obj1);</span><br></pre></td></tr></table></figure>


<p><strong>注意这两行代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id tmp = objc_loadWeakRetained(&amp;obj);</span><br><span class="line">objc_autorelease(tmp);</span><br></pre></td></tr></table></figure>
<p><strong>与赋值时相比，在使用附有__weak修饰符变量的情况下，增加了对objc_loadWeakRetained函数和objc_autorelease函数的调用。</strong><br>(1) objc_loadWeakRetained 函数取出附有__weak修饰符变量所引用的对象并retain<br>(2) objc_autorelease 函数将对象注册到autoreleasepool中。</p>
<p><strong>注意：</strong><br>每次使用<strong>weak修饰的变量，会使变量所引用的对象注册到autoreleasepool中。<br>如果要避免这种情况可以将附有</strong>weak修饰符的变量赋值给附有__strong修饰符的变量后再次使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id __weak o = obj;</span><br><span class="line">id tmp = o;</span><br></pre></td></tr></table></figure>

<h3 id="allowWeakReference-retainWeakReference"><a href="#allowWeakReference-retainWeakReference" class="headerlink" title="allowWeakReference/retainWeakReference"></a>allowWeakReference/retainWeakReference</h3><p>当allowsWeakReference/retainWeakReference实例方法(没有写入NSObject接口说明文档中)返回NO的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)allowsWeakReference;</span><br><span class="line">- (BOOL)retainWeakReference;</span><br></pre></td></tr></table></figure>
<p>在赋值给__weak修饰符的变量时,如果allowsWeakReference方法返回NO，程序将异常终止。<br>对象retain时,如果retainWeakReference方法返回NO, 该变量将使用nil</p>
<h3 id="具体源码分析"><a href="#具体源码分析" class="headerlink" title="具体源码分析"></a>具体源码分析</h3><p>以上关于weak的</p>
<ul>
<li>weak_register_no_lock</li>
<li>weak_unregister_no_lock</li>
<li>。。。<br>很多具体实现都没有讲…<br>我把自己看的代码加上注释贴出来了…感兴趣的可以看一下具体的实现…感受源码实现的魅力</li>
</ul>
<p><a href="https://github.com/opensource-apple/objc4" target="_blank" rel="noopener">objc开源部分</a></p>
<p><strong>weak_unregister_no_lock</strong><br>怎么理解呢objc_object **referrer?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">objc_object **referrer = (objc_object **)referrer_id;</span><br></pre></td></tr></table></figure>

<p>referent 是一个指针，指向内存上的对象的存储位置.<br>referrer 只指向referent的指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*referrer = referent</span><br></pre></td></tr></table></figure>

<p>我们要结合remove_referrer这个函数来理解</p>
<p><strong>remove_referrer</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;inline_referrers[i] == old_referrer) &#123;</span><br><span class="line">                entry-&gt;inline_referrers[i] = nil;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p><img src="referrer.dot.pdf" alt="referrer理解"></p>
<p>所以我们要拿到referrer 根据这个值来和entry链表中的指针进行比较，如果发现，就nil</p>
<p>（指针搞得我都晕了…佩服c/c++系统工程师）<br>（阅读源码真的是一件有意思的是哈哈）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"objc-private.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"objc-weak.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libkern/OSAtomic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TABLE_SIZE(entry) (entry-&gt;mask ? entry-&gt;mask + 1 : 0)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">append_referrer</span><span class="params">(<span class="keyword">weak_entry_t</span> *entry, objc_object **new_referrer)</span></span>;</span><br><span class="line"></span><br><span class="line">BREAKPOINT_FUNCTION(</span><br><span class="line">    <span class="keyword">void</span> objc_weak_error(<span class="keyword">void</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Unique hash function for object pointers only.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param key The object pointer</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return Size unrestricted hash of pointer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> uintptr_t <span class="title">hash_pointer</span><span class="params">(objc_object *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ptr_hash((<span class="keyword">uintptr_t</span>)key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Unique hash function for weak object pointers only.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param key The weak object pointer. </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return Size unrestricted hash of pointer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> uintptr_t <span class="title">w_hash_pointer</span><span class="params">(objc_object **key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ptr_hash((<span class="keyword">uintptr_t</span>)key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Grow the entry's hash table of referrers. Rehashes each</span></span><br><span class="line"><span class="comment"> * of the referrers.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param entry Weak pointer hash set for a particular object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__attribute__((noinline, used))</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">grow_refs_and_insert</span><span class="params">(<span class="keyword">weak_entry_t</span> *entry, </span></span></span><br><span class="line"><span class="function"><span class="params">                                 objc_object **new_referrer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(entry-&gt;out_of_line);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> old_size = TABLE_SIZE(entry);</span><br><span class="line">    <span class="keyword">size_t</span> new_size = old_size ? old_size * <span class="number">2</span> : <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> num_refs = entry-&gt;num_refs;</span><br><span class="line">    <span class="keyword">weak_referrer_t</span> *old_refs = entry-&gt;referrers;</span><br><span class="line">    entry-&gt;mask = new_size - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    entry-&gt;referrers = (<span class="keyword">weak_referrer_t</span> *)</span><br><span class="line">        <span class="built_in">calloc</span>(TABLE_SIZE(entry), <span class="keyword">sizeof</span>(<span class="keyword">weak_referrer_t</span>));</span><br><span class="line">    entry-&gt;num_refs = <span class="number">0</span>;</span><br><span class="line">    entry-&gt;max_hash_displacement = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; old_size &amp;&amp; num_refs &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (old_refs[i] != nil) &#123;</span><br><span class="line">            append_referrer(entry, old_refs[i]);</span><br><span class="line">            num_refs--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Insert</span></span><br><span class="line">    append_referrer(entry, new_referrer);</span><br><span class="line">    <span class="keyword">if</span> (old_refs) <span class="built_in">free</span>(old_refs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Add the given referrer to set of weak pointers in this entry.</span></span><br><span class="line"><span class="comment"> * Does not perform duplicate checking (b/c weak pointers are never</span></span><br><span class="line"><span class="comment"> * added to a set twice). </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param entry The entry holding the set of weak pointers. </span></span><br><span class="line"><span class="comment"> * @param new_referrer The new weak pointer to be added.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">append_referrer</span><span class="params">(<span class="keyword">weak_entry_t</span> *entry, objc_object **new_referrer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// if is Array implementation</span></span><br><span class="line">    <span class="keyword">if</span> (! entry-&gt;out_of_line) &#123;</span><br><span class="line">        <span class="comment">// Try to insert inline.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;inline_referrers[i] == nil) &#123;</span><br><span class="line">                entry-&gt;inline_referrers[i] = new_referrer;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Couldn't insert inline. Allocate out of line.</span></span><br><span class="line">        <span class="keyword">weak_referrer_t</span> *new_referrers = (<span class="keyword">weak_referrer_t</span> *)</span><br><span class="line">            <span class="built_in">calloc</span>(WEAK_INLINE_COUNT, <span class="keyword">sizeof</span>(<span class="keyword">weak_referrer_t</span>));</span><br><span class="line">        <span class="comment">// This constructed table is invalid, but grow_refs_and_insert</span></span><br><span class="line">        <span class="comment">// will fix it and rehash it.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            new_referrers[i] = entry-&gt;inline_referrers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        entry-&gt;referrers = new_referrers;</span><br><span class="line">        entry-&gt;num_refs = WEAK_INLINE_COUNT;</span><br><span class="line">        entry-&gt;out_of_line = <span class="number">1</span>;</span><br><span class="line">        entry-&gt;mask = WEAK_INLINE_COUNT<span class="number">-1</span>;</span><br><span class="line">        entry-&gt;max_hash_displacement = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(entry-&gt;out_of_line);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;num_refs &gt;= TABLE_SIZE(entry) * <span class="number">3</span>/<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> grow_refs_and_insert(entry, new_referrer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//find a place to insert ref</span></span><br><span class="line">    <span class="comment">//weak_entry_remove() may bzero() some place</span></span><br><span class="line">    <span class="keyword">size_t</span> index = w_hash_pointer(new_referrer) &amp; (entry-&gt;mask);</span><br><span class="line">    <span class="keyword">size_t</span> hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (entry-&gt;referrers[index] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; entry-&gt;mask;</span><br><span class="line">        hash_displacement++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123;</span><br><span class="line">        entry-&gt;max_hash_displacement = hash_displacement;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">weak_referrer_t</span> &amp;ref = entry-&gt;referrers[index];</span><br><span class="line">    ref = new_referrer;</span><br><span class="line">    entry-&gt;num_refs++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Remove old_referrer from set of referrers, if it's present.</span></span><br><span class="line"><span class="comment"> * Does not remove duplicates, because duplicates should not exist. </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @todo this is slow if old_referrer is not present. Is this ever the case? </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param entry The entry holding the referrers.</span></span><br><span class="line"><span class="comment"> * @param old_referrer The referrer to remove. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove_referrer</span><span class="params">(<span class="keyword">weak_entry_t</span> *entry, objc_object **old_referrer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! entry-&gt;out_of_line) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;inline_referrers[i] == old_referrer) &#123;</span><br><span class="line">                entry-&gt;inline_referrers[i] = nil;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _objc_inform(<span class="string">"Attempted to unregister unknown __weak variable "</span></span><br><span class="line">                     <span class="string">"at %p. This is probably incorrect use of "</span></span><br><span class="line">                     <span class="string">"objc_storeWeak() and objc_loadWeak(). "</span></span><br><span class="line">                     <span class="string">"Break on objc_weak_error to debug.\n"</span>, </span><br><span class="line">                     old_referrer);</span><br><span class="line">        objc_weak_error();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> index = w_hash_pointer(old_referrer) &amp; (entry-&gt;mask);</span><br><span class="line">    <span class="keyword">size_t</span> hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (entry-&gt;referrers[index] != old_referrer) &#123;</span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; entry-&gt;mask;</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        <span class="keyword">if</span> (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"Attempted to unregister unknown __weak variable "</span></span><br><span class="line">                         <span class="string">"at %p. This is probably incorrect use of "</span></span><br><span class="line">                         <span class="string">"objc_storeWeak() and objc_loadWeak(). "</span></span><br><span class="line">                         <span class="string">"Break on objc_weak_error to debug.\n"</span>, </span><br><span class="line">                         old_referrer);</span><br><span class="line">            objc_weak_error();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    entry-&gt;referrers[index] = nil;</span><br><span class="line">    entry-&gt;num_refs--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Add new_entry to the object's table of weak references.</span></span><br><span class="line"><span class="comment"> * Does not check whether the referent is already in the table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">weak_entry_insert</span><span class="params">(<span class="keyword">weak_table_t</span> *weak_table, <span class="keyword">weak_entry_t</span> *new_entry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">weak_entry_t</span> *weak_entries = weak_table-&gt;weak_entries;</span><br><span class="line">    assert(weak_entries != nil);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//mask may keep entry in array</span></span><br><span class="line">    <span class="keyword">size_t</span> index = hash_pointer(new_entry-&gt;referent) &amp; (weak_table-&gt;mask);</span><br><span class="line">    <span class="keyword">size_t</span> hash_displacement = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//hash index 处理</span></span><br><span class="line">    <span class="keyword">while</span> (weak_entries[index].referent != nil) &#123;</span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; weak_table-&gt;mask;</span><br><span class="line">        hash_displacement++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    weak_entries[index] = *new_entry;</span><br><span class="line">    weak_table-&gt;num_entries++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//update max_hash_displacement</span></span><br><span class="line">    <span class="keyword">if</span> (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123;</span><br><span class="line">        weak_table-&gt;max_hash_displacement = hash_displacement;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">weak_resize</span><span class="params">(<span class="keyword">weak_table_t</span> *weak_table, <span class="keyword">size_t</span> new_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> old_size = TABLE_SIZE(weak_table);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak_entry_t</span> *old_entries = weak_table-&gt;weak_entries;</span><br><span class="line">    <span class="keyword">weak_entry_t</span> *new_entries = (<span class="keyword">weak_entry_t</span> *)</span><br><span class="line">        <span class="built_in">calloc</span>(new_size, <span class="keyword">sizeof</span>(<span class="keyword">weak_entry_t</span>));</span><br><span class="line"></span><br><span class="line">    weak_table-&gt;mask = new_size - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//new</span></span><br><span class="line">    weak_table-&gt;weak_entries = new_entries;</span><br><span class="line">    weak_table-&gt;max_hash_displacement = <span class="number">0</span>;</span><br><span class="line">    weak_table-&gt;num_entries = <span class="number">0</span>;  <span class="comment">// restored by weak_entry_insert below</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//use pointer</span></span><br><span class="line">    <span class="keyword">if</span> (old_entries) &#123;</span><br><span class="line">        <span class="keyword">weak_entry_t</span> *entry;</span><br><span class="line">        <span class="keyword">weak_entry_t</span> *<span class="built_in">end</span> = old_entries + old_size;</span><br><span class="line">        <span class="keyword">for</span> (entry = old_entries; entry &lt; <span class="built_in">end</span>; entry++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;referent) &#123;</span><br><span class="line">                weak_entry_insert(weak_table, entry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(old_entries);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Grow the given zone's table of weak references if it is full.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">weak_grow_maybe</span><span class="params">(<span class="keyword">weak_table_t</span> *weak_table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> old_size = TABLE_SIZE(weak_table);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Grow if at least 3/4 full.</span></span><br><span class="line">    <span class="keyword">if</span> (weak_table-&gt;num_entries &gt;= old_size * <span class="number">3</span> / <span class="number">4</span>) &#123;</span><br><span class="line">        weak_resize(weak_table, old_size ? old_size*<span class="number">2</span> : <span class="number">64</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Shrink the table if it is mostly empty.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">weak_compact_maybe</span><span class="params">(<span class="keyword">weak_table_t</span> *weak_table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> old_size = TABLE_SIZE(weak_table);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shrink if larger than 1024 buckets and at most 1/16 full.</span></span><br><span class="line">    <span class="keyword">if</span> (old_size &gt;= <span class="number">1024</span>  &amp;&amp; old_size / <span class="number">16</span> &gt;= weak_table-&gt;num_entries) &#123;</span><br><span class="line">        weak_resize(weak_table, old_size / <span class="number">8</span>);</span><br><span class="line">        <span class="comment">// leaves new table no more than 1/2 full</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Remove entry from the zone's table of weak references.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">weak_entry_remove</span><span class="params">(<span class="keyword">weak_table_t</span> *weak_table, <span class="keyword">weak_entry_t</span> *entry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// remove entry</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;out_of_line) <span class="built_in">free</span>(entry-&gt;referrers);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//bzero()函数在由s指向的区域中放置n个0。</span></span><br><span class="line">    bzero(entry, <span class="keyword">sizeof</span>(*entry));</span><br><span class="line"></span><br><span class="line">    weak_table-&gt;num_entries--;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//maybe resize weak_table</span></span><br><span class="line">    weak_compact_maybe(weak_table);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Return the weak reference table entry for the given referent. </span></span><br><span class="line"><span class="comment"> * If there is no entry for referent, return NULL. </span></span><br><span class="line"><span class="comment"> * Performs a lookup.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param weak_table </span></span><br><span class="line"><span class="comment"> * @param referent The object. Must not be nil.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return The table of weak referrers to this object. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">weak_entry_t</span> *</span><br><span class="line">weak_entry_for_referent(<span class="keyword">weak_table_t</span> *weak_table, objc_object *referent)</span><br><span class="line">&#123;</span><br><span class="line">    assert(referent);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">weak_entry_t</span> *weak_entries = weak_table-&gt;weak_entries;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!weak_entries) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> index = hash_pointer(referent) &amp; weak_table-&gt;mask;</span><br><span class="line">    <span class="keyword">size_t</span> hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (weak_table-&gt;weak_entries[index].referent != referent) &#123;</span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; weak_table-&gt;mask;</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        <span class="keyword">if</span> (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123;</span><br><span class="line">            <span class="keyword">return</span> nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &amp;weak_table-&gt;weak_entries[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Unregister an already-registered weak reference.</span></span><br><span class="line"><span class="comment"> * This is used when referrer's storage is about to go away, but referent</span></span><br><span class="line"><span class="comment"> * isn't dead yet. (Otherwise, zeroing referrer later would be a</span></span><br><span class="line"><span class="comment"> * bad memory access.)</span></span><br><span class="line"><span class="comment"> * Does nothing if referent/referrer is not a currently active weak reference.</span></span><br><span class="line"><span class="comment"> * Does not zero referrer.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * FIXME currently requires old referent value to be passed in (lame)</span></span><br><span class="line"><span class="comment"> * FIXME unregistration should be automatic if referrer is collected</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param weak_table The global weak table.</span></span><br><span class="line"><span class="comment"> * @param referent The object.</span></span><br><span class="line"><span class="comment"> * @param referrer The weak reference.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">weak_unregister_no_lock(<span class="keyword">weak_table_t</span> *weak_table, id referent_id, </span><br><span class="line">                        id *referrer_id)</span><br><span class="line">&#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">    objc_object **referrer = (objc_object **)referrer_id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak_entry_t</span> *entry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!referent) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((entry = weak_entry_for_referent(weak_table, referent))) &#123;</span><br><span class="line">        remove_referrer(entry, referrer);</span><br><span class="line">        <span class="keyword">bool</span> empty = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//after unregister the entry's referrers is empty?</span></span><br><span class="line">        <span class="comment">// Hash implementation</span></span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;out_of_line  &amp;&amp;  entry-&gt;num_refs != <span class="number">0</span>) &#123;</span><br><span class="line">            empty = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Array implementation</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry-&gt;inline_referrers[i]) &#123;</span><br><span class="line">                    empty = <span class="literal">false</span>; </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if entry.references empty</span></span><br><span class="line">        <span class="keyword">if</span> (empty) &#123;</span><br><span class="line">            weak_entry_remove(weak_table, entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not set *referrer = nil. objc_storeWeak() requires that the </span></span><br><span class="line">    <span class="comment">// value not change.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Registers a new (object, weak pointer) pair. Creates a new weak</span></span><br><span class="line"><span class="comment"> * object entry if it does not exist.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param weak_table The global weak table.</span></span><br><span class="line"><span class="comment"> * @param referent The object pointed to by the weak reference.</span></span><br><span class="line"><span class="comment"> * @param referrer The weak pointer address.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">id </span><br><span class="line">weak_register_no_lock(<span class="keyword">weak_table_t</span> *weak_table, id referent_id, </span><br><span class="line">                      id *referrer_id, <span class="keyword">bool</span> crashIfDeallocating)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//object</span></span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//The Point which point the object</span></span><br><span class="line">    objc_object **referrer = (objc_object **)referrer_id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!referent  ||  referent-&gt;isTaggedPointer()) <span class="keyword">return</span> referent_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ensure that the referenced object is viable</span></span><br><span class="line">    <span class="comment">// judge is Allows Weak Reference</span></span><br><span class="line">    <span class="keyword">bool</span> deallocating;</span><br><span class="line">    <span class="keyword">if</span> (!referent-&gt;ISA()-&gt;hasCustomRR()) &#123;</span><br><span class="line">        deallocating = referent-&gt;rootIsDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        BOOL (*allowsWeakReference)(objc_object *, SEL) = </span><br><span class="line">            (BOOL(*)(objc_object *, SEL))</span><br><span class="line">            object_getMethodImplementation((id)referent, </span><br><span class="line">                                           SEL_allowsWeakReference);</span><br><span class="line">        <span class="keyword">if</span> ((IMP)allowsWeakReference == _objc_msgForward) &#123;</span><br><span class="line">            <span class="keyword">return</span> nil;</span><br><span class="line">        &#125;</span><br><span class="line">        deallocating =</span><br><span class="line">            ! (*allowsWeakReference)(referent, SEL_allowsWeakReference);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (deallocating) &#123;</span><br><span class="line">        <span class="keyword">if</span> (crashIfDeallocating) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">"Cannot form weak reference to instance (%p) of "</span></span><br><span class="line">                        <span class="string">"class %s. It is possible that this object was "</span></span><br><span class="line">                        <span class="string">"over-released, or is in the process of deallocation."</span>,</span><br><span class="line">                        (<span class="keyword">void</span>*)referent, object_getClassName((id)referent));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now remember it and where it is being stored</span></span><br><span class="line">    <span class="keyword">weak_entry_t</span> *entry;</span><br><span class="line">    <span class="keyword">if</span> ((entry = weak_entry_for_referent(weak_table, referent))) &#123;</span><br><span class="line">        append_referrer(entry, referrer);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">weak_entry_t</span> new_entry;</span><br><span class="line">        new_entry.referent = referent;</span><br><span class="line">        new_entry.out_of_line = <span class="number">0</span>;</span><br><span class="line">        new_entry.inline_referrers[<span class="number">0</span>] = referrer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            new_entry.inline_referrers[i] = nil;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        weak_grow_maybe(weak_table);</span><br><span class="line">        weak_entry_insert(weak_table, &amp;new_entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not set *referrer. objc_storeWeak() requires that the </span></span><br><span class="line">    <span class="comment">// value not change.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> referent_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line"><span class="keyword">bool</span></span><br><span class="line">weak_is_registered_no_lock(<span class="keyword">weak_table_t</span> *weak_table, id referent_id) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> weak_entry_for_referent(weak_table, (objc_object *)referent_id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Called by dealloc; nils out all weak pointers that point to the </span></span><br><span class="line"><span class="comment"> * provided object so that they can no longer be used.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param weak_table </span></span><br><span class="line"><span class="comment"> * @param referent The object being deallocated. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">weak_clear_no_lock(<span class="keyword">weak_table_t</span> *weak_table, id referent_id) </span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//referent objc</span></span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//referent objc entry(which save many referents)</span></span><br><span class="line">    <span class="keyword">weak_entry_t</span> *entry = weak_entry_for_referent(weak_table, referent);</span><br><span class="line">    <span class="keyword">if</span> (entry == nil) &#123;</span><br><span class="line">        <span class="comment">/// XXX shouldn't happen, but does with mismatched CF/objc</span></span><br><span class="line">        <span class="comment">//printf("XXX no entry for clear deallocating %p\n", referent);</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// zero out references</span></span><br><span class="line">    <span class="keyword">weak_referrer_t</span> *referrers;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;out_of_line) &#123;</span><br><span class="line">        referrers = entry-&gt;referrers;</span><br><span class="line">        count = TABLE_SIZE(entry);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        referrers = entry-&gt;inline_referrers;</span><br><span class="line">        count = WEAK_INLINE_COUNT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//entry-&gt;referrers all nil</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        objc_object **referrer = referrers[i];</span><br><span class="line">        <span class="keyword">if</span> (referrer) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*referrer == referent) &#123;</span><br><span class="line">                *referrer = nil;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (*referrer) &#123;</span><br><span class="line">                _objc_inform(<span class="string">"__weak variable at %p holds %p instead of %p. "</span></span><br><span class="line">                             <span class="string">"This is probably incorrect use of "</span></span><br><span class="line">                             <span class="string">"objc_storeWeak() and objc_loadWeak(). "</span></span><br><span class="line">                             <span class="string">"Break on objc_weak_error to debug.\n"</span>, </span><br><span class="line">                             referrer, (<span class="keyword">void</span>*)*referrer, (<span class="keyword">void</span>*)referent);</span><br><span class="line">                objc_weak_error();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    weak_entry_remove(weak_table, entry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * This function gets called when the value of a weak pointer is being </span></span><br><span class="line"><span class="comment"> * used in an expression. Called by objc_loadWeakRetained() which is</span></span><br><span class="line"><span class="comment"> * ultimately called by objc_loadWeak(). The objective is to assert that</span></span><br><span class="line"><span class="comment"> * there is in fact a weak pointer(s) entry for this particular object being</span></span><br><span class="line"><span class="comment"> * stored in the weak-table, and to retain that object so it is not deallocated</span></span><br><span class="line"><span class="comment"> * during the weak pointer's usage.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param weak_table </span></span><br><span class="line"><span class="comment"> * @param referrer The weak pointer address. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Once upon a time we eagerly cleared *referrer if we saw the referent </span></span><br><span class="line"><span class="comment">  was deallocating. This confuses code like NSPointerFunctions which </span></span><br><span class="line"><span class="comment">  tries to pre-flight the raw storage and assumes if the storage is </span></span><br><span class="line"><span class="comment">  zero then the weak system is done interfering. That is false: the </span></span><br><span class="line"><span class="comment">  weak system is still going to check and clear the storage later. </span></span><br><span class="line"><span class="comment">  This can cause objc_weak_error complaints and crashes.</span></span><br><span class="line"><span class="comment">  So we now don't touch the storage until deallocation completes.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">id </span><br><span class="line">weak_read_no_lock(<span class="keyword">weak_table_t</span> *weak_table, id *referrer_id) </span><br><span class="line">&#123;</span><br><span class="line">    objc_object **referrer = (objc_object **)referrer_id;</span><br><span class="line">    objc_object *referent = *referrer;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Detection Tagged Pointer</span></span><br><span class="line">    <span class="keyword">if</span> (referent-&gt;isTaggedPointer()) <span class="keyword">return</span> (id)referent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak_entry_t</span> *entry;</span><br><span class="line">    <span class="comment">// referent == nil or entry == nil</span></span><br><span class="line">    <span class="keyword">if</span> (referent == nil  ||  </span><br><span class="line">        !(entry = weak_entry_for_referent(weak_table, referent))) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Custom RR denotes a custom retain-release implementation</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (! referent-&gt;ISA()-&gt;hasCustomRR()) &#123;</span><br><span class="line">        <span class="comment">//???question</span></span><br><span class="line">        <span class="keyword">if</span> (! referent-&gt;rootTryRetain()) &#123;</span><br><span class="line">            <span class="keyword">return</span> nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//has isa</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        BOOL (*tryRetain)(objc_object *, SEL) = (BOOL(*)(objc_object *, SEL))</span><br><span class="line">            object_getMethodImplementation((id)referent, </span><br><span class="line">                                           SEL_retainWeakReference);</span><br><span class="line">        <span class="comment">//IMP != _objc_magForward</span></span><br><span class="line">        <span class="keyword">if</span> ((IMP)tryRetain == _objc_msgForward) &#123;</span><br><span class="line">            <span class="keyword">return</span> nil;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//IMP != nil</span></span><br><span class="line">        <span class="keyword">if</span> (! (*tryRetain)(referent, SEL_retainWeakReference)) &#123;</span><br><span class="line">            <span class="keyword">return</span> nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (id)referent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/02/01/Objective-C-weak-%E5%85%B3%E9%94%AE%E5%AD%97-%E5%AE%9E%E7%8E%B0-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" data-id="ck3g0y6yr000aqy36gs3j4bia" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  


  <div id="page-nav">
    <nav><ul class="pagination"><li><a class="page-prev" rel="prev" href="/"><i class="fa fa-chevron-left"></i> Prev</a></li><li><a class="page-number" href="/">1</a></li><li class="active"><span class="page-number">2</span></li><li><a class="page-number" href="/page/3/">3</a></li><li><a class="page-next" rel="next" href="/page/3/">Next <i class="fa fa-chevron-right"></i></a></li></ul></nav>
  </div>



        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          
  <div class="sidebar-module sidebar-module-inset">
  <h4>About</h4>
  <p>手淘架构组招人 jimu.xjy@alibaba-inc.com</p>

</div>


  
  <div class="sidebar-module">
    <h4>Categories</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/APM/">APM</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Hook/">Hook</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/iOS/">iOS</a><span class="sidebar-module-list-count">7</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/%E7%A0%94%E5%8F%91%E6%B5%81%E7%A8%8B/">研发流程</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/">设计架构</a><span class="sidebar-module-list-count">3</span></li></ul>
  </div>



  


  

  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/10/">October 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/09/">September 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/09/">September 2018</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/06/">June 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/05/">May 2018</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/04/">April 2018</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/01/">January 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/12/">December 2017</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/11/">November 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/10/">October 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/09/">September 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/05/">May 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/04/">April 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/02/">February 2017</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/01/">January 2017</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Recents</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/2019/10/05/cocoapodsdev/">CocoaPods插件开发原理(一) CocoaPods做了啥</a>
        </li>
      
        <li>
          <a href="/2019/09/28/CrashMonitorSystem/">崩溃捕获系统的原理（一）异常信号</a>
        </li>
      
        <li>
          <a href="/2018/09/30/dwarf%E5%92%8C%E7%AC%A6%E5%8F%B7%E5%8C%96/">DWARF和符号化</a>
        </li>
      
        <li>
          <a href="/2018/09/16/CrashSymbolicateSystemDesign/">APM Crash系统</a>
        </li>
      
        <li>
          <a href="/2018/06/13/libmalloc/">libmalloc &#34;malloc&#34; 探究</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2019 junyixie<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  

<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>



<script src="/js/script.js"></script>

</body>
</html>
