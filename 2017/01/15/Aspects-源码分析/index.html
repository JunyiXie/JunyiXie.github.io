<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Aspects 源码分析 | xiejunyi Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="简介Aspects是一个面向切面编程的库。如果想深入了解iOS Runtime中的消息发送机制，Aspects的源码是值得分析的。     项目主页Aspects 核心实现Aspects的核心实现就是利用Runtime中的消息分发机制： Aspects通过把selector的方法替换为msg_forward方法转发 转而调用 forwardInvocation（forwardInvocation的">
<meta property="og:type" content="article">
<meta property="og:title" content="Aspects 源码分析">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2017&#x2F;01&#x2F;15&#x2F;Aspects-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90&#x2F;index.html">
<meta property="og:site_name" content="xiejunyi Blog">
<meta property="og:description" content="简介Aspects是一个面向切面编程的库。如果想深入了解iOS Runtime中的消息发送机制，Aspects的源码是值得分析的。     项目主页Aspects 核心实现Aspects的核心实现就是利用Runtime中的消息分发机制： Aspects通过把selector的方法替换为msg_forward方法转发 转而调用 forwardInvocation（forwardInvocation的">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-11-26T15:34:03.905Z">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="xiejunyi Blog" type="application/atom+xml">
  
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  <link rel="stylesheet" href="/css/styles.css">
  

</head>

<body>
  <nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">xiejunyi Blog</h1>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          <article id="post-Aspects-源码分析" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 class="article-title" itemprop="name">
      Aspects 源码分析
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/01/15/Aspects-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="article-date"><time datetime="2017-01-15T10:03:27.000Z" itemprop="datePublished">2017-01-15</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Aspects是一个面向切面编程的库。<br>如果想深入了解iOS Runtime中的消息发送机制，Aspects的源码是值得分析的。    </p>
<p><strong>项目主页</strong><br><a href="https://github.com/steipete/Aspects" target="_blank" rel="noopener">Aspects</a></p>
<h2 id="核心实现"><a href="#核心实现" class="headerlink" title="核心实现"></a>核心实现</h2><p>Aspects的核心实现就是利用Runtime中的消息分发机制：</p>
<p><strong>Aspects通过把selector的方法替换为msg_forward方法转发 转而调用 forwardInvocation（forwardInvocation的实现被Aspects替换，将原来的方法实现与添加的实现组合在了一起）</strong></p>
<h2 id="核心源码分析"><a href="#核心源码分析" class="headerlink" title="核心源码分析"></a>核心源码分析</h2><p>这是Aspects 面向切面编程的入口方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector</span><br><span class="line">                      withOptions:(AspectOptions)options</span><br><span class="line">                       usingBlock:(<span class="keyword">id</span>)block</span><br><span class="line">                            error:(<span class="built_in">NSError</span> **)error &#123;</span><br><span class="line">    <span class="keyword">return</span> aspect_add(<span class="keyword">self</span>, selector, options, block, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这段代码可以分三部分来看</p>
<ol>
<li><strong>aspect_isSelectorAllowedAndTrack 这个方法 对父子类同时hook一个方法进行了一些限制</strong></li>
<li><strong>aspect_getContainerForObject 通过Runtime添加关联值的方式 管理hook的方法</strong></li>
<li><strong>aspect_prepareClassAndHookSelector 这是核心的实现，涉及到动态生成子类，改变isa指针的指向，改变方法的实现 一系列操作</strong></li>
</ol>
<h3 id="能否Hook-判断"><a href="#能否Hook-判断" class="headerlink" title="能否Hook 判断"></a>能否Hook 判断</h3><p><code>aspect_isSelectorAllowedAndTrack</code> 中会判断方法能否被hook </p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断当前这个类有没有曾经hock 过方法</span></span><br><span class="line">AspectTracker *tracker = swizzledClassesDict[currentClass];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ([tracker subclassHasHookedSelectorName:selectorName]) &#123;</span><br><span class="line">    <span class="built_in">NSSet</span> *subclassTracker = [tracker subclassTrackersHookingSelectorName:selectorName];</span><br><span class="line">    <span class="built_in">NSSet</span> *subclassNames = [subclassTracker valueForKey:<span class="string">@"trackedClassName"</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *errorDescription = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Error: %@ already hooked subclasses: %@. A method can only be hooked once per class hierarchy."</span>, selectorName, subclassNames];</span><br><span class="line">    AspectError(AspectErrorSelectorAlreadyHookedInClassHierarchy, errorDescription);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举个例子<br>比如说:<br>UIView hook 了 <code>initWithFrame:</code> 为 method1<br>UIButton hook 了 <code>initWithFrame:</code> 为 method1</p>
<p>UIButton 调用 <code>initWithFrame:</code> 时 是 method1 ，method1 中的实现会 调用<code>[super initWithFrame:]</code> ，而<code>[super initWithFrame:]</code> 是 method1 这就造成了循环引用</p>
<p>最近发现了一片文章提供了解决重复hook的解决方案,阿里星牛逼！</p>
<blockquote>
<p><a href="http://satanwoo.github.io/2017/09/24/mainthreadchecker1/" target="_blank" rel="noopener">基于桥的全量方法Hook方案 - 探究苹果主线程检查实现</a></p>
</blockquote>
<h3 id="管理hook"><a href="#管理hook" class="headerlink" title="管理hook"></a>管理hook</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> aspect_add(<span class="keyword">id</span> <span class="keyword">self</span>, SEL selector, AspectOptions options, <span class="keyword">id</span> block, <span class="built_in">NSError</span> **error) &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(<span class="keyword">self</span>);</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(selector);</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(block);</span><br><span class="line"></span><br><span class="line">    __block AspectIdentifier *identifier = <span class="literal">nil</span>;</span><br><span class="line">    aspect_performLocked(^&#123;</span><br><span class="line">        <span class="keyword">if</span> (aspect_isSelectorAllowedAndTrack(<span class="keyword">self</span>, selector, options, error)) &#123;</span><br><span class="line">            <span class="comment">//一个实例 只有一个container</span></span><br><span class="line">            <span class="comment">//这是区分实例对象和类对象的关键</span></span><br><span class="line">            <span class="comment">//实例对象可以有很多个，但是同一个类的类对象只能有一个</span></span><br><span class="line">            AspectsContainer *aspectContainer = aspect_getContainerForObject(<span class="keyword">self</span>, selector);</span><br><span class="line">            <span class="comment">//原来的selector block</span></span><br><span class="line">            identifier = [AspectIdentifier identifierWithSelector:selector object:<span class="keyword">self</span> options:options block:block error:error];</span><br><span class="line">            <span class="keyword">if</span> (identifier) &#123;</span><br><span class="line">                <span class="comment">//container 里 存有 identifier (selector,block)</span></span><br><span class="line">                [aspectContainer addAspect:identifier withOptions:options];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Modify the class to allow message interception.</span></span><br><span class="line">                aspect_prepareClassAndHookSelector(<span class="keyword">self</span>, selector, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> identifier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态生成子类，改变isa指针"><a href="#动态生成子类，改变isa指针" class="headerlink" title="动态生成子类，改变isa指针"></a>动态生成子类，改变isa指针</h3><p> <strong>aspect_prepareClassAndHookSelector这是核心的实现，涉及到动态生成子类，改变isa指针，改变方法的实现 一系列操作</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> aspect_prepareClassAndHookSelector(<span class="built_in">NSObject</span> *<span class="keyword">self</span>, SEL selector, <span class="built_in">NSError</span> **error) &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(selector);</span><br><span class="line">    <span class="comment">//动态创建子类，改变forwardInvocation方法的实现</span></span><br><span class="line">    Class klass = aspect_hookClass(<span class="keyword">self</span>, error);</span><br><span class="line">    Method targetMethod = class_getInstanceMethod(klass, selector);</span><br><span class="line">    IMP targetMethodIMP = method_getImplementation(targetMethod);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!aspect_isMsgForwardIMP(targetMethodIMP)) &#123;</span><br><span class="line">        <span class="comment">// Make a method alias for the existing method implementation, it not already copied.</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *typeEncoding = method_getTypeEncoding(targetMethod);</span><br><span class="line">        SEL aliasSelector = aspect_aliasForSelector(selector);</span><br><span class="line">        <span class="keyword">if</span> (![klass instancesRespondToSelector:aliasSelector]) &#123;</span><br><span class="line">            <span class="comment">//子类的aliasSelector的实现为 当前类的selector</span></span><br><span class="line">            __unused <span class="built_in">BOOL</span> addedAlias = class_addMethod(klass, aliasSelector, method_getImplementation(targetMethod), typeEncoding);</span><br><span class="line">            <span class="built_in">NSCAssert</span>(addedAlias, <span class="string">@"Original implementation for %@ is already copied to %@ on %@"</span>, <span class="built_in">NSStringFromSelector</span>(selector), <span class="built_in">NSStringFromSelector</span>(aliasSelector), klass);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//selector方法替换为_objc_msgForward</span></span><br><span class="line">        <span class="comment">// We use forwardInvocation to hook in.</span></span><br><span class="line">        class_replaceMethod(klass, selector, aspect_getMsgForwardIMP(<span class="keyword">self</span>, selector), typeEncoding);</span><br><span class="line">        AspectLog(<span class="string">@"Aspects: Installed hook for -[%@ %@]."</span>, klass, <span class="built_in">NSStringFromSelector</span>(selector));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个写法有点像KVO的实现。动态生成子类，hook子类的forwardInvocation方法，并且将isa指针指向subclass, 这种写法对于使用者，没有什么影响，可以当成原来的对象使用，Swizzling子类的方法，避免了去改变对象的类。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - Hook Class</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Class aspect_hookClass(<span class="built_in">NSObject</span> *<span class="keyword">self</span>, <span class="built_in">NSError</span> **error) &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(<span class="keyword">self</span>);</span><br><span class="line">    <span class="comment">//这里可以思考一下 class 方法 和 isa 的区别</span></span><br><span class="line">    <span class="comment">//[self class] KVO可能改变了isa指针的指向</span></span><br><span class="line">    Class statedClass = <span class="keyword">self</span>.class;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// object_getClass 能准确的找到isa指针</span></span><br><span class="line">    Class baseClass = object_getClass(<span class="keyword">self</span>);</span><br><span class="line">    <span class="built_in">NSString</span> *className = <span class="built_in">NSStringFromClass</span>(baseClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Already subclassed</span></span><br><span class="line">    <span class="comment">//如果已经子类化了 就返回</span></span><br><span class="line">    <span class="keyword">if</span> ([className hasSuffix:AspectsSubclassSuffix]) &#123;</span><br><span class="line">        <span class="keyword">return</span> baseClass;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果是类 就改掉类的forwardInvocation 而不是一个子类对象</span></span><br><span class="line">        <span class="comment">// We swizzle a class object, not a single object.</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (class_isMetaClass(baseClass)) &#123;</span><br><span class="line">        <span class="keyword">return</span> aspect_swizzleClassInPlace((Class)<span class="keyword">self</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//考虑到KVO,KVO的底层实现,交换了isa指针</span></span><br><span class="line">        <span class="comment">// Probably a KVO'ed class. Swizzle in place. Also swizzle meta classes in place.</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (statedClass != baseClass) &#123;</span><br><span class="line">        <span class="keyword">return</span> aspect_swizzleClassInPlace(baseClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Default case. Create dynamic subclass.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *subclassName = [className stringByAppendingString:AspectsSubclassSuffix].UTF8String;</span><br><span class="line">    Class subclass = objc_getClass(subclassName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (subclass == <span class="literal">nil</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过创建新子类的方式</span></span><br><span class="line">        subclass = objc_allocateClassPair(baseClass, subclassName, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (subclass == <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *errrorDesc = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"objc_allocateClassPair failed to allocate class %s."</span>, subclassName];</span><br><span class="line">            AspectError(AspectErrorFailedToAllocateClassPair, errrorDesc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// forwardInvocation 替换成 (IMP)_ASPECTS_ARE_BEING_CALLED__</span></span><br><span class="line">        aspect_swizzleForwardInvocation(subclass);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//子类的class方法返回当前被hook的对象的class</span></span><br><span class="line">        aspect_hookedGetClass(subclass, statedClass);</span><br><span class="line">        aspect_hookedGetClass(object_getClass(subclass), statedClass);</span><br><span class="line">        </span><br><span class="line">        objc_registerClassPair(subclass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将当前self设置为子类，这里其实只是更改了self的isa指针而已, 这里hook了子类的forwardInvocation方法，再次使用当前类时，其实是使用了子类的forwardInvocation方法。</span></span><br><span class="line">    object_setClass(<span class="keyword">self</span>, subclass);</span><br><span class="line">    <span class="keyword">return</span> subclass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Hook-方式解析"><a href="#Hook-方式解析" class="headerlink" title="Hook 方式解析"></a>Hook 方式解析</h2><p>目的是：大量的给目的方法打桩 , 打桩的代码相同</p>
<p>思路：传统hook , 直接创建一个新的方法，调用原来的方法，添加代码<br>这样，如果如果要hook 大量的方法，则需要很多method定义</p>
<p>既然我们要给方法添加自己的实现， 等价于  调用方法之前/之后添加实现。</p>
<p>那么我们必须要找到方法是如何调用的</p>
<pre><code>1. 通过符号表直接查找对应符号的IMP
2. objc_msgsend
    + resolveInstance...
    + forwordtarger...
    + forwardInvocation... </code></pre><p>走objc_msgsend 必然会调用三个方法之一<br>resolveInstance.,forwordtarger 拿不到原来方法的target 和 sel ,无法调用原来的实现</p>
<p>forwardInvocation 中的invocation 有target和sel，hook 这个方法，然后添加自己的实现，调用原来的方法</p>
<p>然后如何让方法每次都走objc_msgsend呢？<br>把原来的 sel的IMP改成objc_msgsend.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IMP msgForwardIMP = _objc_msgForward;</span><br><span class="line">class_replaceMethod(cls, originSelector, msgForwardIMP, originTypes);</span><br></pre></td></tr></table></figure>

<p>这时我们需要保存原来的 IMP </p>
<p>然后hook forwardInvocation … 换成自己的实现，调用原来的IMP和新增的代码</p>
<p>然后… 还要注意 如果真的需要 forwardInvocation  的处理问题</p>
<p>ANYMethodLog <a href="https://github.com/qhd/ANYMethodLog" target="_blank" rel="noopener">https://github.com/qhd/ANYMethodLog</a> 这个实现 简单点，考虑的情况少…<br>Aspects <a href="https://github.com/steipete/Aspects" target="_blank" rel="noopener">https://github.com/steipete/Aspects</a> 这个有针对 fowardInvocation 的处理</p>
<p>不同开源库实现的方式多种多样，总之… 你判断就得了呗</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// If no hooks are installed, call original implementation (usually to throw an exception)</span><br><span class="line">if (!respondsToAlias) &#123;</span><br><span class="line">    invocation.selector = originalSelector;</span><br><span class="line">    SEL originalForwardInvocationSEL = NSSelectorFromString(AspectsForwardInvocationSelectorName);</span><br><span class="line">    </span><br><span class="line">    // origin forwardInvocation 处理</span><br><span class="line">    if ([self respondsToSelector:originalForwardInvocationSEL]) &#123;</span><br><span class="line">        ((void( *)(id, SEL, NSInvocation *))objc_msgSend)(self, originalForwardInvocationSEL, invocation);</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        [self doesNotRecognizeSelector:invocation.selector];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="hook-父子类循环问题"><a href="#hook-父子类循环问题" class="headerlink" title="hook 父子类循环问题"></a>hook 父子类循环问题</h3><p>假设我们现在对UIView、UIButton都Hook了initWithFrame:这个方法，在调用[[UIView alloc] initWithFrame:]和[[UIButton alloc] initWithFrame:]都会定向到C函数qhd_forwardInvocation中，在UIView调用的时候没问题。但是在UIButton调用的时候，由于其内部实现获取了super initWithFrame:，就产生了循环定向的问题。</p>
<p>objc_msgsend(super…) 其实还是子类的self</p>
<p>父类调用 - (void)forwardInvocation:(NSInvocation *)anInvocation; 中的隐藏参数self  也是 其实是子类啊… emmm …</p>
<p>这就导致了循环…</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/01/15/Aspects-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" data-id="ck3g0y6ye0001qy369guqhzqj" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
    
<ul id="article-nav" class="nav nav-pills nav-justified">
  
  
  <li role="presentation">
    <a href="/2017/01/24/iOS-Core-Animation%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/" id="article-nav-newer" class="article-nav-link-wrap">
      <span class="article-nav-link-title">iOS Core Animation性能调优 笔记</span>
      <i class="fa fa-chevron-right pull-right"></i>
    </a>
  </li>
  
</ul>


  
</article>




        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          
  <div class="sidebar-module sidebar-module-inset">
  <h4>About</h4>
  <p>手淘架构组招人 jimu.xjy@alibaba-inc.com</p>

</div>


  
  <div class="sidebar-module">
    <h4>Categories</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/APM/">APM</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Hook/">Hook</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/iOS/">iOS</a><span class="sidebar-module-list-count">7</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/%E7%A0%94%E5%8F%91%E6%B5%81%E7%A8%8B/">研发流程</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/">设计架构</a><span class="sidebar-module-list-count">3</span></li></ul>
  </div>



  


  

  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/10/">October 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/09/">September 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/09/">September 2018</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/06/">June 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/05/">May 2018</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/04/">April 2018</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/01/">January 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/12/">December 2017</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/11/">November 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/10/">October 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/09/">September 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/05/">May 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/04/">April 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/02/">February 2017</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/01/">January 2017</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Recents</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/2019/10/05/cocoapodsdev/">CocoaPods插件开发原理(一) CocoaPods做了啥</a>
        </li>
      
        <li>
          <a href="/2019/09/28/CrashMonitorSystem/">崩溃捕获系统的原理（一）异常信号</a>
        </li>
      
        <li>
          <a href="/2018/09/30/dwarf%E5%92%8C%E7%AC%A6%E5%8F%B7%E5%8C%96/">DWARF和符号化</a>
        </li>
      
        <li>
          <a href="/2018/09/16/CrashSymbolicateSystemDesign/">APM Crash系统</a>
        </li>
      
        <li>
          <a href="/2018/06/13/libmalloc/">libmalloc &#34;malloc&#34; 探究</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2019 junyixie<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  

<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>



<script src="/js/script.js"></script>

</body>
</html>
