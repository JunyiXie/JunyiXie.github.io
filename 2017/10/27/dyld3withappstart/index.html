<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>链接和App启动速度优化 | xiejunyi Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="最近看了链接相关的知识，结合 WWDC 2篇Session 和 iOS 启动优化 做一下总结. 1 链接相关的基础知识1.1 从main.c到一个可执行目标文件我们的源程序main.c 经过C预处理器 翻译成一个ASCII中间文件 main.i,接下来 驱动程序运行C编译器，它将main.i翻译成一个ASCII汇编语言文件main.s,然后驱动程序运行汇编器，它讲main.s翻译成一个可重定位目标">
<meta property="og:type" content="article">
<meta property="og:title" content="链接和App启动速度优化">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2017&#x2F;10&#x2F;27&#x2F;dyld3withappstart&#x2F;index.html">
<meta property="og:site_name" content="xiejunyi Blog">
<meta property="og:description" content="最近看了链接相关的知识，结合 WWDC 2篇Session 和 iOS 启动优化 做一下总结. 1 链接相关的基础知识1.1 从main.c到一个可执行目标文件我们的源程序main.c 经过C预处理器 翻译成一个ASCII中间文件 main.i,接下来 驱动程序运行C编译器，它将main.i翻译成一个ASCII汇编语言文件main.s,然后驱动程序运行汇编器，它讲main.s翻译成一个可重定位目标">
<meta property="og:locale" content="en">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2017&#x2F;10&#x2F;27&#x2F;dyld3withappstart&#x2F;idahello">
<meta property="og:updated_time" content="2019-11-25T16:22:21.032Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2017&#x2F;10&#x2F;27&#x2F;dyld3withappstart&#x2F;idahello">
  
    <link rel="alternate" href="/atom.xml" title="xiejunyi Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">xiejunyi Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-dyld3withappstart" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/27/dyld3withappstart/" class="article-date">
  <time datetime="2017-10-27T12:25:33.000Z" itemprop="datePublished">2017-10-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      链接和App启动速度优化
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近看了链接相关的知识，结合 WWDC 2篇Session 和 iOS 启动优化 做一下总结.</p>
<h2 id="1-链接相关的基础知识"><a href="#1-链接相关的基础知识" class="headerlink" title="1 链接相关的基础知识"></a>1 链接相关的基础知识</h2><h3 id="1-1-从main-c到一个可执行目标文件"><a href="#1-1-从main-c到一个可执行目标文件" class="headerlink" title="1.1 从main.c到一个可执行目标文件"></a>1.1 从main.c到一个可执行目标文件</h3><p>我们的源程序main.c 经过C预处理器 翻译成一个ASCII中间文件 main.i,接下来 驱动程序运行C编译器，它将main.i翻译成一个ASCII汇编语言文件main.s,然后驱动程序运行汇编器，它讲main.s翻译成一个可重定位目标文件main.o,链接器程序将main.o和一些必要的系统目标文件组合起来,创建一个可执行目标文件。在运行时,main.o还可以和一些共享目标文件链接。</p>
<p><strong>预处理</strong></p>
<p>在该阶段，编译器将上述代码中的stdio.h编译进来，并且用户可以使用gcc的选项”-E”进行查看，该选项的作用是让gcc在预处理结束后停止编译过程。预处理阶段主要处理#include和#define，它把</p>
<ol>
<li>#include包含进来的.h 文件插入到#include所在的位置</li>
<li>把源程序中使用到的用#define定义的宏用实际的字符串代替</li>
</ol>
<p>hello.c</p>
<p><code>gcc -E hello.c -o hello.i</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Hello world!\n"</span>);  </span><br><span class="line">  </span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/JunyiXie/JunyiXie.github.io/blob/master/2017/10/27/dyld3withappstart/demo/hello.i" target="_blank" rel="noopener">hello.i</a></p>
<p><strong>编译阶段</strong></p>
<p>接下来进行的是编译阶段，在这个阶段中，Gcc首先要检查代码的规范性、是否有语法错误等，以确定代码的实际要做的工作，在检查无误后，Gcc把代码翻译成汇编语言。用户可以使用”-S”选项来进行查看，该选项只进行编译而不进行汇编，生成汇编代码。</p>
<p><code>gcc -S hello.c -o hello.s</code></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">	.section</span>	__TEXT,__text,regular,pure_instructions</span><br><span class="line"><span class="meta">	.macosx_version_min</span> <span class="number">10</span>, <span class="number">12</span></span><br><span class="line"><span class="meta">	.globl</span>	_main</span><br><span class="line"><span class="meta">	.p2align</span>	<span class="number">4</span>, <span class="number">0x90</span></span><br><span class="line"><span class="symbol">_main:</span>                                  ## @main</span><br><span class="line"><span class="meta">	.cfi_startproc</span></span><br><span class="line">## BB#<span class="number">0</span>:</span><br><span class="line">	pushq	%rbp</span><br><span class="line"><span class="symbol">Lcfi0:</span></span><br><span class="line"><span class="meta">	.cfi_def_cfa_offset</span> <span class="number">16</span></span><br><span class="line"><span class="symbol">Lcfi1:</span></span><br><span class="line"><span class="meta">	.cfi_offset</span> %rbp, -<span class="number">16</span></span><br><span class="line">	<span class="keyword">movq</span>	%rsp, %rbp</span><br><span class="line"><span class="symbol">Lcfi2:</span></span><br><span class="line"><span class="meta">	.cfi_def_cfa_register</span> %rbp</span><br><span class="line">	subq	<span class="number">$16</span>, %rsp</span><br><span class="line">	leaq	L_<span class="number">.</span><span class="keyword">str</span>(%rip), %rdi</span><br><span class="line">	movl	<span class="number">$0</span>, -<span class="number">4</span>(%rbp)</span><br><span class="line">	movb	<span class="number">$0</span>, %al</span><br><span class="line">	callq	_printf</span><br><span class="line">	xorl	%ecx, %ecx</span><br><span class="line">	movl	%eax, -<span class="number">8</span>(%rbp)          ## <span class="number">4</span>-<span class="built_in">byte</span> Spill</span><br><span class="line">	movl	%ecx, %eax</span><br><span class="line">	addq	<span class="number">$16</span>, %rsp</span><br><span class="line">	popq	%rbp</span><br><span class="line">	retq</span><br><span class="line"><span class="meta">	.cfi_endproc</span></span><br><span class="line"></span><br><span class="line"><span class="meta">	.section</span>	__TEXT,__cstring,cstring_literals</span><br><span class="line"><span class="symbol">L_.str:</span>                                 ## @.str</span><br><span class="line"><span class="meta">	.asciz</span>	<span class="string">"Hello world! \n"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">.subsections_via_symbols</span></span><br></pre></td></tr></table></figure>

<p><strong>汇编阶段</strong></p>
<p>汇编阶段把<code>.s</code>文件翻译成二进制机器指令文件<code>.o</code>，如命令gcc -c hello.s -o hello.o，其中-c告诉gcc进行汇编处理。这步生成的文件是二进制文件，直接用文本工具打开看到的将是乱码，我们需要反汇编工具如IDA的帮助才能读懂它</p>
<p><img src="idahello" alt="IDAhello.s"></p>
<p><strong>链接阶段</strong></p>
<p>在编译之后，就进入到了链接阶段。我们<code>hello.c</code> 中是没有定义<code>printf</code>的。我们需要把<code>hello.o</code>中的<code>printf</code>符号和它的定义相关联，重定位hello.o和相关的模块，生成一个可执行目标文件.此时我们的<code>printf</code>符号就能正常调用了.</p>
<p>链接使用<code>ld</code>工具.如果没有特别的指定,gcc会到系统默认的搜索路径<code>/usr/lib</code>下进行查找,找到合适的函数库，进行链接.</p>
<p><code>gcc hello.o -o hello.out</code> 生成可执行文件</p>
<p><code>./hello.out</code> 运行可执行文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello world!</span><br></pre></td></tr></table></figure>


<h3 id="1-2-链接的分类"><a href="#1-2-链接的分类" class="headerlink" title="1.2 链接的分类"></a>1.2 链接的分类</h3><ol>
<li>静态链接</li>
<li>动态链接</li>
</ol>
<p><strong>静态链接</strong><br>像Linux LD程序这样的静态链接器以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的，可以加载和运行的可执行目标文件为输出。</p>
<p><strong>动态链接</strong><br>共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链接.由一个叫做动态链接器的程序来执行的。</p>
<h3 id="1-3-链接的任务"><a href="#1-3-链接的任务" class="headerlink" title="1.3 链接的任务"></a>1.3 链接的任务</h3><ol>
<li><p>符号解析<br>目标文件定义和引用符号，符号解析的目的是将每个符号引用正好和一个符号定义关联起来</p>
</li>
<li><p>重定位<br>编译器和链接器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，是他们指向这个内存位置。</p>
</li>
</ol>
<p><strong>可重定位目标文件</strong></p>
<p>链接器是以可重定位目标文件作为输入的，要想理解链接的过程，首先应该了解可重定位目标文件。</p>
<table>
<thead>
<tr>
<th>setion</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>ELF头</td>
<td>系统的字的大小，字节顺序，ELF头的大小，目标文件的类型，机器类型，节头部表的文件偏移，节头部表中条目的大小和数量</td>
</tr>
<tr>
<td>.text</td>
<td>已编译程序的机器代码</td>
</tr>
<tr>
<td>.rodata</td>
<td>只读数据</td>
</tr>
<tr>
<td>.data</td>
<td>已初始化的全局和静态C变量</td>
</tr>
<tr>
<td>.bss</td>
<td>未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量</td>
</tr>
<tr>
<td>.symtab</td>
<td>一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。</td>
</tr>
<tr>
<td>.rel.text</td>
<td>重定位条目，一个.text节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这个位置。</td>
</tr>
<tr>
<td>.rel.data</td>
<td>重定位条目，被模块引用或定义的所有全局变量的重定位信息。</td>
</tr>
<tr>
<td>.debug</td>
<td>一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的C源文件。</td>
</tr>
<tr>
<td>.line</td>
<td>原始C源程序中的行号和.text节中机器指令间的映射。</td>
</tr>
<tr>
<td>.strtab</td>
<td>一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。字符串表就是以null结尾的字符串的序列。</td>
</tr>
<tr>
<td>节头目表</td>
<td>不同节的位置和大小。</td>
</tr>
</tbody></table>
<p>我们在链接中做的工作主要是：<br>符号解析<code>.text</code>,<code>.data</code>段的符号引用，重定位目标文件。</p>
<p><strong>符号和符号表</strong></p>
<p>在我们的一个可重定位目标模块中，通常会使用在当前模块和其他模块中定义的函数和全局变量，我们称之为符号。每个可重定位目标模块都有一个符号表，它包含m定义和引用符号的信息。</p>
<p><strong>ELF符号表条目</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> name;</span><br><span class="line">    <span class="keyword">char</span> type:<span class="number">4</span>,binding:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">char</span> reserved;<span class="comment">//没用</span></span><br><span class="line">    <span class="keyword">short</span> section;</span><br><span class="line">    <span class="keyword">long</span> value;</span><br><span class="line">    <span class="keyword">long</span> <span class="built_in">size</span>;</span><br><span class="line">&#125;Elf64_Symbol;</span><br></pre></td></tr></table></figure>

<ul>
<li>Name: 字符串表中的字节偏移</li>
<li>Value:符号的地址</li>
<li>Size:目标的大小</li>
<li>Type:函数或者是数据</li>
<li>Bingding:符号是本地的还是全局的</li>
</ul>
<p>使用nm命令我们可以看到：<br><code>$ nm mymalloc.o</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                 U ___real_free</span><br><span class="line">                 U ___real_malloc</span><br><span class="line">0000000000000050 T ___wrap_free</span><br><span class="line">0000000000000000 T ___wrap_malloc</span><br><span class="line">                 U _printf</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">___wrap_free,___wrap_malloc 是已定义的符号，在text段，有相应的内存地址.</span><br><span class="line">___real_free,_printf,___real_malloc 是未定义的符号</span><br></pre></td></tr></table></figure>


<p><strong>符号解析</strong></p>
<p>模块引用了符号，我们需要将符号和一个确定的符号定义关联起来，这样我们的程序才可以正常的执行下去。<br>对于引用和定义在相同模块中的局部符号，符号解析是很简单明了的。<br>但是当编译器遇到不是在当前模块中定义的符号时，只能假设该符号已经在其他模块中定义，生成一个链接器符号表条目，把它交给链接器处理。</p>
<p><strong>重定位</strong></p>
<p>一但链接器完成了符号解析这一步，就把代码中的每个符号引用和正好一个符号定义关联起来（即它的一个输入目标模块中的一个），此时，链接器就知道它的输入目标模块中的代码节和数据节的确切大小。现在就可以开始重定位步骤，在这个步骤中重定位将合并输入模块，并为每个符号分配运行时地址。</p>
<p><strong>重定位由两步组成：</strong></p>
<ol>
<li>重定位节和符号定义 <ul>
<li>链接器将所有相同类型的节合并为同一类型的新的聚合节。</li>
<li>链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成后，程序中的每条指令和全局变量都有唯一的运行时内存地址了。</li>
</ul>
</li>
<li>重定位节中的符号引用<ul>
<li>链接器依赖可重定位条目的数据结构，修改代码节和数据节中对每个符号的引用，使它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目标模块中成为可重定位条目的数据结构。</li>
</ul>
</li>
</ol>
<p><strong>可重定位条目</strong></p>
<p>当汇编器生成一个目标模块时，它并不知道数据和代码最终放在内存中的什么位置。他也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。所以，无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。</p>
<p>代码的可重定位条目在<code>.rel.text</code>节中，已初始化数据的重定位条目放在<code>.rel.data</code>中.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">long</span> offset;<span class="comment">// 需要被修改引用的节偏移</span></span><br><span class="line">	<span class="keyword">long</span> type:<span class="number">32</span>,symbol:<span class="number">32</span>;<span class="comment">// type:如何修改新的引用,symbol:标示被修改引用应该指向的符号</span></span><br><span class="line">	<span class="keyword">long</span> addend;<span class="comment">// 一些类型的重定位要使用它对被修改引用的值做偏移调整</span></span><br><span class="line">&#125;Elf64_Rela;</span><br></pre></td></tr></table></figure>

<p><strong>两种基本的重定位类型</strong>：</p>
<ol>
<li>PC 相对地址引用 一个PC相对地址就是 距程序计数器(PC)的当前运行值的偏移量</li>
<li>绝对地址引用 </li>
</ol>
<h3 id="1-4-动态链接共享库"><a href="#1-4-动态链接共享库" class="headerlink" title="1.4 动态链接共享库"></a>1.4 动态链接共享库</h3><p>静态库有一些明显的缺点，比如：</p>
<ol>
<li>静态库更新后需要显式地将他们的程序与更新了的库重新链接。</li>
<li>静态库的代码会被复制到每个运行进程的文本段中。</li>
</ol>
<p><strong>共享库，动态链接</strong><br>共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链接.由一个叫做动态链接器的程序来执行的。</p>
<p><strong>共享库的共享方式</strong></p>
<ol>
<li>给定文件系统中一个库只有一个.so文件。</li>
<li>内存中，一个共享库的.text节的一个副本可以被不同的正在运行的进程共享。</li>
</ol>
<p><strong>共享库的链接时机</strong></p>
<ol>
<li>在运行时由动态链接器练链接和加载</li>
<li>在调用程序被加载和开始执行时</li>
<li>根据需要在程序调用 dlopen 库的函数时</li>
</ol>
<p><strong>PIC 借助GOT,PLT实现</strong><br>第一次调用外部函数：<br>    1. 调用外部符号，程序进入相应的PLT条目<br>    2. 把 调用的 ID压入栈后，跳转到PLT[0]<br>    3. PLT[0]通过GOT[1]间接的把动态链接器的一个参数压入栈中，然后通过GOT[2]间接的跳转进动态链接器中。动态链接器使用两个栈条目来确定 外部函数的 远行时为止，用这个地址重写GOT[4],再把控制权传给 函数。</p>
<p>后续再次调用：<br>    1. 控制传递到PLT相应条目<br>    2. 通过相应的GOT条目直接转移控制到 函数</p>
<p>PLT[0]: 特殊条目，它跳转到动态链接器中<br>GOT[0]和GOT[1]包含动态链接器在解析函数地址时会使用的信息。<br>GOT[2]是动态链接器在ld-linux.so模块中的入口点。</p>
<h3 id="1-4-加载可执行目标文件"><a href="#1-4-加载可执行目标文件" class="headerlink" title="1.4 加载可执行目标文件"></a>1.4 加载可执行目标文件</h3><p>加载器将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。</p>
<p><strong>需要注意的是：</strong></p>
<ol>
<li>由于.data段有对齐要求，所以代码段和数据段之间是有间隙的</li>
<li>链接器会使用ASLR技术,每次区域运行时区域的地址都会改变，但是相对地址不会改变。</li>
</ol>
<p><strong>Linux下的加载</strong></p>
<ol>
<li>父shell进程生成一个子进程，它是父进程的一个复制</li>
<li>子进程通过execve系统调用启动加载器</li>
<li>加载器删除子进程现有的虚拟内存段，并创建一组新的代码，数据，堆和栈段</li>
<li>将虚拟地址空间中的页映射到可执行文件的页大小的片（chunk） ，新的代码和数据段被初始化为可执行文件的内容</li>
<li>加载器跳转到_start地址，最终会调用应用程序的main 函数。</li>
</ol>
<p>注意：除了一些头部信息，在加载过程中没有任何从磁盘到内存的数据复制。直到CPU引用一个被映射的虚拟页时才会进行复制，此时，操作系统利用它的页面调度机制，自动将页面从磁盘传送到内存。</p>
<h2 id="2-Apple-App-Start-And-Dyld"><a href="#2-Apple-App-Start-And-Dyld" class="headerlink" title="2 Apple App Start And Dyld"></a>2 Apple App Start And Dyld</h2><h3 id="2-1-dyld"><a href="#2-1-dyld" class="headerlink" title="2.1 dyld"></a>2.1 dyld</h3><p>当内核完成映射进程的工作后会将名字为dyld的Mach-O文件映射到进程中的随机地址，它将PC寄存器设为dyld的地址并运行.</p>
<p><strong>Fix-ups</strong><br>由于代码签名，我们无法修改<code>__TEXT</code>段的内容,我们可以通过PIC（Position Independent Code）将<code>dyld</code>修改的引用的地址存储到<code>__DATA</code>中. 在Linux中是通过<code>GOT(Global Offset Table)</code>和<code>PLT(Procedure Linkage Table)</code>实现的.</p>
<p><strong>dyld的时间线：</strong><br>Load dylibs -&gt; Rebase -&gt; Bind -&gt; ObjC -&gt; Initalizers</p>
<p><strong>Load</strong></p>
<ul>
<li>Load dylibs:dylibs映射到内存上。</li>
</ul>
<p><strong>Rebase和Binding</strong></p>
<p>Rebase：在镜像内部调整指针的指向. Binding：将指针指向镜像外部的内容</p>
<ul>
<li>Rebase和Binding:使用PIC技术重定位<code>__DATA</code>中对应<code>__TEXT</code>中符号的指针</li>
</ul>
<p>可以通过命令行查看 rebase 和 bind 相关的资源指针：<br><code>xcrun dyldinfo -rebase -bind -lazy_bind xxx.app/xxx</code><br>诸如此类的输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__DATA  __la_symbol_ptr  0x1000341C8 0x04C3 libobjc          _objc_setAssociatedObject</span><br><span class="line">__DATA  __la_symbol_ptr  0x1000341D0 0x04E4 libobjc          _objc_setProperty_nonatomic_copy</span><br><span class="line">__DATA  __la_symbol_ptr  0x1000341D8 0x050C libobjc          _objc_storeStrong</span><br><span class="line">__DATA  __la_symbol_ptr  0x1000341E0 0x0525 libobjc          _objc_storeWeak</span><br><span class="line">__DATA  __la_symbol_ptr  0x1000341E8 0x053C libobjc          _objc_unsafeClaimAutoreleasedReturnValue</span><br><span class="line">__DATA  __la_symbol_ptr  0x1000341F0 0x056C libSystem        _pow</span><br><span class="line">__DATA  __la_symbol_ptr  0x1000341F8 0x0578 libSystem        _sin</span><br><span class="line">__DATA  __la_symbol_ptr  0x100034200 0x0584 libSystem        _sinf</span><br><span class="line">__DATA  __la_symbol_ptr  0x100034208 0x0591 libswiftCore     _swift_getObjCClassMetadata</span><br><span class="line">__DATA  __la_symbol_ptr  0x100034210 0x05B4 libswiftCore     _swift_getObjectType</span><br><span class="line">__DATA  __la_symbol_ptr  0x100034218 0x05D0 libswiftCore     _swift_unknownRelease</span><br><span class="line">__DATA  __la_symbol_ptr  0x100034220 0x05ED libswiftCore     _swift_unknownRetain</span><br></pre></td></tr></table></figure>





<p><strong>ObjC Runtime</strong></p>
<ul>
<li>ObjC  数据结构中有class DATA structure 有很多指针，例如指向 methods 和 super 的指针。这些指针的Fixed-up是通过 rebasing 和 binding.可以说我们类中method_list中的很多信息都是通过 Fix-ups 来维护的</li>
<li>因为Objc的动态性,Objc 可以通过类名来实例化对象, 这意味着 ObjC runtime 需要维护 一张哈希表，负责<code>class name</code>和<code>class</code>的映射.因此当你加载dylib的时候，dylib中定义的类都会被注册到表中。</li>
<li>更新类定义 没有C++中易碎的基类问题，因为 Fix-ups已经更新了<code>__DATA</code> 因此类中ivar相对于类实例起始地址的offset也被更新了.</li>
<li>ObjC 可以定义类别，类别可以改变 类的方法,但是 类别的定义可能和类不在同一个 image 中，在加载过程中，也需要做Fix-up,修复方法的指针. 将category中的method 加到class method_list 的前面，这样我们 在OC 运行时顺序查找方法表，先找的是 category 定义的方法.</li>
<li>ObjC 的 selector 是唯一的</li>
</ul>
<p><strong>Initializers</strong></p>
<ul>
<li>C++ 为静态创建的对象生成初始化器</li>
<li>Objc <code>+load</code> 方法，已经废弃,建议使用 <code>+initialize</code></li>
</ul>
<h3 id="2-2-启动调用顺序"><a href="#2-2-启动调用顺序" class="headerlink" title="2.2 启动调用顺序"></a>2.2 启动调用顺序</h3><p>initialize -&gt; dyld -&gt; main() -&gt; UIApplicationMain()</p>
<h2 id="3-dyld3"><a href="#3-dyld3" class="headerlink" title="3 dyld3"></a>3 dyld3</h2><p>在WWDC 2017 上，苹果宣布已经使用 dyld3 来作为系统app的动态链接器</p>
<p><strong>dyld3可以分成三个部分</strong></p>
<ol>
<li>一个进程外的 mach-o 分析器和编译器 处理可能影响启动速度的searchpath @rpaths 和 环境变量，解析mach-o二进制文件，完成符号解析的工作.</li>
<li>一个进程内的引擎 执行启动收尾处理 验证启动收尾，映射动态链接库</li>
<li>一个启动收尾缓存服务  系统程序收尾被直接加入到共享缓存，使用这个工具在系统中运行和分析每个mach-o文件，将它们放入共享缓存，使它映射到缓存中，所有dylib都使用它来启动. 对于第三方程序，在程序安装或系统更新时，生成启动收尾处理（因为系统库那时已经发生更改）</li>
</ol>
<p><strong>为什么启动收尾可以提高启动速度?</strong><br>通过启动收尾，缓存了 符号相对于库中的偏移位置， 这就避免了以后启动程序进程再次进行符号链接的时间消耗。直接从磁盘读取缓存的启动收尾，验证是否正确即可.</p>
<h2 id="4-优化方案"><a href="#4-优化方案" class="headerlink" title="4 优化方案"></a>4 优化方案</h2><p>App 的启动时间: dylib和App可执行文件的加载时间 + - (BOOL)Application:(UIApplication *)Application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions执行时间.</p>
<p><strong>加载images</strong></p>
<ul>
<li>使用更少的非系统dylibs 合并多个dylibs 使用静态库</li>
</ul>
<p><strong>Rebase/Binding</strong></p>
<ul>
<li>减少Objc 类数量，减少selector数量，减少C++虚函数数量，使用Swift struct</li>
</ul>
<p><strong>Initializer</strong><br>Explict Initializer</p>
<ul>
<li>使用 <code>+initialize</code> 而不是 <code>+load</code></li>
<li>不要使用 <strong>atribute</strong>((constructor)) 将方法显式标记为初始化器,而是让初始化方法调用时才执行.可以使用 <code>dispatch_once()</code>,<code>pthread_once()</code>,<code>std::once()</code></li>
</ul>
<p>Implict Initializer</p>
<ul>
<li>在调用的地方使用初始化器</li>
<li>只用简单值类型赋值（POD:Plain Old Data），这样静态链接器会预先计算 __DATA 中的数据，无需再进行 fix-up 工作</li>
<li>使用编译器 warning 标志 -Wglobal-constructors 来发现隐式初始化代码。</li>
<li>苹果还建议更多使用 Swift。Swift 在设计上能避免很多 C、C++ 和 OC 的陷阱；Swift 没有初始化过程；Swift 也不允许不对齐的结构体。这些都对启动时间的优化有一定帮助</li>
</ul>
<h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5 参考"></a>5 参考</h2><blockquote>
<p><a href="https://developer.apple.com/videos/play/wwdc2017/413/" target="_blank" rel="noopener">2017 WWDC Session 413</a></p>
</blockquote>
<blockquote>
<p><a href="https://developer.apple.com/videos/play/wwdc2016/406/" target="_blank" rel="noopener">2016 WWDC Session 406</a></p>
</blockquote>
<blockquote>
<p>《深入理解计算机系统》</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/27/dyld3withappstart/" data-id="ck6umce5v000khfjgca5geqbi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/12/04/safeSwizzleRSSwizzleAnalyze/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Method Swizzling 的正确途径
        
      </div>
    </a>
  
  
    <a href="/2017/09/26/%E7%90%86%E8%A7%A3HTTPS/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">理解HTTPS</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/APM/">APM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hook/">Hook</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A0%94%E5%8F%91%E6%B5%81%E7%A8%8B/">研发流程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/">设计架构</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/02/19/crashruntimeinfo/">Block ABI 文档阅读</a>
          </li>
        
          <li>
            <a href="/2020/02/12/iosdevdebug/">iOS开发必备的问题定位调试技巧</a>
          </li>
        
          <li>
            <a href="/2019/11/26/projectpodenv/">CocoaPods插件开发原理(二) 定制项目CocoaPods插件环境</a>
          </li>
        
          <li>
            <a href="/2019/10/05/cocoapodsdev/">CocoaPods插件开发原理(一) CocoaPods做了啥</a>
          </li>
        
          <li>
            <a href="/2019/09/28/CrashMonitorSystem/">崩溃捕获系统的原理（一）异常信号</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 junyixie<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>