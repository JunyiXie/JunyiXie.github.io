<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>关于架构和编码的思考 | xiejunyi Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="长期更新，记录我对设计架构的理解 控制反转A,B,C三个组件，如果可以互相调用，则ABC互相依赖。在大型项目中，这种会造成组件间耦合紧密的问题。 思考一下，组件间调用的本质 有组件的实例 接口  拥有组件的实例，我们直接拥有另一个组件，这显然是依赖的。 如何在尽量减少依赖的情况下解决这些问题呢？  可以通过反射的方式, 需要建立 {组件}&amp;lt;-&amp;gt;{字符串} 的映射表，把关系转移到了配置文">
<meta property="og:type" content="article">
<meta property="og:title" content="关于架构和编码的思考">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2018&#x2F;04&#x2F;13&#x2F;dependency&#x2F;index.html">
<meta property="og:site_name" content="xiejunyi Blog">
<meta property="og:description" content="长期更新，记录我对设计架构的理解 控制反转A,B,C三个组件，如果可以互相调用，则ABC互相依赖。在大型项目中，这种会造成组件间耦合紧密的问题。 思考一下，组件间调用的本质 有组件的实例 接口  拥有组件的实例，我们直接拥有另一个组件，这显然是依赖的。 如何在尽量减少依赖的情况下解决这些问题呢？  可以通过反射的方式, 需要建立 {组件}&amp;lt;-&amp;gt;{字符串} 的映射表，把关系转移到了配置文">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2018-05-25T18:05:00.000Z">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="xiejunyi Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">xiejunyi Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-dependency" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/dependency/" class="article-date">
  <time datetime="2018-04-13T05:08:46.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/">设计架构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      关于架构和编码的思考
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>长期更新，记录我对设计架构的理解</strong></p>
<h2 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h2><p>A,B,C三个组件，如果可以互相调用，则ABC互相依赖。在大型项目中，这种会造成组件间耦合紧密的问题。</p>
<h2 id="思考一下，组件间调用的本质"><a href="#思考一下，组件间调用的本质" class="headerlink" title="思考一下，组件间调用的本质"></a>思考一下，组件间调用的本质</h2><ol>
<li>有组件的实例</li>
<li>接口</li>
</ol>
<p><strong>拥有组件的实例</strong>，我们直接拥有另一个组件，这显然是依赖的。</p>
<p><strong>如何在尽量减少依赖的情况下解决这些问题呢？</strong></p>
<ol>
<li>可以通过反射的方式, 需要建立 {组件}&lt;-&gt;{字符串} 的映射表，把关系转移到了配置文件中，这种方式存在安全性问题，因为没有编译器的强类型检查。</li>
<li>建立映射关系。我们可以 建立Class和某种物件的映射， 因为有protocol的存在，接口的问题被解决了。于是建立Class和Protocol的映射，可以获得实例的同时也知晓接口。这就构成了一个组件调用的基础条件。并且我们需要一个manager替我们管理映射。</li>
</ol>
<p>在2中，依赖关系变成了如下<br>{组件}-&gt;{manager}-&gt;{interface}</p>
<p>组件的耦合转移到了组件和interface的耦合。这在工程维护中存在一个问题，我们需要维护一个庞大的protocol列表。不过相比于组件间相互依赖，这种做法好了很多。</p>
<h3 id="接口类映射-和-反射-的选择"><a href="#接口类映射-和-反射-的选择" class="headerlink" title="接口类映射 和 反射 的选择"></a>接口类映射 和 反射 的选择</h3><p>我个人愿意维护protocols，而不是维护组件字符串映射表。 从逻辑上说，无法实现双方相互隐藏。这无非是 “关系” 的体现方式不同。我选择程序内的映射关系，有编译器检查。</p>
<h2 id="依赖倒置"><a href="#依赖倒置" class="headerlink" title="依赖倒置"></a>依赖倒置</h2><p>传统的过程性系统的设计方法倾向于使高层次的模块依赖于低层次的模块，抽象层次依赖于具体层次。<br>而依赖倒置则将{高层次模块，低层次模块}-&gt;{抽象接口}，这样无论上层还是下层的整个模块出现了替换，只要接口不变化，就不需要修改另一层次的模块。</p>
<p><strong>这里值得注意的是，低层次模块依赖了高层次模块中定义的接口。当我们把低层次模块拆分后，将其用于别的项目时，会出现问题。对此我的想法是：</strong></p>
<ol>
<li>如果高层次模块需要和底层次模块完全隔离，方便的替换整个低层次模块的实现，那么使用依赖倒置。</li>
<li>如果没有1中的需求，那么还是直接依赖低层次模块，我认为低层次模块本身的接口暴露合理，内部实现的改动也不会对高层次模块有什么影响。</li>
</ol>
<h3 id="采用接口的成本"><a href="#采用接口的成本" class="headerlink" title="采用接口的成本"></a>采用接口的成本</h3><ol>
<li>接口定义，接口维护，遵循类维护</li>
<li>如果暴露了一些定义的数据结构、类，则这些也需要抽象。会造成很多重复的代码。<br>我觉得还是尽量只在必要情况下使用接口，</li>
</ol>
<ul>
<li>足够底层的类，可以放到核心库中。让所有模块都依赖呗。</li>
<li>接口适用于 同级别模块间的服务交互</li>
</ul>
<h3 id="包装一下"><a href="#包装一下" class="headerlink" title="包装一下"></a>包装一下</h3><p>我们使用高层模块时，其实就是构造一个符合接口的东西而已。<br>底层模块A去遵循高层模块的协议，无疑让底层模块无法复用。这时候我们可以再新建一个类C，让C去遵循协议，C通过A来构建自己。</p>
<h2 id="单一职责和关注点分离原则"><a href="#单一职责和关注点分离原则" class="headerlink" title="单一职责和关注点分离原则"></a>单一职责和关注点分离原则</h2><p><strong>关注点分离</strong>要求每一个功能对应一个单独的任务，每一个功能都要在一个独立的模块中实现。每个模块都有自己的职责，而不会关注其他模块的职责。如果一个类包含多个职责，要求改其中的一个职责，则可能会影响该类里其他职责的实现。<br><strong>单一职责原则</strong>要求每个类只包含一个职责，所有方法都应该为了实现该职责。要修改一个类的职责，只涉及该类。</p>
<h3 id="例子：Record和Log写在一起？"><a href="#例子：Record和Log写在一起？" class="headerlink" title="例子：Record和Log写在一起？"></a>例子：Record和Log写在一起？</h3><p>场景：Record模块，存储了Crash的信息。我们需要生成某种格式的日志。Record把生成日志的代码通过分类实现。<br>这里通过category的实现，方便，不会引入单独的类。把格式化生成log的职责放在了record模块里。但是Log是个改动频繁的功能，兼具有相当多的扩展性(多种格式..)。仅是log当做Record的一个功能，职责和灵活性都说不过去。Record应<strong>仅关注信息的记录</strong>。把Log当做另一个同等级模块来看待。</p>
<p>做法1：把Log和Record拆分为同等级的模块，Log模块依赖于Record,生成相应的日志。<br>这里纠正一个错误，有同学说，既然存在依赖，那就用分类好了不需要拆分。<strong>模块拆分和依赖无关，关注的是职责分离和粒度控制，是通过现在情况和未来发展做出的判断。</strong></p>
<p><strong>从框架开发的角度来看</strong>，Record和Log都是独立的模块，不能互相依赖。Log模块需要元数据，我们可以定义Info协议，Log依赖Info协议。当需要生成log时，我们构造一个遵循Info协议的类RecordInfo，给Log使用即可。多了一层中间层，但是把 Record和Log隔离出来，两者都可以复用。 <strong>维护成本由 Log和Record 的使用者承担。</strong>这是做的很干净的写法，适用于需要复用的情况，如果仅仅把Log用在固定的场景，那么直接依赖元数据类也是可以的。</p>
<h2 id="策略控制"><a href="#策略控制" class="headerlink" title="策略控制"></a>策略控制</h2><p>现在对于 某个功能 有一个实现A， 此时，在A的实现的基础上出现了另一种分支，达到B的效果。</p>
<p>在A的代码中，修改逻辑是常用的做法，借此实现AB功能。<br>但这样破坏了原有的功能，使得逻辑日渐复杂。我认为相对合理的做法是，将AB的共同逻辑抽取，差异逻辑分开。如果实现代码很多，可以拆分成两个策略类。关于<code>func</code>还是<code>strategy class</code>可以根据代码量和复杂程度来权衡。</p>
<p>软件开发中是无法避免依赖的，我们可以把相关的逻辑放在类中，也可以放在函数中。我认为这本质上是一样的。粒度是开发过程中需要考虑的问题。合理的设计出最适用用与当下的框架，不过度设计。要知道我们无法从根本上改变软件逐渐增大的复杂度，我们能做的是改变自己的编码方式，将逻辑写的合理清晰就好了。</p>
<h2 id="创建模式的思考"><a href="#创建模式的思考" class="headerlink" title="创建模式的思考"></a>创建模式的思考</h2><ol>
<li>工厂模式 生产一类物品</li>
<li>抽象工厂模式 生产多类物品</li>
<li>生成器模式 构造复杂的产品</li>
</ol>
<p>工厂模式将实现代码与暴露的接口隔离。抽象工厂模式在工厂模式的基础上将多种工厂的能力统一暴露。生成器模式关注于复杂对象的步骤生成。</p>
<p>创建模式都将实现与产品隔离。生成器模式相较于抽象工厂模式，在对象的生成中更加细化，将生成的对象各个步骤隔离，各个步骤可以组合。而抽象工厂模式适用于简单的对象生成。</p>
<p><strong>我认为，本质上，创建者模式，通过依赖注入，以统一的接口分发不同的实现。可以根据实际情况，根据复杂度选择合适的做法。</strong></p>
<h2 id="契约式设计"><a href="#契约式设计" class="headerlink" title="契约式设计"></a>契约式设计</h2><p>DbC的核心思想是对软件系统中的元素之间相互合作以及“责任”与“义务”的比喻。这种比喻从商业活动中“客户”与“供应商”达成“契约”而得来。例如：</p>
<ul>
<li>供应商必须提供某种产品（责任），并且他有权期望客户已经付款（权利）。</li>
<li>客户必须付款（责任），并且有权得到产品（权利）。</li>
<li>契约双方必须履行那些对所有契约都有效的责任，如法律和规定等。</li>
</ul>
<p>同样的，如果在面向对象程序设计中一个类的函数提供了某种功能，那么它要：</p>
<ul>
<li>期望所有调用它的客户模块都保证一定的进入条件：这就是函数的先验条件—客户的义务和供应商的权利，这样它就不用去处理不满足先验条件的情况。</li>
<li>保证退出时给出特定的属性：这就是函数的后验条件—供应商的义务，显然也是客户的权利。</li>
<li>在进入时假定，并在退出时保持一些特定的属性：不变条件。</li>
</ul>
<h3 id="调用方和被调用方相互负责的看法"><a href="#调用方和被调用方相互负责的看法" class="headerlink" title="调用方和被调用方相互负责的看法"></a>调用方和被调用方相互负责的看法</h3><p>在写code中经常会遇到 不知道一些guard 条件到底写在哪好。<br>写在调用方，逻辑清晰一些。写在被调用方，可以减少代码冗余。</p>
<p>我个人觉得这样的写法比较合适:</p>
<ol>
<li>调用者体内会被改变的状态，在调用者做校验。</li>
<li>被调用者处理上下文的一些信息。</li>
<li>当被调用者的guard逻辑重复多次，考虑将判断逻辑抽象成函数。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/13/dependency/" data-id="ck8hkauum000potjh3zzd7s2i" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/06/13/libmalloc/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          libmalloc &#34;malloc&#34; 探究
        
      </div>
    </a>
  
  
    <a href="/2018/04/10/iosoom/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">iOS OOM</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/APM/">APM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hook/">Hook</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A0%94%E5%8F%91%E6%B5%81%E7%A8%8B/">研发流程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/">设计架构</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/04/01/MachOObjC/">MachO（一） ObjC类结构的加载</a>
          </li>
        
          <li>
            <a href="/2020/03/25/DobbyRead/">Dobby源码学习（一） Inline Hook</a>
          </li>
        
          <li>
            <a href="/2020/03/19/cocoapods-new-feature/">cocoapods 新feature 开发 Example, On Demand Resource</a>
          </li>
        
          <li>
            <a href="/2020/03/04/lazybind/">dyld(2) lazy bind 和 dyld_stub_binder</a>
          </li>
        
          <li>
            <a href="/2020/03/03/macholinkedit/">dyld(1) MachO Linkedit 段</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 junyixie<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>