<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>xiejunyi Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="xiejunyi Blog">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="xiejunyi Blog">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="xiejunyi Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">xiejunyi Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-iosdevdebug" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/12/iosdevdebug/" class="article-date">
  <time datetime="2020-02-12T07:48:35.000Z" itemprop="datePublished">2020-02-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/12/iosdevdebug/">iOS开发必备的问题定位调试技巧</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>好久没写科普文..</p>
<p>在iOS开发的过程中难免遇到各种问题，本文将结合作者这么多年（其实也没几年）的擦屁股和挖坑经验，总结一套调试方法，让你在遇到问题时不盲目，有切入点，可以自己一步一步分析去解决问题。</p>
<ol>
<li>逻辑问题调试</li>
<li>崩溃问题调试</li>
<li>内存问题调试</li>
</ol>
<h2 id="逻辑问题调试"><a href="#逻辑问题调试" class="headerlink" title="逻辑问题调试"></a>逻辑问题调试</h2><p>在阅读一份完全不熟悉的代码时，不知道从何入手，如何找到自己感兴趣的部分。这里介绍几个手段定位到你感兴趣的点：</p>
<h3 id="关键字搜索"><a href="#关键字搜索" class="headerlink" title="关键字搜索"></a>关键字搜索</h3><p>ripgrep <a href="https://github.com/BurntSushi/ripgrep" target="_blank" rel="noopener">https://github.com/BurntSushi/ripgrep</a> 这个工具，可以通过关键字快速过滤出你感兴趣的内容。</p>
<p>最近，在解崩溃时遇到 KERN_PROTECTION_FAILURE 这个异常类型，想了解一下在什么情况下会产生。于是直接在xnu源码中搜索, 就可以快速定位到错误产生的相关代码，了解其原理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">$ rg -C <span class="number">10</span> <span class="string">" = KERN_PROTECTION_FAILURE"</span></span><br><span class="line">bsd/vm/vm_unix.c</span><br><span class="line"><span class="number">859</span>-	task = p-&gt;task;</span><br><span class="line"><span class="number">860</span>-	task_reference(task);</span><br><span class="line"><span class="number">861</span>-</span><br><span class="line"><span class="number">862</span>-	<span class="comment">/* If we aren't root and target's task access port is set... */</span></span><br><span class="line"><span class="number">863</span>-	<span class="keyword">if</span> (!kauth_cred_issuser(kauth_cred_get()) &amp;&amp;</span><br><span class="line"><span class="number">864</span>-		p != current_proc() &amp;&amp;</span><br><span class="line"><span class="number">865</span>-		(task_get_task_access_port(task, &amp;tfpport) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line"><span class="number">866</span>-		(tfpport != IPC_PORT_NULL)) &#123;</span><br><span class="line"><span class="number">867</span>-</span><br><span class="line"><span class="number">868</span>-		<span class="keyword">if</span> (tfpport == IPC_PORT_DEAD) &#123;</span><br><span class="line"><span class="number">869</span>:			error = KERN_PROTECTION_FAILURE;</span><br><span class="line"><span class="number">870</span>-			<span class="keyword">goto</span> tfpout;</span><br><span class="line"><span class="number">871</span>-		&#125;</span><br><span class="line"><span class="number">872</span>-</span><br><span class="line"><span class="number">873</span>-		<span class="comment">/*</span></span><br><span class="line"><span class="comment">874-		 * Drop the proc_find proc ref before making an upcall</span></span><br><span class="line"><span class="comment">875-		 * to taskgated, since holding a proc_find</span></span><br><span class="line"><span class="comment">876-		 * ref while making an upcall can cause deadlock.</span></span><br><span class="line"><span class="comment">877-		 */</span></span><br><span class="line"><span class="number">878</span>-		proc_rele(p);</span><br><span class="line"><span class="number">879</span>-		p = PROC_NULL;</span><br><span class="line"></span><br><span class="line">osfmk/vm/vm_fault.c</span><br><span class="line"><span class="number">3632</span>-	 */</span><br><span class="line"><span class="number">3633</span>-	<span class="keyword">if</span> (fault_type == VM_PROT_READ &amp;&amp;</span><br><span class="line"><span class="number">3634</span>-		(prot &amp; VM_PROT_EXECUTE) &amp;&amp;</span><br><span class="line"><span class="number">3635</span>-		!(prot &amp; VM_PROT_READ) &amp;&amp;</span><br><span class="line"><span class="number">3636</span>-		pmap_enforces_execute_only(pmap)) &#123;</span><br><span class="line"><span class="number">3637</span>-			vm_object_unlock(object);</span><br><span class="line"><span class="number">3638</span>-			vm_map_unlock_read(<span class="built_in">map</span>);</span><br><span class="line"><span class="number">3639</span>-			<span class="keyword">if</span> (real_map != <span class="built_in">map</span>) &#123;</span><br><span class="line"><span class="number">3640</span>-				vm_map_unlock(real_map);</span><br><span class="line"><span class="number">3641</span>-			&#125;</span><br><span class="line"><span class="number">3642</span>:			kr = KERN_PROTECTION_FAILURE;</span><br><span class="line"><span class="number">3643</span>-			<span class="keyword">goto</span> done;</span><br><span class="line"><span class="number">3644</span>-	&#125;</span><br><span class="line"><span class="number">3645</span>-<span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="日志输出内容搜索"><a href="#日志输出内容搜索" class="headerlink" title="日志输出内容搜索"></a>日志输出内容搜索</h3><p>程序运行日志中的输出，很多内容都是写死在代码中的，这个是搜索利器，通过输出，定位到具体的函数。</p>
<p>当使用 otool -Vt 去反编译 text段时，可以看到，otool 可以反编译出 字符串常量的使用。literal pool for: “you”, 一看 “literal pool for:”极有可能存在在代码 printf中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0000000000001fb0	movq	%rsi, -0x10(%rbp)</span><br><span class="line">0000000000001fb4	leaq	0x15(%rip), %rsi ## literal pool for: &quot;you&quot;</span><br><span class="line">0000000000001fbb	movq	%rsi, -0x18(%rbp)</span><br><span class="line">0000000000001fbf	leaq	0xe(%rip), %rsi ## literal pool for: &quot;fuck&quot;</span><br></pre></td></tr></table></figure>

<p>通过该关键字搜索 直接定位到了输出内容的地方。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># xiejunyi @ 192 in ~/cctools-886 on git:master x [16:49:41] </span></span><br><span class="line">$ rg -C <span class="number">10</span> <span class="string">"literal pool for:"</span>         </span><br><span class="line">otool/arm_disasm.c</span><br><span class="line"><span class="number">5250</span>-		   info-&gt;indirect_symbols, info-&gt;nindirect_symbols,</span><br><span class="line"><span class="number">5251</span>-		   info-&gt;symbols, <span class="literal">NULL</span>, info-&gt;nsymbols, info-&gt;strings,</span><br><span class="line"><span class="number">5252</span>-		   info-&gt;strings_size);</span><br><span class="line"><span class="number">5253</span>-	<span class="keyword">if</span>(name != <span class="literal">NULL</span>)</span><br><span class="line"><span class="number">5254</span>-	    <span class="built_in">fprintf</span>(stream, <span class="string">"\t@ symbol stub for: %s"</span>, name);</span><br><span class="line"><span class="number">5255</span>-	<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="number">5256</span>-	    <span class="keyword">uint64_t</span> reference_type;</span><br><span class="line"><span class="number">5257</span>-	    reference_type = LLVMDisassembler_ReferenceType_In_PCrel_Load;</span><br><span class="line"><span class="number">5258</span>-	    name = guess_literal_pointer(addr, pc, &amp;reference_type, info);</span><br><span class="line"><span class="number">5259</span>-	    <span class="keyword">if</span>(name != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="number">5260</span>:		<span class="built_in">fprintf</span>(stream, <span class="string">" literal pool for: "</span>);</span><br><span class="line"><span class="number">5261</span>-		<span class="keyword">if</span>(reference_type ==</span><br><span class="line"><span class="number">5262</span>-		   LLVMDisassembler_ReferenceType_Out_LitPool_CstrAddr)</span><br><span class="line"><span class="number">5263</span>-		    <span class="built_in">fprintf</span>(stream, <span class="string">"\"%s\""</span>, name);</span><br><span class="line"><span class="number">5264</span>-		<span class="keyword">else</span></span><br><span class="line"><span class="number">5265</span>-		    <span class="built_in">fprintf</span>(stream, <span class="string">"%s"</span>, name);</span><br><span class="line"><span class="number">5266</span>-	    &#125;</span><br><span class="line"><span class="number">5267</span>-	&#125;</span><br><span class="line"><span class="number">5268</span>-    &#125;</span><br><span class="line"><span class="number">5269</span>-&#125;</span><br><span class="line"><span class="number">5270</span>-</span><br></pre></td></tr></table></figure>




<h3 id="调试打断点"><a href="#调试打断点" class="headerlink" title="调试打断点"></a>调试打断点</h3><p>通过上面的文本搜索，你可能已经定位到了关键函数。这时，如果你可以对代码进行调试，在目标函数设置断点可以看到调用栈，快速了解代码的执行逻辑。<br>我在分析ld对symboltabl处理时打了几个断点</p>
<img src="/2020/02/12/iosdevdebug/ld_breakpoint.png" class="" title="ld_breakpoint.png">

<p>然后通过调用栈了解相关的程序执行逻辑。<br>main -&gt; 执行ld pass -&gt; 构建序数表 -&gt; 构建nametable</p>
<img src="/2020/02/12/iosdevdebug/ld_callstack.png" class="" title="ld_callstack.png">


<h3 id="通过log"><a href="#通过log" class="headerlink" title="通过log"></a>通过log</h3><p>一般靠谱点的项目中会有各种日志打印，通常需要自行打开。我们在使用一些工具的时候也会打开调试日志进行分析，常见的是通过–verbose选项。<br>在代码中，很容易就可以找到一些打印输入，然后将其开启。通过代码作者的log，我们可以了解代码运行时的一些关键信息。</p>
<p>这是ld64的 printStatistics log </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">           ld total time:  343.4 seconds ( 100.0%)</span><br><span class="line">     option parsing time:    0.2 milliseconds (   0.0%)</span><br><span class="line">  object file processing:    0.0 milliseconds (   0.0%)</span><br><span class="line">         resolve symbols:    5.3 milliseconds (   0.0%)</span><br><span class="line">         build atom list:    0.0 milliseconds (   0.0%)</span><br><span class="line">                 passess:  343.4 seconds (  99.9%)</span><br><span class="line">            write output:    0.7 milliseconds (   0.0%)</span><br><span class="line">pageins=6169353, pageouts=3545, faults=247734135</span><br><span class="line">processed   1 object files,  totaling           2,720 bytes</span><br><span class="line">processed   0 archive files, totaling               0 bytes</span><br><span class="line">processed  35 dylib files</span><br></pre></td></tr></table></figure>

<p>代码中也存在 通过开关打开的log，找到<em>s</em>log的设置入口，打开即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_s_log ) <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"could not order %s as %u because it was already laid out earlier by %s as %u\n"</span>,</span><br><span class="line">                atom-&gt;name(), index, _followOnStarts[atom]-&gt;name(), _ordinalOverrideMap[atom] );</span><br></pre></td></tr></table></figure>



<h2 id="崩溃问题调试"><a href="#崩溃问题调试" class="headerlink" title="崩溃问题调试"></a>崩溃问题调试</h2><h3 id="查看和分析崩溃日志"><a href="#查看和分析崩溃日志" class="headerlink" title="查看和分析崩溃日志"></a>查看和分析崩溃日志</h3><p>程序崩溃时，给开发者解决问题的最主要的信息就是崩溃日志了。<br>iOS系统自带crash捕获和日志生成功能，可以通过xcode查看设备中存储崩溃日志</p>
<img src="/2020/02/12/iosdevdebug/view_iphone_crash.png" class="" title="view_iphone_crash.png">

<p>通过crash日志，可以看到程序崩溃时的现场信息，主要关注调用栈信息和崩溃类型。</p>
<img src="/2020/02/12/iosdevdebug/crashlog.png" class="" title="crashlog.png">

<p>如何分析crashlog就不详细展开了，可以网上搜一搜相关的文章。<br>这里提几个点：</p>
<ol>
<li>反编译代码 通过崩溃函数的汇编代码获取更多的信息（例如：常见的野指针问题我们可以分析出哪个对象野了）</li>
<li>常见崩溃问题的了解，crash watchdog oom 野指针 循环调用导致栈溢出… </li>
</ol>
<h3 id="Xcode中debug程序"><a href="#Xcode中debug程序" class="headerlink" title="Xcode中debug程序"></a>Xcode中debug程序</h3><p>使用 xcode debug 程序时，Xcode的调试器 会自动监听程序的exception端口，当崩溃发生时，xcode会帮我们保留现场。<br>开启Exception BreakPoint</p>
<img src="/2020/02/12/iosdevdebug/open_exception_breakpoint.png" class="" title="open_exception_breakpoint.png">

<p>崩溃时，Xcode会自动定位到崩溃的代码行。</p>
<img src="/2020/02/12/iosdevdebug/exception_crash.png" class="" title="exception_crash.png">


<h2 id="内存问题调试"><a href="#内存问题调试" class="headerlink" title="内存问题调试"></a>内存问题调试</h2><h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><p>iOS开发中常见的内容问题是 循环引用，xcode8引入了memory graph这一神器来分析这类问题。<br>在Xcode下方的工具栏中进入，</p>
<img src="/2020/02/12/iosdevdebug/memory_graph_btn.png" class="" title="memory_graph_btn.png">

<p>如下代码 可以看到 obj1 obj2 循环引用了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@interface TestClass : NSObject</span><br><span class="line">@property (nonatomic, strong) NSMutableArray *array;</span><br><span class="line">@end</span><br><span class="line">@implementation TestClass</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        self.array = @[].mutableCopy;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSMutableArray *array;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    TestClass *obj1 = [TestClass new];</span><br><span class="line">    TestClass *obj2 = [TestClass new];</span><br><span class="line"></span><br><span class="line">    [obj1.array addObject:obj2];</span><br><span class="line">    [obj2.array addObject:obj1];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>通过memory graph 可以直观的看到 </p>
<ol>
<li>对象间的引用关系</li>
<li>对象分配的调用栈（需要打开Malloc Stack）</li>
<li>有内存问题的对象列表</li>
</ol>
<img src="/2020/02/12/iosdevdebug/memory_graph.png" class="" title="memory_graph.png">

<h3 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h3><p>可通过下图两个工具排查</p>
<img src="/2020/02/12/iosdevdebug/memorytools.png" class="" title="memorytools.png">


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/12/iosdevdebug/" data-id="ck6j1eplb000w63jgfe5b5ve5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-projectpodenv" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/26/projectpodenv/" class="article-date">
  <time datetime="2019-11-26T15:41:18.000Z" itemprop="datePublished">2019-11-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%A0%94%E5%8F%91%E6%B5%81%E7%A8%8B/">研发流程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/26/projectpodenv/">CocoaPods插件开发原理(二) 定制项目CocoaPods插件环境</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>CocoaPods是主流的iOS工程依赖管理工具。我们在使用CocoaPods管理工程的过程中，经常面对各种定制化的需求。CocoaPods提供的插件机制可以帮助我们定制CocoaPods。随着插件的增多，管理插件也成为了蛋疼的问题…… 本片文章介绍如何利用Bundler管理项目插件。</p>
<h2 id="Bundler"><a href="#Bundler" class="headerlink" title="Bundler"></a>Bundler</h2><p>Bundler是Ruby的依赖管理工具，通过Gemfile可以指定项目依赖的ruby gems。通过bundle install 进行安装。bundle exec 执行。</p>
<h3 id="Gemfile"><a href="#Gemfile" class="headerlink" title="Gemfile"></a>Gemfile</h3><p>和 podfile 挺像的,可以类比一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 指定了gem源</span><br><span class="line">source &apos;https://rubygems.org&apos; </span><br><span class="line"></span><br><span class="line"># 指定 gem 及其 版本 </span><br><span class="line">gem &apos;nokogiri&apos;</span><br><span class="line">gem &apos;rack&apos;, &apos;~&gt; 2.0.1&apos;</span><br><span class="line">gem &apos;rspec&apos;</span><br></pre></td></tr></table></figure>

<h3 id="bundle-install"><a href="#bundle-install" class="headerlink" title="bundle install"></a>bundle install</h3><p>bundle install 会安装 Gemfile指定的依赖。</p>
<h3 id="bundle-exec"><a href="#bundle-exec" class="headerlink" title="bundle exec"></a>bundle exec</h3><p>bundle exec 将会在 bundle install 依赖安装后的环境中执行 命令。</p>
<blockquote>
<p>This command executes the command, making all gems specified in the Gemfile(5) available to require in Ruby programs.</p>
</blockquote>
<p><strong>上面巴拉巴拉说了一堆，总之就是</strong></p>
<ol>
<li>把依赖写进 Gemfile 里</li>
<li>bundle install 安装依赖</li>
<li>bundle exec 在安装依赖后的环境中执行命令</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/26/projectpodenv/" data-id="ck6j1epll001m63jg7iq03q13" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-cocoapodsdev" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/05/cocoapodsdev/" class="article-date">
  <time datetime="2019-10-05T07:49:01.000Z" itemprop="datePublished">2019-10-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%A0%94%E5%8F%91%E6%B5%81%E7%A8%8B/">研发流程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/05/cocoapodsdev/">CocoaPods插件开发原理(一) CocoaPods做了啥</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近入职手淘，搞了一下基于CocoaPods的工程化的升级改造优化。自己也是第一次接触这块，写篇文章总结一下。</p>
<h2 id="开发基础"><a href="#开发基础" class="headerlink" title="开发基础"></a>开发基础</h2><p>CocoaPods插件开发会涉及到的各种概念。</p>
<p>RubyGems: Ruby程序包管理器<br>Gemfile: 定义你的应用依赖哪些第三方包，bundle根据该配置去寻找这些包。<br>Gem: 封装起来的Ruby应用程序或代码库。<br>Bundle: 根据Gemfile安装插件</p>
<h2 id="CocoaPods调试"><a href="#CocoaPods调试" class="headerlink" title="CocoaPods调试"></a>CocoaPods调试</h2><ol>
<li>克隆CocoaPods代码.</li>
<li>安装RubyMine.</li>
<li>通过RubyMine打开工程，会提示install gems.. 点点点…</li>
<li>add Configurations</li>
</ol>
<h2 id="CocoaPods产物分析"><a href="#CocoaPods产物分析" class="headerlink" title="CocoaPods产物分析"></a>CocoaPods产物分析</h2><p>针对于代码工程项目来说，CocoaPods和Xcode的一系列操作，最终都会体现到 build 过程中。</p>
<img src="/2019/10/05/cocoapodsdev/build.png" class="" title="build.png">

<p>可以看到 主要是 compile, link. 资源文件的处理。</p>
<p>对于CocoaPods来说，他的处理结果体现在对Xcode工程配置文件的一系列操作。<br>根据pod install 后查 看 diff, 可以简单的分析一下 做了什么。</p>
<p><strong>主要关注</strong></p>
<ol>
<li>project 文件的diff</li>
<li>xcconfig 的diff</li>
<li>resource 脚本</li>
</ol>
<img src="/2019/10/05/cocoapodsdev/diff.png" class="" title="build.png">

<p>TestCocoaPods.xcodeproj/project.pbxproj: 工程配置文件。<a href="http://www.monobjc.net/xcode-project-file-format.html" target="_blank" rel="noopener">http://www.monobjc.net/xcode-project-file-format.html</a></p>
<p><strong>可以看到对于原始的project, 主要做了以下处理：</strong><br>    1. 配置xcconfig<br>    2. framework链接 Pods_TestCocoaPods.framework<br>    3. 增加 Check Pods Manifest.lock , resource 资源拷贝 操作</p>
<p>*<em>工程文件的diff, 主要是增加文件引用，build phase. *</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">PBXBuildFile section:</span><br><span class="line">E01C29225DD71613589489FA /* Pods_TestCocoaPods.framework in Frameworks */ = &#123;isa = PBXBuildFile; fileRef = CB005D1B7C8E0A3D6341DB9D /* Pods_TestCocoaPods.framework */; &#125;;</span><br><span class="line"></span><br><span class="line">PBXFileReference section:</span><br><span class="line">105074B73663D0E4918F3F90 /* Pods-TestCocoaPods.release.xcconfig */ = &#123;isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = &quot;Pods-TestCocoaPods.release.xcconfig&quot;; path = &quot;Target Support Files/Pods-TestCocoaPods/Pods-TestCocoaPods.release.xcconfig&quot;; sourceTree = &quot;&lt;group&gt;&quot;; &#125;;</span><br><span class="line">60972A114A3E4366A5836A94 /* Pods-TestCocoaPods.debug.xcconfig */ = &#123;isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = &quot;Pods-TestCocoaPods.debug.xcconfig&quot;; path = &quot;Target Support Files/Pods-TestCocoaPods/Pods-TestCocoaPods.debug.xcconfig&quot;; sourceTree = &quot;&lt;group&gt;&quot;; &#125;;</span><br><span class="line">CB005D1B7C8E0A3D6341DB9D /* Pods_TestCocoaPods.framework */ = &#123;isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Pods_TestCocoaPods.framework; sourceTree = BUILT_PRODUCTS_DIR; &#125;;</span><br><span class="line"></span><br><span class="line">PBXFrameworksBuildPhase:</span><br><span class="line">files = (</span><br><span class="line">        E01C29225DD71613589489FA /* Pods_TestCocoaPods.framework in Frameworks */,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">PBXGroup:</span><br><span class="line">22AD612E85507BD42F801917 /* Frameworks */ = &#123;</span><br><span class="line">        isa = PBXGroup;</span><br><span class="line">        children = (</span><br><span class="line">                CB005D1B7C8E0A3D6341DB9D /* Pods_TestCocoaPods.framework */,</span><br><span class="line">        );</span><br><span class="line">        name = Frameworks;</span><br><span class="line">        sourceTree = &quot;&lt;group&gt;&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">563D16002378227800AFB290 = &#123;</span><br><span class="line">        isa = PBXGroup;</span><br><span class="line">        children = (</span><br><span class="line">                C7867C96DA44D37863BEC94B /* Pods */,</span><br><span class="line">                22AD612E85507BD42F801917 /* Frameworks */,</span><br><span class="line">        );</span><br><span class="line">        sourceTree = &quot;&lt;group&gt;&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">C7867C96DA44D37863BEC94B /* Pods */ = &#123;</span><br><span class="line">        isa = PBXGroup;</span><br><span class="line">        children = (</span><br><span class="line">                60972A114A3E4366A5836A94 /* Pods-TestCocoaPods.debug.xcconfig */,</span><br><span class="line">                105074B73663D0E4918F3F90 /* Pods-TestCocoaPods.release.xcconfig */,</span><br><span class="line">        );</span><br><span class="line">        name = Pods;</span><br><span class="line">        path = Pods;</span><br><span class="line">        sourceTree = &quot;&lt;group&gt;&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PBXNativeTarget:</span><br><span class="line">buildPhases = (</span><br><span class="line">        66B2CF8865E26539A7BF8BC7 /* [CP] Check Pods Manifest.lock */,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">PBXShellScriptBuildPhase:</span><br><span class="line">/* Begin PBXShellScriptBuildPhase section */</span><br><span class="line">        66B2CF8865E26539A7BF8BC7 /* [CP] Check Pods Manifest.lock */ = &#123;</span><br><span class="line">                isa = PBXShellScriptBuildPhase;</span><br><span class="line">                buildActionMask = 2147483647;</span><br><span class="line">                files = (</span><br><span class="line">                );</span><br><span class="line">                inputFileListPaths = (</span><br><span class="line">                );</span><br><span class="line">                inputPaths = (</span><br><span class="line">                        &quot;$&#123;PODS_PODFILE_DIR_PATH&#125;/Podfile.lock&quot;,</span><br><span class="line">                        &quot;$&#123;PODS_ROOT&#125;/Manifest.lock&quot;,</span><br><span class="line">                );</span><br><span class="line">                name = &quot;[CP] Check Pods Manifest.lock&quot;;</span><br><span class="line">                outputFileListPaths = (</span><br><span class="line">                );</span><br><span class="line">                outputPaths = (</span><br><span class="line">                        &quot;$(DERIVED_FILE_DIR)/Pods-TestCocoaPods-checkManifestLockResult.txt&quot;,</span><br><span class="line">                );</span><br><span class="line">                runOnlyForDeploymentPostprocessing = 0;</span><br><span class="line">                shellPath = /bin/sh;</span><br><span class="line">                shellScript = &quot;diff \&quot;$&#123;PODS_PODFILE_DIR_PATH&#125;/Podfile.lock\&quot; \&quot;$&#123;PODS_ROOT&#125;/Manifest.lock\&quot; &gt; /dev/null\nif [ $? != 0 ] ; then\n    # print error to STDERR\n    echo \&quot;error: The sandbox is not in sync with the Podfile.lock. Run &apos;pod install&apos; or update your CocoaPods installation.\&quot; &gt;&amp;2\n    exit 1\nfi\n# This output is used by Xcode &apos;outputs&apos; to avoid re-running this script phase.\necho \&quot;SUCCESS\&quot; &gt; \&quot;$&#123;SCRIPT_OUTPUT_FILE_0&#125;\&quot;\n&quot;;</span><br><span class="line">                showEnvVarsInLog = 0;</span><br><span class="line">        &#125;;</span><br><span class="line">/* End PBXShellScriptBuildPhase section */</span><br><span class="line"></span><br><span class="line">XCBuildConfiguration:</span><br><span class="line">563D16232378227900AFB290 /* Debug */ = &#123;</span><br><span class="line">        baseConfigurationReference = 60972A114A3E4366A5836A94 /* Pods-TestCocoaPods.debug.xcconfig */;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Target Support Files/Pods-TestCocoaPods/Pods-TestCocoaPods.debug.xcconfig:</strong><br>主要处理了 头文件路径，库路径，链接配置 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FRAMEWORK_SEARCH_PATHS = $(inherited) &quot;$&#123;PODS_ROOT&#125;/AliColor&quot;</span><br><span class="line">GCC_PREPROCESSOR_DEFINITIONS = $(inherited) COCOAPODS=1</span><br><span class="line">LD_RUNPATH_SEARCH_PATHS = $(inherited) &apos;@executable_path/Frameworks&apos; &apos;@loader_path/Frameworks&apos;</span><br><span class="line">OTHER_LDFLAGS = $(inherited) -ObjC -framework &quot;AliColor&quot;</span><br><span class="line">PODS_BUILD_DIR = $&#123;BUILD_DIR&#125;</span><br><span class="line">PODS_CONFIGURATION_BUILD_DIR = $&#123;PODS_BUILD_DIR&#125;/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)</span><br><span class="line">PODS_PODFILE_DIR_PATH = $&#123;SRCROOT&#125;/.</span><br><span class="line">PODS_ROOT = $&#123;SRCROOT&#125;/Pods</span><br></pre></td></tr></table></figure>

<p><strong>CocoaPods Framework 资源管理</strong><br>在Github找了MJRefresh,其里面包含了一些资源文件。<br>pod install 之后，build phase 中有 Pods-xxx-framework.sh 其中对资源文件做了处理</p>
<p>主要的内容如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Use filter instead of exclude so missing patterns don&apos;t throw errors.</span><br><span class="line">echo &quot;rsync --delete -av &quot;$&#123;RSYNC_PROTECT_TMP_FILES[@]&#125;&quot; --filter \&quot;- CVS/\&quot; --filter \&quot;- .svn/\&quot; --filter \&quot;- .git/\&quot; --filter \&quot;- .hg/\&quot; --filter \&quot;- Headers\&quot; --filter \&quot;- PrivateHeaders\&quot; --filter \&quot;- Modules\&quot; \&quot;$&#123;source&#125;\&quot; \&quot;$&#123;destination&#125;\&quot;&quot;</span><br><span class="line">rsync --delete -av &quot;$&#123;RSYNC_PROTECT_TMP_FILES[@]&#125;&quot; --filter &quot;- CVS/&quot; --filter &quot;- .svn/&quot; --filter &quot;- .git/&quot; --filter &quot;- .hg/&quot; --filter &quot;- Headers&quot; --filter &quot;- PrivateHeaders&quot; --filter &quot;- Modules&quot; &quot;$&#123;source&#125;&quot; &quot;$&#123;destination&#125;&quot;</span><br><span class="line"># Strip invalid architectures so &quot;fat&quot; simulator / device frameworks work on device</span><br><span class="line">if [[ &quot;$(file &quot;$binary&quot;)&quot; == *&quot;dynamically linked shared library&quot;* ]]; then</span><br><span class="line">strip_invalid_archs &quot;$binary&quot;</span><br><span class="line">fi</span><br><span class="line"># Resign the code if required by the build settings to avoid unstable apps</span><br><span class="line">  code_sign_if_enabled &quot;$&#123;destination&#125;/$(basename &quot;$1&quot;)&quot;</span><br></pre></td></tr></table></figure>

<p>Build 一下，看看Log，可以看到拷贝了资源文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">PhaseScriptExecution [CP]\ Embed\ Pods\ Frameworks /Users/xiejunyi/Library/Developer/Xcode/DerivedData/TestCocoaPods-emoajnwkneawvvazmpgriocqboko/Build/Intermediates.noindex/TestCocoaPods.build/Debug-iphonesimulator/TestCocoaPods.build/Script-2FE0977B29313E1B2691D262.sh (in target &apos;TestCocoaPods&apos; from project &apos;TestCocoaPods&apos;)</span><br><span class="line">    cd /Users/xiejunyi/Library/Mobile\ Documents/com~apple~CloudDocs/codes/Demos/TestCocoaPods</span><br><span class="line">    /bin/sh -c /Users/xiejunyi/Library/Developer/Xcode/DerivedData/TestCocoaPods-emoajnwkneawvvazmpgriocqboko/Build/Intermediates.noindex/TestCocoaPods.build/Debug-iphonesimulator/TestCocoaPods.build/Script-2FE0977B29313E1B2691D262.sh</span><br><span class="line"></span><br><span class="line">mkdir -p /Users/xiejunyi/Library/Developer/Xcode/DerivedData/TestCocoaPods-emoajnwkneawvvazmpgriocqboko/Build/Products/Debug-iphonesimulator/TestCocoaPods.app/Frameworks</span><br><span class="line">rsync --delete -av --filter P .*.?????? --filter &quot;- CVS/&quot; --filter &quot;- .svn/&quot; --filter &quot;- .git/&quot; --filter &quot;- .hg/&quot; --filter &quot;- Headers&quot; --filter &quot;- PrivateHeaders&quot; --filter &quot;- Modules&quot; &quot;/Users/xiejunyi/Library/Developer/Xcode/DerivedData/TestCocoaPods-emoajnwkneawvvazmpgriocqboko/Build/Products/Debug-iphonesimulator/MJRefresh/MJRefresh.framework&quot; &quot;/Users/xiejunyi/Library/Developer/Xcode/DerivedData/TestCocoaPods-emoajnwkneawvvazmpgriocqboko/Build/Products/Debug-iphonesimulator/TestCocoaPods.app/Frameworks&quot;</span><br><span class="line">building file list ... done</span><br><span class="line">MJRefresh.framework/</span><br><span class="line">MJRefresh.framework/Info.plist</span><br><span class="line">MJRefresh.framework/MJRefresh</span><br><span class="line">MJRefresh.framework/MJRefresh.bundle/</span><br><span class="line">MJRefresh.framework/MJRefresh.bundle/arrow@2x.png</span><br><span class="line">MJRefresh.framework/MJRefresh.bundle/en.lproj/</span><br><span class="line">MJRefresh.framework/MJRefresh.bundle/en.lproj/Localizable.strings</span><br><span class="line">MJRefresh.framework/MJRefresh.bundle/ko.lproj/</span><br><span class="line">MJRefresh.framework/MJRefresh.bundle/ko.lproj/Localizable.strings</span><br><span class="line">MJRefresh.framework/MJRefresh.bundle/zh-Hans.lproj/</span><br><span class="line">MJRefresh.framework/MJRefresh.bundle/zh-Hans.lproj/Localizable.strings</span><br><span class="line">MJRefresh.framework/MJRefresh.bundle/zh-Hant.lproj/</span><br><span class="line">MJRefresh.framework/MJRefresh.bundle/zh-Hant.lproj/Localizable.strings</span><br><span class="line">MJRefresh.framework/_CodeSignature/</span><br><span class="line">MJRefresh.framework/_CodeSignature/CodeResources</span><br><span class="line"></span><br><span class="line">sent 240510 bytes  received 238 bytes  481496.00 bytes/sec</span><br><span class="line">total size is 239605  speedup is 1.00</span><br><span class="line">Code Signing /Users/xiejunyi/Library/Developer/Xcode/DerivedData/TestCocoaPods-emoajnwkneawvvazmpgriocqboko/Build/Products/Debug-iphonesimulator/TestCocoaPods.app/Frameworks/MJRefresh.framework with Identity -</span><br><span class="line">/usr/bin/codesign --force --sign -  --preserve-metadata=identifier,entitlements &apos;/Users/xiejunyi/Library/Developer/Xcode/DerivedData/TestCocoaPods-emoajnwkneawvvazmpgriocqboko/Build/Products/Debug-iphonesimulator/TestCocoaPods.app/Frameworks/MJRefresh.framework&apos;</span><br><span class="line">/Users/xiejunyi/Library/Developer/Xcode/DerivedData/TestCocoaPods-emoajnwkneawvvazmpgriocqboko/Build/Products/Debug-iphonesimulator/TestCocoaPods.app/Frameworks/MJRefresh.framework: replacing existing signature</span><br></pre></td></tr></table></figure>

<p>以上基本涵盖了一个简单工程，CocoaPods进行的主要操作。</p>
<h3 id="下一篇-CocoaPods插件开发原理-二-定制项目CocoaPods插件环境"><a href="#下一篇-CocoaPods插件开发原理-二-定制项目CocoaPods插件环境" class="headerlink" title="下一篇 CocoaPods插件开发原理(二) 定制项目CocoaPods插件环境"></a>下一篇 CocoaPods插件开发原理(二) 定制项目CocoaPods插件环境</h3><h3 id="下一篇-CocoaPods插件开发原理-三-调试与开发CocoaPods插件"><a href="#下一篇-CocoaPods插件开发原理-三-调试与开发CocoaPods插件" class="headerlink" title="下一篇 CocoaPods插件开发原理(三) 调试与开发CocoaPods插件"></a>下一篇 CocoaPods插件开发原理(三) 调试与开发CocoaPods插件</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/10/05/cocoapodsdev/" data-id="ck6j1epla000t63jg16sf9qwf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CrashMonitorSystem" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/28/CrashMonitorSystem/" class="article-date">
  <time datetime="2019-09-28T06:27:45.000Z" itemprop="datePublished">2019-09-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/APM/">APM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/28/CrashMonitorSystem/">崩溃捕获系统的原理（一）异常信号</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前在头条搞了端监控，比较有意思的部分是Crash捕获，持续做了1年。开源的Crash捕获框架KSCrash,PLCrashReporter 都值得一看。当然也存在各自的问题。这边博客主要简单讲一下Mach系统的异常处理模型。</p>
<h2 id="Crash捕获"><a href="#Crash捕获" class="headerlink" title="Crash捕获"></a>Crash捕获</h2><p>下面是Crash捕获处理系统几个核心的关键领域知识。感兴趣的可以自行了解一下，每一部分都值得研究，弄明白了 系统的异常处理机制，Dynamic Image, Thread Context，可以加深对iOS底层工作原理的理解。</p>
<ul>
<li>UNIX signals 信号</li>
<li>Mach Exceptions Mach异常</li>
<li>Basic Thread details 线程现场信息</li>
<li>Binary image information 动态库信息</li>
<li>Frame pointer-based stack traces 基于fp的callstack回溯</li>
<li>Compact Unwind support 辅助callstack回溯的 Compact Unwind信息</li>
</ul>
<p><strong>本片主要介绍的是异常和信号的处理。</strong><br>具体代码怎么抓 Mach / Signal Exception 可以看看开源的 KSCrash 和 PLCrashReporter.</p>
<h2 id="异常处理流程"><a href="#异常处理流程" class="headerlink" title="异常处理流程"></a>异常处理流程</h2><ul>
<li>Mach异常模型</li>
<li>Mach异常和Signal的转换</li>
<li>软件异常</li>
<li>硬件异常触发流程</li>
<li>系统是怎么抓的crash? 为什么都是 EXC_CRASH 类型？</li>
</ul>
<p>首先要明确几个概念及其之间的联系：<code>硬件异常</code>, <code>软件异常</code>,<code>mach异常</code>, <code>Signal异常</code>。这四种异常概念，自底向上构建了iOS系统的异常处理模型。</p>
<p>其之间的关系如下</p>
<img src="/2019/09/28/CrashMonitorSystem/process.png" class="" title="process.png">

<h3 id="Mach异常模型"><a href="#Mach异常模型" class="headerlink" title="Mach异常模型"></a>Mach异常模型</h3><p>基于 mach message 机制, 可以</p>
<ul>
<li>通过注册端口监听异常消息<ul>
<li>可以为 host, task, thread 注册异常处理端口。(例如：小程序注册thread 级别的处理，然后自己处理异常。)</li>
</ul>
</li>
<li>发送异常消息</li>
</ul>
<p>mach异常信号的来源，可以看到通过两种途径：</p>
<ul>
<li>硬件级别的触发异常</li>
<li>proc退出时会触发异常(EXC_CRASH)。</li>
</ul>
<img src="/2019/09/28/CrashMonitorSystem/exception_triage.png" class="" title="exception_triage.png">


<h3 id="Mach异常和Signal的转换"><a href="#Mach异常和Signal的转换" class="headerlink" title="Mach异常和Signal的转换"></a>Mach异常和Signal的转换</h3><p>Mach异常如果不处理，默认会转化为Signal异常。<br>内核注册了host-level的exception handler，负责将mach异常转换为对应的Signal信号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Called with kernel funnel held */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">bsdinit_task(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">proc_t</span> p = current_proc();</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uthread</span> *<span class="title">ut</span>;</span></span><br><span class="line">	<span class="keyword">thread_t</span> thread;</span><br><span class="line"></span><br><span class="line">	process_name(<span class="string">"init"</span>, p);</span><br><span class="line"></span><br><span class="line">	ux_handler_init();</span><br><span class="line"></span><br><span class="line">	thread = current_thread();</span><br><span class="line">	(<span class="keyword">void</span>) host_set_exception_ports(host_priv_self(),</span><br><span class="line">					EXC_MASK_ALL &amp; ~(EXC_MASK_RPC_ALERT),<span class="comment">//pilotfish (shark) needs this port</span></span><br><span class="line">					(<span class="keyword">mach_port_t</span>) ux_exception_port,</span><br><span class="line">					EXCEPTION_DEFAULT| MACH_EXCEPTION_CODES,</span><br><span class="line">					<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	ut = (<span class="keyword">uthread_t</span>)get_bsdthread_info(thread);</span><br><span class="line"></span><br><span class="line">	bsd_init_task = get_threadtask(thread);</span><br><span class="line">	init_task_failure_data[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_MACF</span></span><br><span class="line">	mac_cred_label_associate_user(p-&gt;p_ucred);</span><br><span class="line">	mac_task_label_update_cred (p-&gt;p_ucred, (struct task *) p-&gt;task);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	load_init_program(p);</span><br><span class="line">	lock_trace = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="硬件异常触发流程"><a href="#硬件异常触发流程" class="headerlink" title="硬件异常触发流程"></a>硬件异常触发流程</h3><img src="/2019/09/28/CrashMonitorSystem/hardware_mach.png" class="" title="hardware_mach.png">
<p>硬件异常会转化为Mach异常</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">i386_exception(</span><br><span class="line">	<span class="keyword">int</span>	exc,</span><br><span class="line">	<span class="keyword">mach_exception_code_t</span> code,</span><br><span class="line">	<span class="keyword">mach_exception_subcode_t</span> subcode)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">mach_exception_data_type_t</span>   codes[EXCEPTION_CODE_MAX];</span><br><span class="line"></span><br><span class="line">	DEBUG_KPRINT_SYSCALL_MACH(<span class="string">"i386_exception: exc=%d code=0x%llx subcode=0x%llx\n"</span>,</span><br><span class="line">							  exc, code, subcode);</span><br><span class="line">	codes[<span class="number">0</span>] = code;		<span class="comment">/* new exception interface */</span></span><br><span class="line">	codes[<span class="number">1</span>] = subcode;</span><br><span class="line">	exception_triage(exc, codes, <span class="number">2</span>);</span><br><span class="line">	<span class="comment">/*NOTREACHED*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">exception_triage(</span><br><span class="line">	<span class="keyword">exception_type_t</span>	exception,</span><br><span class="line">	<span class="keyword">mach_exception_data_t</span>	code,</span><br><span class="line">	<span class="keyword">mach_msg_type_number_t</span>  codeCnt)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">thread_t</span>		thread;</span><br><span class="line">	<span class="keyword">task_t</span>			task;</span><br><span class="line">	<span class="keyword">host_priv_t</span>		host_priv;</span><br><span class="line">	<span class="keyword">lck_mtx_t</span>		*mutex;</span><br><span class="line">	<span class="keyword">kern_return_t</span>	kr;</span><br><span class="line"></span><br><span class="line">	assert(exception != EXC_RPC_ALERT);</span><br><span class="line"></span><br><span class="line">	thread = current_thread();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Try to raise the exception at the activation level.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mutex = &amp;thread-&gt;mutex;</span><br><span class="line">	kr = exception_deliver(thread, exception, code, codeCnt, thread-&gt;exc_actions, mutex);</span><br><span class="line">	<span class="keyword">if</span> (kr == KERN_SUCCESS || kr == MACH_RCV_PORT_DIED)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Maybe the task level will handle it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	task = current_task();</span><br><span class="line">	mutex = &amp;task-&gt;lock;</span><br><span class="line">	kr = exception_deliver(thread, exception, code, codeCnt, task-&gt;exc_actions, mutex);</span><br><span class="line">	<span class="keyword">if</span> (kr == KERN_SUCCESS || kr == MACH_RCV_PORT_DIED)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * How about at the host level?</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	host_priv = host_priv_self();</span><br><span class="line">	mutex = &amp;host_priv-&gt;lock;</span><br><span class="line">	kr = exception_deliver(thread, exception, code, codeCnt, host_priv-&gt;exc_actions, mutex);</span><br><span class="line">	<span class="keyword">if</span> (kr == KERN_SUCCESS || kr == MACH_RCV_PORT_DIED)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Nobody handled it, terminate the task.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	(<span class="keyword">void</span>) task_terminate(task);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> ((exception != EXC_CRASH) &amp;&amp; (exception != EXC_RESOURCE) &amp;&amp;</span><br><span class="line">	    (exception != EXC_GUARD))</span><br><span class="line">		thread_exception_return();</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="软件异常"><a href="#软件异常" class="headerlink" title="软件异常"></a>软件异常</h3><p>通过kill() 直接抛出signal异常(软件)<br>处理流程如下图所示：</p>
<img src="/2019/09/28/CrashMonitorSystem/kill.png" class="" title="kill.png">


<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">__private_extern__ <span class="keyword">void</span></span><br><span class="line">__abort()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!CRGetCrashLogMessage())</span><br><span class="line">		CRSetCrashLogMessage(<span class="string">"__abort() called"</span>);</span><br><span class="line">	act.sa_handler = SIG_DFL;</span><br><span class="line">	act.sa_flags = <span class="number">0</span>;</span><br><span class="line">	sigfillset(&amp;act.sa_mask);</span><br><span class="line">	(<span class="keyword">void</span>)_sigaction(SIGABRT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">	sigdelset(&amp;act.sa_mask, SIGABRT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* &lt;rdar://problem/7397932&gt; abort() should call pthread_kill to deliver a signal to the aborting thread </span></span><br><span class="line"><span class="comment">	 * This helps gdb focus on the thread calling abort()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (__is_threaded) &#123;</span><br><span class="line">	    <span class="comment">/* Block all signals on all other threads */</span></span><br><span class="line">	    <span class="keyword">sigset_t</span> fullmask;</span><br><span class="line">	    sigfillset(&amp;fullmask);</span><br><span class="line">	    (<span class="keyword">void</span>)_sigprocmask(SIG_SETMASK, &amp;fullmask, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	    <span class="comment">/* &lt;rdar://problem/8400096&gt; Set the workqueue killable */</span></span><br><span class="line">	    __pthread_workqueue_setkill(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	    (<span class="keyword">void</span>)pthread_sigmask(SIG_SETMASK, &amp;act.sa_mask, <span class="literal">NULL</span>);</span><br><span class="line">	    (<span class="keyword">void</span>)pthread_kill(pthread_self(), SIGABRT);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    (<span class="keyword">void</span>)_sigprocmask(SIG_SETMASK, &amp;act.sa_mask, <span class="literal">NULL</span>);</span><br><span class="line">	    (<span class="keyword">void</span>)kill(getpid(), SIGABRT);</span><br><span class="line">	&#125;</span><br><span class="line">	usleep(TIMEOUT); <span class="comment">/* give time for signal to happen */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If for some reason SIGABRT was not delivered, we exit using __builtin_trap</span></span><br><span class="line"><span class="comment">	 * which generates an illegal instruction on i386: &lt;rdar://problem/8400958&gt;</span></span><br><span class="line"><span class="comment">	 * and SIGTRAP on arm.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	sigfillset(&amp;act.sa_mask);</span><br><span class="line">	sigdelset(&amp;act.sa_mask, SIGILL);</span><br><span class="line">	sigdelset(&amp;act.sa_mask, SIGTRAP);</span><br><span class="line">	(<span class="keyword">void</span>)_sigprocmask(SIG_SETMASK, &amp;act.sa_mask, <span class="literal">NULL</span>);</span><br><span class="line">	__builtin_trap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="系统是怎么抓的crash-为什么都是-EXC-CRASH-类型？"><a href="#系统是怎么抓的crash-为什么都是-EXC-CRASH-类型？" class="headerlink" title="系统是怎么抓的crash? 为什么都是 EXC_CRASH 类型？"></a>系统是怎么抓的crash? 为什么都是 EXC_CRASH 类型？</h3><p>系统通过launchd监听了EXC_CRASH。<br>EXC_CRASH 是一种特殊类型，囊括硬件和软件异常，什么都能抓。但是需要out-of-process 处理。(信号发出的时候，进程已经跪了)<br>看进程退出逻辑，EXC_CRASH 基本上会囊括所有的崩溃类型。软硬件异常都会转化为Signal信号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">proc_prepareexit(<span class="keyword">proc_t</span> p, <span class="keyword">int</span> rv, <span class="keyword">boolean_t</span> perf_notify) </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">mach_exception_data_type_t</span> code, subcode;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uthread</span> *<span class="title">ut</span>;</span></span><br><span class="line">	<span class="keyword">thread_t</span> self = current_thread();</span><br><span class="line">	ut = get_bsdthread_info(self);</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">/* If a core should be generated, notify crash reporter */</span></span><br><span class="line">	<span class="keyword">if</span> (hassigprop(WTERMSIG(rv), SA_CORE) || ((p-&gt;p_csflags &amp; CS_KILLED) != <span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="comment">/* </span></span><br><span class="line"><span class="comment">		 * Workaround for processes checking up on PT_DENY_ATTACH:</span></span><br><span class="line"><span class="comment">		 * should be backed out post-Leopard (details in 5431025).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> ((SIGSEGV == WTERMSIG(rv)) &amp;&amp; </span><br><span class="line">				(p-&gt;p_pptr-&gt;p_lflag &amp; P_LNOATTACH)) &#123;</span><br><span class="line">			<span class="keyword">goto</span> skipcheck;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Crash Reporter looks for the signal value, original exception</span></span><br><span class="line"><span class="comment">		 * type, and low 20 bits of the original code in code[0] </span></span><br><span class="line"><span class="comment">		 * (8, 4, and 20 bits respectively). code[1] is unmodified. </span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		code = ((WTERMSIG(rv) &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">24</span>) |</span><br><span class="line">			((ut-&gt;uu_exception &amp; <span class="number">0x0f</span>) &lt;&lt; <span class="number">20</span>) | </span><br><span class="line">			((<span class="keyword">int</span>)ut-&gt;uu_code &amp; <span class="number">0xfffff</span>);</span><br><span class="line">		subcode = ut-&gt;uu_subcode;</span><br><span class="line">		(<span class="keyword">void</span>) task_exception_notify(EXC_CRASH, code, subcode);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">skipcheck:</span><br><span class="line">	<span class="comment">/* Notify the perf server? */</span></span><br><span class="line">	<span class="keyword">if</span> (perf_notify) &#123;</span><br><span class="line">		(<span class="keyword">void</span>)sys_perf_notify(self, p-&gt;p_pid);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Remove proc from allproc queue and from pidhash chain.</span></span><br><span class="line"><span class="comment">	 * Need to do this before we do anything that can block.</span></span><br><span class="line"><span class="comment">	 * Not doing causes things like mount() find this on allproc</span></span><br><span class="line"><span class="comment">	 * in partially cleaned state.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	proc_list_lock();</span><br><span class="line"></span><br><span class="line">	LIST_REMOVE(p, p_list);</span><br><span class="line">	LIST_INSERT_HEAD(&amp;zombproc, p, p_list);	<span class="comment">/* Place onto zombproc. */</span></span><br><span class="line">	<span class="comment">/* will not be visible via proc_find */</span></span><br><span class="line">	p-&gt;p_listflag |= P_LIST_EXITED;</span><br><span class="line"></span><br><span class="line">	proc_list_unlock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PGINPROF</span></span><br><span class="line">	vmsizmon();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If parent is waiting for us to exit or exec,</span></span><br><span class="line"><span class="comment">	 * P_LPPWAIT is set; we will wakeup the parent below.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	proc_lock(p);</span><br><span class="line">	p-&gt;p_lflag &amp;= ~(P_LTRACED | P_LPPWAIT);</span><br><span class="line">	p-&gt;p_sigignore = ~(sigcantmask);</span><br><span class="line">	ut-&gt;uu_siglist = <span class="number">0</span>;</span><br><span class="line">	proc_unlock(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/28/CrashMonitorSystem/" data-id="ck6j1epkr000763jgd5ss9reu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-dwarf和符号化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/30/dwarf%E5%92%8C%E7%AC%A6%E5%8F%B7%E5%8C%96/" class="article-date">
  <time datetime="2018-09-30T08:21:07.000Z" itemprop="datePublished">2018-09-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/APM/">APM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/30/dwarf%E5%92%8C%E7%AC%A6%E5%8F%B7%E5%8C%96/">DWARF和符号化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="DWARF-格式简介"><a href="#DWARF-格式简介" class="headerlink" title="DWARF 格式简介"></a>DWARF 格式简介</h2><p>DWARF: 它是可执行程序与源代码关系的一个紧凑的表示.</p>
<p>大多数现代编程语言是块结构的：每个实体（例如，一个类定义或一个函数）被包含在另一个实体中。在一个C程序里，每个文件可能包含多个数据定义、多个变量定义，及多个函数。DWARF遵循这个模型，它也是块结构的。在DWARF里基本的描述项是调试信息项（DebuggingInformation Entry——DIE）。一个DIE有一个标签，它指明了这个DIE描述什么及一个填入了细节并进一步描述该项的属性列表。一个DIE（除了最顶层的）被一个父DIE包含（或者说拥有），并可能有兄弟DIE或子DIE。属性可能包含各种值：常量（比如一个函数名），变量（比如一个函数的起始地址），或对另一个DIE的引用（比如一个函数的返回值类型）。</p>
<h2 id="利用DWARF符号化"><a href="#利用DWARF符号化" class="headerlink" title="利用DWARF符号化"></a>利用DWARF符号化</h2><p>符号化地址，我们期望的结果是，获取地址对应的函数名称和调用行数等信息。DWARF调试格式中携带了大量信息，当然包括函数名称和地址。因此如果我们提供的调用地址能在函数中找到信息，优先使用DWARF中的符号信息进行符号化。</p>
<p>在 DWARF 中，这些信息主要由 DW_AT_subprogram 和 line table 承载。<br>我们只需要根据地址在 DWARF 文件中找到对应的 信息。</p>
<h3 id="函数名称"><a href="#函数名称" class="headerlink" title="函数名称"></a>函数名称</h3><p>DW_AT_Subprogram 中可以获取到的信息</p>
<p>很容易看到，Dwarf调试信息中精心设计了 函数信息的具体表示，我们可以获取名称和类型等重要的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1</span>$:    DW_TAG_unspecified_type</span><br><span class="line">           DW_AT_name(<span class="string">"void"</span>)</span><br><span class="line">           ...</span><br><span class="line"><span class="number">2</span>$     DW_TAG_base_type</span><br><span class="line">           DW_AT_name(<span class="string">"int"</span>)</span><br><span class="line">           ...</span><br><span class="line"><span class="number">3</span>$:    DW_TAG_class_type</span><br><span class="line">           DW_AT_name(<span class="string">"A"</span>)</span><br><span class="line">           ...</span><br><span class="line"><span class="number">4</span>$:        DW_TAG_pointer_type</span><br><span class="line">               DW_AT_type(reference to <span class="number">3</span>$)</span><br><span class="line">               ...</span><br><span class="line"><span class="number">5</span>$:        DW_TAG_const_type</span><br><span class="line">               DW_AT_type(reference to <span class="number">3</span>$)</span><br><span class="line">               ...</span><br><span class="line"><span class="number">6</span>$:        DW_TAG_pointer_type</span><br><span class="line">               DW_AT_type(reference to <span class="number">5</span>$)</span><br><span class="line">               ...</span><br><span class="line"><span class="number">7</span>$:        DW_TAG_subprogram</span><br><span class="line">               DW_AT_name(<span class="string">"func1"</span>)</span><br><span class="line">               DW_AT_type(reference to <span class="number">1</span>$)</span><br><span class="line">               DW_AT_object_pointer(reference to <span class="number">8</span>$)</span><br><span class="line">                   ! References a formal parameter in <span class="keyword">this</span> member function</span><br><span class="line">               ...</span><br><span class="line"><span class="number">8</span>$:            DW_TAG_formal_parameter</span><br><span class="line">                   DW_AT_artificial(<span class="literal">true</span>)</span><br><span class="line">                   DW_AT_name(<span class="string">"this"</span>)</span><br><span class="line">                   DW_AT_type(reference to <span class="number">4</span>$)</span><br><span class="line">                       ! Makes type of 'this' as 'A*' =&gt;</span><br><span class="line">                       ! func1 has <span class="keyword">not</span> been marked <span class="keyword">const</span> <span class="keyword">or</span> <span class="keyword">volatile</span></span><br><span class="line">                   DW_AT_location ...</span><br><span class="line">                   ...</span><br><span class="line"><span class="number">9</span>$:            DW_TAG_formal_parameter</span><br><span class="line">                   DW_AT_name(x1)</span><br><span class="line">                   DW_AT_type(reference to <span class="number">2</span>$)</span><br><span class="line">                   ...</span><br><span class="line"><span class="number">10</span>$:       DW_TAG_subprogram</span><br><span class="line">               DW_AT_name(<span class="string">"func2"</span>)</span><br><span class="line">               DW_AT_type(reference to <span class="number">1</span>$)</span><br><span class="line">               DW_AT_object_pointer(reference to <span class="number">11</span>$)</span><br><span class="line">                   ! References a formal parameter in <span class="keyword">this</span> member function</span><br><span class="line">               ...</span><br><span class="line"><span class="number">11</span>$:           DW_TAG_formal_parameter</span><br><span class="line">                   DW_AT_artificial(<span class="literal">true</span>)</span><br><span class="line">                   DW_AT_name(<span class="string">"this"</span>)</span><br><span class="line">                   DW_AT_type(reference to <span class="number">6</span>$)</span><br><span class="line">                       ! Makes type of 'this' as 'A const*' =&gt;</span><br><span class="line">                       ! func2 marked as <span class="keyword">const</span></span><br><span class="line">                   DW_AT_location ...</span><br><span class="line">                   ...</span><br><span class="line"><span class="number">12</span>$:       DW_TAG_subprogram</span><br><span class="line">               DW_AT_name(<span class="string">"func3"</span>)</span><br><span class="line">               DW_AT_type(reference to <span class="number">1</span>$)</span><br><span class="line">               ...</span><br><span class="line">                   ! No 'this' formal parameter =&gt; func3 is static</span><br><span class="line"><span class="number">13</span>$:           DW_TAG_formal_parameter</span><br><span class="line">                   DW_AT_name(x3)</span><br><span class="line">                   DW_AT_type(reference to <span class="number">2</span>$)</span><br><span class="line">                   ...</span><br></pre></td></tr></table></figure>


<h3 id="内联函数处理"><a href="#内联函数处理" class="headerlink" title="内联函数处理"></a>内联函数处理</h3><p>对于内联函数，编译器会将其在多处展开。可以通过 DW_AT_inline 标志判断其展开的状态和判断其是否是”abstract instance entry”.<br>基于存储空间的考虑，把 某个内联函数构造成 “abstract instance entry” 提供名称等信息，可以避免多个具体内联函数展开的重复空间消耗。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">       ! Abstract instance <span class="keyword">for</span> OUTER</span><br><span class="line">        !</span><br><span class="line">OUTER.AI<span class="number">.1</span><span class="number">.1</span>:</span><br><span class="line">        DW_TAG_subprogram</span><br><span class="line">            DW_AT_name(<span class="string">"OUTER"</span>)</span><br><span class="line">            DW_AT_inline(DW_INL_declared_inlined)</span><br><span class="line">            ! No low/high PCs</span><br><span class="line">OUTER.AI<span class="number">.1</span><span class="number">.2</span>:</span><br><span class="line">            DW_TAG_formal_parameter</span><br><span class="line">                DW_AT_name(<span class="string">"OUTER_FORMAL"</span>)</span><br><span class="line">                DW_AT_type(reference to integer)</span><br><span class="line">                ! No location</span><br><span class="line">OUTER.AI<span class="number">.1</span><span class="number">.3</span>:</span><br><span class="line">            DW_TAG_variable</span><br><span class="line">                DW_AT_name(<span class="string">"OUTER_LOCAL"</span>)</span><br><span class="line">                DW_AT_type(reference to integer)</span><br><span class="line">                ! No location</span><br><span class="line">            !</span><br><span class="line">            ! Abstract instance <span class="keyword">for</span> INNER</span><br><span class="line">            !</span><br><span class="line">INNER.AI<span class="number">.1</span><span class="number">.1</span>:</span><br><span class="line">            DW_TAG_subprogram</span><br><span class="line">                DW_AT_name(<span class="string">"INNER"</span>)</span><br><span class="line">                DW_AT_inline(DW_INL_declared_inlined)</span><br><span class="line">                ! No low/high PCs</span><br><span class="line">INNER.AI<span class="number">.1</span><span class="number">.2</span>:   DW_TAG_formal_parameter</span><br><span class="line">                    DW_AT_name(<span class="string">"INNER_FORMAL"</span>)</span><br><span class="line">                    DW_AT_type(reference to integer)</span><br><span class="line">                    ! No location</span><br><span class="line">INNER.AI<span class="number">.1</span><span class="number">.3</span>:   DW_TAG_variable</span><br><span class="line">                    DW_AT_name(<span class="string">"INNER_LOCAL"</span>)</span><br><span class="line">                    DW_AT_type(reference to integer)</span><br><span class="line">                    ! No location</span><br><span class="line">                ...</span><br><span class="line">                <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            ! <span class="function">No <span class="title">DW_TAG_inlined_subroutine</span> <span class="params">(concrete instance)</span></span></span><br><span class="line">      ! for INNER corresponding to calls of INNER</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Figure <span class="number">66.</span> Inlining example #<span class="number">1</span>: abstract instance</span><br></pre></td></tr></table></figure>

<p><strong>concrete instance</strong> 表示编译时，某处内联函数的展开。它最主要的信息就是 DW_AT_low_pc,DW_AT_high_pc 通过pc地址信息，我们可以将函数调用地址定位到具体的DWARF debug entry。<br>由于存在 “abstract instance”，”concrete instance” 的某些属性会被省略，因此我们需要通过 DW_AT_abstract_origin 属性去找到对应的 abstract instance entry，获取被省略掉的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">        ! Concrete instance <span class="keyword">for</span> call <span class="string">"OUTER(7)"</span></span><br><span class="line">  !</span><br><span class="line">OUTER.CI<span class="number">.1</span><span class="number">.1</span>:</span><br><span class="line">        DW_TAG_inlined_subroutine</span><br><span class="line">            ! No name</span><br><span class="line">            DW_AT_abstract_origin(reference to OUTER.AI<span class="number">.1</span><span class="number">.1</span>)</span><br><span class="line">            DW_AT_low_pc(...)</span><br><span class="line">            DW_AT_high_pc(...)</span><br><span class="line">OUTER.CI<span class="number">.1</span><span class="number">.2</span>:</span><br><span class="line">            DW_TAG_formal_parameter</span><br><span class="line">                ! No name</span><br><span class="line">                DW_AT_abstract_origin(reference to OUTER.AI<span class="number">.1</span><span class="number">.2</span>)</span><br><span class="line">    DW_AT_const_value(<span class="number">7</span>)</span><br><span class="line">OUTER.CI<span class="number">.1</span><span class="number">.3</span>:</span><br><span class="line">            DW_TAG_variable</span><br><span class="line">                ! No name</span><br><span class="line">                DW_AT_abstract_origin(reference to OUTER.AI<span class="number">.1</span><span class="number">.3</span>)</span><br><span class="line">                DW_AT_location(...)</span><br><span class="line">            !</span><br><span class="line">            ! <span class="function">No <span class="title">DW_TAG_subprogram</span> <span class="params">(abstract instance)</span> <span class="keyword">for</span> INNER</span></span><br><span class="line">            !</span><br><span class="line">            ! <span class="function">Concrete instance <span class="keyword">for</span> call <span class="title">INNER</span><span class="params">(OUTER_LOCAL)</span></span></span><br><span class="line">            ! </span><br><span class="line">INNER.CI<span class="number">.1</span><span class="number">.1</span>:</span><br><span class="line">            DW_TAG_inlined_subroutine</span><br><span class="line">                ! No name</span><br><span class="line">                DW_AT_abstract_origin(reference to INNER.AI<span class="number">.1</span><span class="number">.1</span>)</span><br><span class="line">                DW_AT_low_pc(...)</span><br><span class="line">                DW_AT_high_pc(...)</span><br><span class="line">                DW_AT_static_link(...)</span><br><span class="line">INNER.CI<span class="number">.1</span><span class="number">.2</span>:   DW_TAG_formal_parameter</span><br><span class="line">                    ! No name</span><br><span class="line">                    DW_AT_abstract_origin(reference to INNER.AI<span class="number">.1</span><span class="number">.2</span>)</span><br><span class="line">                    DW_AT_location(...)</span><br><span class="line">INNER.CI<span class="number">.1</span><span class="number">.3</span>:   DW_TAG_variable</span><br><span class="line">                    ! No name</span><br><span class="line">                    DW_AT_abstract_origin(reference to INNER.AI<span class="number">.1</span><span class="number">.3</span>)</span><br><span class="line">                    DW_AT_location(...)</span><br><span class="line">                ...</span><br><span class="line">                <span class="number">0</span></span><br><span class="line"></span><br><span class="line">      ! Another concrete instance of INNER within OUTER</span><br><span class="line">      ! <span class="keyword">for</span> the call <span class="string">"INNER(31)"</span></span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="非定义调试信息项处理"><a href="#非定义调试信息项处理" class="headerlink" title="非定义调试信息项处理"></a>非定义调试信息项处理</h3><p>当函数定义并不在声明区域时，subprogram DIE 就会有 DW_AT_specification 属性，指向相关的函数定义DIE.<br>对于带有 DW_AT_specification 的调试信息项，我们需要进行特殊处理。</p>
<h3 id="定位地址对应Dwarf-debug-info"><a href="#定位地址对应Dwarf-debug-info" class="headerlink" title="定位地址对应Dwarf debug info"></a>定位地址对应Dwarf debug info</h3><p>backtrace() 我们可以拿到 image 的 loadaddress 和 address调用地址。</p>
<p>进而得到文件虚拟地址<br>fileVmAddress = address - (loadaddress - imageFileVmTextAddress)</p>
<p>通过文件虚拟地址后通过 .debug_aranges 查找到指定的 DWARF compile unit，进而查找到具体的DIE. 从属性中获取我们需要的信息。</p>
<p>.debug_aranges 是DWARF 中包含 debug info entry offset的 Section。<br>DWARF compile unit 是编译单元，在这里我们可以理解为文件或文件中的片段。也是DIE</p>
<h3 id="行号信息"><a href="#行号信息" class="headerlink" title="行号信息"></a>行号信息</h3><p>对于一个文件，我们将其编译后，其产出汇编代码类似于这种形式，在原始文件中的行对应着多条汇编指令。<br>对于行号的查找我们只需要 将符号的运行时地址转换为文件的虚拟地址，在该文件的行号信息中进行范围查找即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: <span class="keyword">int</span></span><br><span class="line"><span class="number">2</span>: main()</span><br><span class="line">    <span class="number">0x239</span>: push pb</span><br><span class="line">    <span class="number">0x23a</span>: mov  bp,sp</span><br><span class="line"><span class="number">3</span>:  &#123;</span><br><span class="line"><span class="number">4</span>:  <span class="built_in">printf</span>(“Omit needless words\n”);</span><br><span class="line">    <span class="number">0x23c</span>: mov  ax,<span class="number">0xaa</span></span><br><span class="line">    <span class="number">0x23f</span>: push ax</span><br><span class="line">    <span class="number">0x240</span>: call _printf</span><br><span class="line">    <span class="number">0x243</span>: pop  cx</span><br><span class="line"><span class="number">5</span>:  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="number">0x244</span>: xor  ax,ax</span><br><span class="line">    <span class="number">0x246</span>: push ax</span><br><span class="line">    <span class="number">0x247</span>: call _exit</span><br><span class="line">    <span class="number">0x24a</span>: pop  cx</span><br><span class="line"><span class="number">6</span>:  &#125;</span><br><span class="line">    <span class="number">0x24b</span>: pop  bp</span><br><span class="line">    <span class="number">0x24c</span>: ret</span><br><span class="line"><span class="number">7</span>:</span><br><span class="line">    <span class="number">0x24d</span>:</span><br></pre></td></tr></table></figure>

<p>对应的编码类似于: SPECIAL(n,m) 制定了行号增加和地址增加</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Opcode  Operand Byte <span class="built_in">Stream</span></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">DW_LNS_advance_pc LEB128(0x239) 0x2, 0xb9, 0x04</span><br><span class="line">SPECIAL(<span class="number">2</span>, <span class="number">0</span>)   <span class="number">0xb</span></span><br><span class="line">SPECIAL(<span class="number">2</span>, <span class="number">3</span>)   <span class="number">0x38</span></span><br><span class="line">SPECIAL(<span class="number">1</span>, <span class="number">8</span>)   <span class="number">0x82</span></span><br><span class="line">SPECIAL(<span class="number">1</span>, <span class="number">7</span>)   <span class="number">0x73</span></span><br><span class="line">DW_LNS_advance_pc   LEB128(2) 0x2, 0x2</span><br><span class="line">DW_LNE_end_sequence   <span class="number">0x0</span>, <span class="number">0x1</span>, <span class="number">0x1</span></span><br></pre></td></tr></table></figure>

<h2 id="利用symtab符号化"><a href="#利用symtab符号化" class="headerlink" title="利用symtab符号化"></a>利用symtab符号化</h2><p>当我们代码编译的时候，可以选择产生调试信息。也可以不产生调试信息，作为降级方案，我们仍可采用symbtab所包含的信息进行符号化。<br>symtab段我们可以提取到具体符号的地址，对应字符串表中的偏移地址，很容易就取到对应的符号名称。</p>
<p>具体可以参考各种实现，这里贴一段fishhook里的代码段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rebind_symbols_for_image</span><span class="params">(struct rebindings_entry *rebindings,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">const</span> struct mach_header *header,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">intptr_t</span> slide)</span> </span>&#123;</span><br><span class="line">  Dl_info info;</span><br><span class="line">  <span class="keyword">if</span> (dladdr(header, &amp;info) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"dli_fname:%s \ndli_sname:%s"</span>, info.dli_fname, info.dli_sname);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">segment_command_t</span> *cur_seg_cmd;</span><br><span class="line">  <span class="keyword">segment_command_t</span> *linkedit_segment = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">symtab_command</span>* <span class="title">symtab_cmd</span> = <span class="title">NULL</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dysymtab_command</span>* <span class="title">dysymtab_cmd</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">uintptr_t</span> cur = (<span class="keyword">uintptr_t</span>)header + <span class="keyword">sizeof</span>(<span class="keyword">mach_header_t</span>);</span><br><span class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123;</span><br><span class="line">    cur_seg_cmd = (<span class="keyword">segment_command_t</span> *)cur;</span><br><span class="line">    <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cur_seg_cmd-&gt;segname, SEG_LINKEDIT) == <span class="number">0</span>) &#123;</span><br><span class="line">        linkedit_segment = cur_seg_cmd;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SYMTAB) &#123;</span><br><span class="line">      symtab_cmd = (struct symtab_command*)cur_seg_cmd;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_DYSYMTAB) &#123;</span><br><span class="line">      dysymtab_cmd = (struct dysymtab_command*)cur_seg_cmd;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!symtab_cmd || !dysymtab_cmd || !linkedit_segment ||</span><br><span class="line">      !dysymtab_cmd-&gt;nindirectsyms) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find base symbol/string table addresses</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> linkedit_base = (<span class="keyword">uintptr_t</span>)slide + linkedit_segment-&gt;vmaddr - linkedit_segment-&gt;fileoff;</span><br><span class="line">  <span class="keyword">nlist_t</span> *symtab = (<span class="keyword">nlist_t</span> *)(linkedit_base + symtab_cmd-&gt;symoff);</span><br><span class="line">  <span class="keyword">char</span> *strtab = (<span class="keyword">char</span> *)(linkedit_base + symtab_cmd-&gt;stroff);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get indirect symbol table (array of uint32_t indices into symbol table)</span></span><br><span class="line">  <span class="keyword">uint32_t</span> *indirect_symtab = (<span class="keyword">uint32_t</span> *)(linkedit_base + dysymtab_cmd-&gt;indirectsymoff);</span><br><span class="line"></span><br><span class="line">  cur = (<span class="keyword">uintptr_t</span>)header + <span class="keyword">sizeof</span>(<span class="keyword">mach_header_t</span>);</span><br><span class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123;</span><br><span class="line">    cur_seg_cmd = (<span class="keyword">segment_command_t</span> *)cur;</span><br><span class="line">    <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cur_seg_cmd-&gt;segname, SEG_DATA) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">          <span class="built_in">strcmp</span>(cur_seg_cmd-&gt;segname, SEG_DATA_CONST) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; cur_seg_cmd-&gt;nsects; j++) &#123;</span><br><span class="line">        <span class="keyword">section_t</span> *sect =</span><br><span class="line">          (<span class="keyword">section_t</span> *)(cur + <span class="keyword">sizeof</span>(<span class="keyword">segment_command_t</span>)) + j;</span><br><span class="line">        <span class="keyword">if</span> ((sect-&gt;flags &amp; SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS) &#123;</span><br><span class="line">          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((sect-&gt;flags &amp; SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS) &#123;</span><br><span class="line">          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>符号化工具提供了 将函数地址 转化为 具体名称等信息的能力。但是提供大规模的符号化能力，需要在 网络I/O,缓存,Server端进一步的优化，这些优化我会写在内网Wiki上 hhhhh…</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>符号化仅是DWARF提供能力的冰山一角，作为提供给 lldb, gdb等调试器的文件格式，蕴含着大量的信息，也就是说，上传了DWARF文件，也相当于应用裸奔了…</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/30/dwarf%E5%92%8C%E7%AC%A6%E5%8F%B7%E5%8C%96/" data-id="ck6j1epl3000g63jggyet3e34" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CrashSymbolicateSystemDesign" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/16/CrashSymbolicateSystemDesign/" class="article-date">
  <time datetime="2018-09-16T14:36:27.000Z" itemprop="datePublished">2018-09-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/APM/">APM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/16/CrashSymbolicateSystemDesign/">APM Crash系统</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><img src="design.png" alt="design"></p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><ol>
<li>Crash/OOM/ANR 抓取</li>
<li>上报日志格式</li>
</ol>
<h3 id="Crash-OOM-卡顿-抓取"><a href="#Crash-OOM-卡顿-抓取" class="headerlink" title="Crash/OOM/卡顿 抓取"></a>Crash/OOM/卡顿 抓取</h3><p>这块技术有很多的开源方案，</p>
<p>Crash抓取有 KSCrash PLCrash…<br>OOM 可以参考腾讯的OOMDetector自己优化一下<br>ANR 可以参考很多方案，这里就不细说了</p>
<h3 id="日志上报格式"><a href="#日志上报格式" class="headerlink" title="日志上报格式"></a>日志上报格式</h3><p>上报的日志我认为最好兼容苹果的 symbolicatecrash 工具, 这就需要我们去理解 symbolicate 工作的原理，随后我们可以加上自己的内容，方便自己进行更多的功能扩展。</p>
<h4 id="symbolicatecrash-的原理"><a href="#symbolicatecrash-的原理" class="headerlink" title="symbolicatecrash 的原理"></a><strong>symbolicatecrash</strong> 的原理</h4><ol>
<li>解析头部信息是否符合规范</li>
<li>解析堆栈信息，符号表 信息</li>
<li>在文件中查找符号表的路径</li>
<li>根据堆栈信息去匹配相应符号表</li>
<li>使用atosl工具进行符号化</li>
<li>文本替换成符号化后的日志</li>
</ol>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><ol>
<li>符号化和解析服务</li>
<li>堆栈聚合服务</li>
<li>符号文件管理系统</li>
</ol>
<h3 id="符号化和解析服务"><a href="#符号化和解析服务" class="headerlink" title="符号化和解析服务"></a>符号化和解析服务</h3><p>我们可以把这块看成两个部分，1符号化，2解析服务</p>
<h4 id="符号化"><a href="#符号化" class="headerlink" title="符号化"></a>符号化</h4><p>符号化就是把地址翻译成对应的符号信息，比如说 把堆栈调用的地址 翻译成 调用方法的名称。<br>苹果给我们在 MacOS 下提供了 atosl 工具，可以帮助我们完成这部分工作。但是这个工具仅仅可以在MacOS 下工作，对于大规模的用户日志来说，依赖于MacOS系统不容易部署维护，费用也十分昂贵，因此我们需要在Linux下实现一个相等功能的工具。</p>
<h4 id="解析服务"><a href="#解析服务" class="headerlink" title="解析服务"></a>解析服务</h4><p>由于我们的日志是文本格式，我们需要提取其中的信息才可以将其用作符号化工具的输入，可以通过正则匹配的方式去处理这些信息。</p>
<h2 id="工具实现"><a href="#工具实现" class="headerlink" title="工具实现"></a>工具实现</h2><ol>
<li>Linux 平台下可用的符号化工具</li>
</ol>
<h3 id="Linux-平台下可用的符号化工具"><a href="#Linux-平台下可用的符号化工具" class="headerlink" title="Linux 平台下可用的符号化工具"></a>Linux 平台下可用的符号化工具</h3><p>总体来说，iOS符号化我们需要了解两部分知识， 1 Dwarf调试格式 2 Macho文件格式</p>
<h4 id="Dwarf调试格式"><a href="#Dwarf调试格式" class="headerlink" title="Dwarf调试格式"></a>Dwarf调试格式</h4><p>我们经常可以接触到的dsym文件是一个目录，其中包含了一个格式为Dwarf的调试信息文件。<br>调试信息是在编译器生成机器码的时候一起产生的。它代表着可执行程序和源代码之间的关系。这个信息以预定义的格式进行编码，并同机器码一起存储。<br>在DWARF里基本的描述项是调试信息项（DebuggingInformation Entry——DIE）。一个DIE有一个标签，它指明了这个DIE描述什么及一个填入了细节并进一步描述该项的属性列表。一个DIE（除了最顶层的）被一个父DIE包含（或者说拥有），并可能有兄弟DIE或子DIE。<br>通过提取Dwarf文件中的调试信息和对应的堆栈进行匹配，就可以解出一些符号信息，包含调用行号文件名称等信息。</p>
<h5 id="需要注意的一些知识点"><a href="#需要注意的一些知识点" class="headerlink" title="需要注意的一些知识点"></a>需要注意的一些知识点</h5><p><strong>DW_AT_abstract_origin， DW_AT_specification</strong></p>
<blockquote>
<p>A debugging information entry that represents a declaration that<br>completes another (earlier) non-defining declaration may have a<br>DW_AT_specification attribute whose value is a reference to the<br>debugging information entry representing the non-defining declaration.<br>A debugging information entry with a DW_AT_specification attribute<br>does not need to duplicate information provided by the debugging<br>information entry referenced by that specification attribute.<br>A DW_TAG_subprogram entry can contain a reference to a DW_AT_abstract_origin entry instead of &gt; duplicating the information. </p>
</blockquote>
<p>这意味着 我们需要针对 DW_AT_abstract_origin 进行特别处理</p>
<h4 id="Macho-文件格式"><a href="#Macho-文件格式" class="headerlink" title="Macho 文件格式"></a>Macho 文件格式</h4><p>上文中提到的符号文件，是Macho文件格式的。<br>Macho文件中包含 SymbolTable 可以提取出符号的名称，对于系统库和外部符号（例如你的静态库中的符号），我们可以从SymbolTable中提取符号名称。</p>
<h3 id="堆栈聚合服务"><a href="#堆栈聚合服务" class="headerlink" title="堆栈聚合服务"></a>堆栈聚合服务</h3><p>因为导致用户Crash的问题大多是相同的，导致用户Crash的堆栈存在许多相似和相等的情况，我们需要把同一类堆栈聚合在一起，协助平台用户高效的解决问题。</p>
<h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><p>接下来我会逐渐介绍这整套系统的设计和相关技术实现。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/16/CrashSymbolicateSystemDesign/" data-id="ck6j1epkl000263jgfjyvde1h" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-libmalloc" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/13/libmalloc/" class="article-date">
  <time datetime="2018-06-13T12:52:38.000Z" itemprop="datePublished">2018-06-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/APM/">APM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/13/libmalloc/">libmalloc &#34;malloc&#34; 探究</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前腾讯开源了 <a href="https://github.com/Tencent/OOMDetector" target="_blank" rel="noopener">OOMDetector</a> 用于监控内存分配，在集成到我司项目时, 修复了一些bug崩溃，优化了性能，在内存不是频繁分配的App上是有用武之地的。</p>
<p>OOMDetector 监控内存分配的核心处理 是通过 libmalloc库 中的 malloc_logger 指针实现的。</p>
<p>我之前一直疑惑 OOMDetector 的监控方式是否能够完善的监控到应用层面的<code>&quot;malloc&quot;</code>内存分配。这就有必要探究下应用层的内存分配API</p>
<h2 id="iOS-“malloc”-内存分配"><a href="#iOS-“malloc”-内存分配" class="headerlink" title="iOS “malloc” 内存分配"></a>iOS “malloc” 内存分配</h2><p>iOS上都通过kernel进行内存分配，将虚拟内存页映射到应用内存空间上。我们在应用层可以通过mmap实现这种内存分配。</p>
<p>不过大多数情况下我们都通过<strong>“malloc”</strong>进行内存分配, 我们可以使用malloc来获取内存，而不用每次都请求vmpage映射。而malloc分配的内存实质上都是从vmpage映射获取的。</p>
<p>你一定注意到了 <strong>“malloc”</strong>, 是的，它代表calloc, realloc, valloc, malloc_zone_malloc, malloc_zone_calloc, malloc_zone_valloc, malloc_zone_realloc, malloc_zone_batch_malloc 等方法，本质上他们的分配都应该被归于一类，都是利用 <code>scalable_zone</code> 进行分配的。</p>
<p>顺便提一下，C++ new的分配 其实现也是用 libc 中的 malloc 进行分配的<br><a href="http://gcc.gnu.org/viewcvs/gcc/trunk/libstdc++-v3/libsupc++/new_opnt.cc?view=markup" target="_blank" rel="noopener">new_opnt.cc</a></p>
<h3 id="libmalloc-分析"><a href="#libmalloc-分析" class="headerlink" title="libmalloc 分析"></a>libmalloc 分析</h3><h3 id="default-zone"><a href="#default-zone" class="headerlink" title="default_zone"></a>default_zone</h3><p>本着质疑的精神，一般我是不会相信空口无凭的文章的，因此，可以从<code>libmalloc</code>中找到答案。</p>
<p>首先找到 malloc, calloc等函数.. 的实现，因为原理类似，就不一一举出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line"><span class="built_in">malloc</span>(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span> *retval;</span><br><span class="line">	retval = malloc_zone_malloc(default_zone, <span class="built_in">size</span>);</span><br><span class="line">	<span class="keyword">if</span> (retval == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		errno = ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line"><span class="built_in">calloc</span>(<span class="keyword">size_t</span> num_items, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span> *retval;</span><br><span class="line">	retval = malloc_zone_calloc(default_zone, num_items, <span class="built_in">size</span>);</span><br><span class="line">	<span class="keyword">if</span> (retval == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		errno = ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先来看看这个 <code>default_zone</code> 是什么东西, 代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">malloc_zone_t</span> malloc_zone;</span><br><span class="line">	<span class="keyword">uint8_t</span> pad[PAGE_MAX_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">malloc_zone_t</span>)];</span><br><span class="line">&#125; <span class="keyword">virtual_default_zone_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">virtual_default_zone_t</span> virtual_default_zone</span><br><span class="line">__attribute__((section(<span class="string">"__DATA,__v_zone"</span>)))</span><br><span class="line">__attribute__((aligned(PAGE_MAX_SIZE))) = &#123;</span><br><span class="line">	<span class="literal">NULL</span>,</span><br><span class="line">	<span class="literal">NULL</span>,</span><br><span class="line">	default_zone_size,</span><br><span class="line">	default_zone_malloc,</span><br><span class="line">	default_zone_calloc,</span><br><span class="line">	default_zone_valloc,</span><br><span class="line">	default_zone_free,</span><br><span class="line">	default_zone_realloc,</span><br><span class="line">	default_zone_destroy,</span><br><span class="line">	DEFAULT_MALLOC_ZONE_STRING,</span><br><span class="line">	default_zone_batch_malloc,</span><br><span class="line">	default_zone_batch_free,</span><br><span class="line">	&amp;default_zone_introspect,</span><br><span class="line">	<span class="number">9</span>,</span><br><span class="line">	default_zone_memalign,</span><br><span class="line">	default_zone_free_definite_size,</span><br><span class="line">	default_zone_pressure_relief</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">malloc_zone_t</span> *default_zone = &amp;virtual_default_zone.malloc_zone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">default_zone_malloc(<span class="keyword">malloc_zone_t</span> *zone, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span><br><span class="line">&#123;</span><br><span class="line">	zone = runtime_default_zone();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> zone-&gt;<span class="built_in">malloc</span>(zone, <span class="built_in">size</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MALLOC_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">malloc_zone_t</span> *</span><br><span class="line">runtime_default_zone() &#123;</span><br><span class="line">	<span class="keyword">return</span> (lite_zone) ? lite_zone : inline_malloc_default_zone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>default_zone</code> 通过这种方式来初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">malloc_zone_t</span> *</span><br><span class="line">inline_malloc_default_zone(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	_malloc_initialize_once();</span><br><span class="line">	<span class="comment">// _malloc_printf(ASL_LEVEL_INFO, "In inline_malloc_default_zone with %d %d\n", malloc_num_zones, malloc_has_debug_zone);</span></span><br><span class="line">	<span class="keyword">return</span> malloc_zones[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>随后的调用如下</strong><br><code>_malloc_initialize</code> -&gt; <code>create_scalable_zone</code> -&gt; <code>create_scalable_szone</code> 最终我们创建了 szone_t 类型的对象，通过类型转换，得到了我们的 default_zone。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">malloc_zone_t</span> *</span><br><span class="line">create_scalable_zone(<span class="keyword">size_t</span> initial_size, <span class="keyword">unsigned</span> debug_flags) &#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">malloc_zone_t</span> *) create_scalable_szone(initial_size, debug_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="“malloc”"><a href="#“malloc”" class="headerlink" title="“malloc”"></a>“malloc”</h3><p>上文代码段中写道<code>malloc</code> 中调用了 <code>malloc_zone_malloc</code>, 看看malloc_zone_malloc 的实现是什么</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">malloc_zone_malloc(<span class="keyword">malloc_zone_t</span> *zone, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span><br><span class="line">&#123;</span><br><span class="line">	MALLOC_TRACE(TRACE_malloc | DBG_FUNC_START, (<span class="keyword">uintptr_t</span>)zone, <span class="built_in">size</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> *ptr;</span><br><span class="line">	<span class="keyword">if</span> (malloc_check_start &amp;&amp; (malloc_check_counter++ &gt;= malloc_check_start)) &#123;</span><br><span class="line">		internal_check();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">size</span> &gt; MALLOC_ABSOLUTE_MAX_SIZE) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ptr = zone-&gt;<span class="built_in">malloc</span>(zone, <span class="built_in">size</span>);		<span class="comment">// if lite zone is passed in then we still call the lite methods</span></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (malloc_logger) &#123;</span><br><span class="line">		malloc_logger(MALLOC_LOG_TYPE_ALLOCATE | MALLOC_LOG_TYPE_HAS_ZONE, (<span class="keyword">uintptr_t</span>)zone, (<span class="keyword">uintptr_t</span>)<span class="built_in">size</span>, <span class="number">0</span>, (<span class="keyword">uintptr_t</span>)ptr, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	MALLOC_TRACE(TRACE_malloc | DBG_FUNC_END, (<span class="keyword">uintptr_t</span>)zone, <span class="built_in">size</span>, (<span class="keyword">uintptr_t</span>)ptr, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其分配实现是 <code>zone-&gt;malloc</code> 根据之前的分析，就是szone_t结构体对象中对应的malloc实现。</p>
<p>在创建szone之后，做了一系列如下的初始化操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize the security token.</span></span><br><span class="line">szone-&gt;cookie = (<span class="keyword">uintptr_t</span>)malloc_entropy[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">szone-&gt;basic_zone.version = <span class="number">9</span>;</span><br><span class="line">szone-&gt;basic_zone.<span class="built_in">size</span> = (<span class="keyword">void</span> *)szone_size;</span><br><span class="line">szone-&gt;basic_zone.<span class="built_in">malloc</span> = (<span class="keyword">void</span> *)szone_malloc;</span><br><span class="line">szone-&gt;basic_zone.<span class="built_in">calloc</span> = (<span class="keyword">void</span> *)szone_calloc;</span><br><span class="line">szone-&gt;basic_zone.valloc = (<span class="keyword">void</span> *)szone_valloc;</span><br><span class="line">szone-&gt;basic_zone.<span class="built_in">free</span> = (<span class="keyword">void</span> *)szone_free;</span><br><span class="line">szone-&gt;basic_zone.<span class="built_in">realloc</span> = (<span class="keyword">void</span> *)szone_realloc;</span><br><span class="line">szone-&gt;basic_zone.destroy = (<span class="keyword">void</span> *)szone_destroy;</span><br><span class="line">szone-&gt;basic_zone.batch_malloc = (<span class="keyword">void</span> *)szone_batch_malloc;</span><br><span class="line">szone-&gt;basic_zone.batch_free = (<span class="keyword">void</span> *)szone_batch_free;</span><br><span class="line">szone-&gt;basic_zone.introspect = (struct <span class="keyword">malloc_introspection_t</span> *)&amp;szone_introspect;</span><br><span class="line">szone-&gt;basic_zone.memalign = (<span class="keyword">void</span> *)szone_memalign;</span><br><span class="line">szone-&gt;basic_zone.free_definite_size = (<span class="keyword">void</span> *)szone_free_definite_size;</span><br><span class="line">szone-&gt;basic_zone.pressure_relief = (<span class="keyword">void</span> *)szone_pressure_relief;</span><br></pre></td></tr></table></figure>

<p>在magazine_malloc.c有着对应的实现。</p>
<h3 id="malloc-logger"><a href="#malloc-logger" class="headerlink" title="malloc_logger"></a>malloc_logger</h3><p>malloc_logger 在 libmalloc 中的以下方法内被调用 <code>malloc_zone_malloc</code> <code>malloc_zone_calloc</code> <code>malloc_zone_valloc</code> <code>malloc_zone_realloc</code> <code>malloc_zone_free</code> <code>malloc_zone_free_definite_size</code> <code>malloc_zone_memalign</code> 等函数中被调用，我们 “malloc” 系列的方法都会调用到这些函数 </p>
<p>如果你使用 malloc_logger 回调，那么 “malloc” 分配你都可以监控到. OOMDetector 中也针对不同的分配做了不同的处理。因此使用malloc_logger回调是可以监控到 “malloc”分配的，验证了文章开头的猜测。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以malloc_logger为线索，探究了一下libmalloc的源码，确定了OOMDetector的原理。当然最重要的是建立对 iOS 内存分配的整体理解。 本文只写了对”malloc”内存分配的理解，以后有时间，会写一下 XNU内存管理相关的文章。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/13/libmalloc/" data-id="ck6j1eplj001f63jgc7rrhlxh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-dependency" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/dependency/" class="article-date">
  <time datetime="2018-04-13T05:08:46.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/">设计架构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/dependency/">关于架构和编码的思考</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>长期更新，记录我对设计架构的理解</strong></p>
<h2 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h2><p>A,B,C三个组件，如果可以互相调用，则ABC互相依赖。在大型项目中，这种会造成组件间耦合紧密的问题。</p>
<h2 id="思考一下，组件间调用的本质"><a href="#思考一下，组件间调用的本质" class="headerlink" title="思考一下，组件间调用的本质"></a>思考一下，组件间调用的本质</h2><ol>
<li>有组件的实例</li>
<li>接口</li>
</ol>
<p><strong>拥有组件的实例</strong>，我们直接拥有另一个组件，这显然是依赖的。</p>
<p><strong>如何在尽量减少依赖的情况下解决这些问题呢？</strong></p>
<ol>
<li>可以通过反射的方式, 需要建立 {组件}&lt;-&gt;{字符串} 的映射表，把关系转移到了配置文件中，这种方式存在安全性问题，因为没有编译器的强类型检查。</li>
<li>建立映射关系。我们可以 建立Class和某种物件的映射， 因为有protocol的存在，接口的问题被解决了。于是建立Class和Protocol的映射，可以获得实例的同时也知晓接口。这就构成了一个组件调用的基础条件。并且我们需要一个manager替我们管理映射。</li>
</ol>
<p>在2中，依赖关系变成了如下<br>{组件}-&gt;{manager}-&gt;{interface}</p>
<p>组件的耦合转移到了组件和interface的耦合。这在工程维护中存在一个问题，我们需要维护一个庞大的protocol列表。不过相比于组件间相互依赖，这种做法好了很多。</p>
<h3 id="接口类映射-和-反射-的选择"><a href="#接口类映射-和-反射-的选择" class="headerlink" title="接口类映射 和 反射 的选择"></a>接口类映射 和 反射 的选择</h3><p>我个人愿意维护protocols，而不是维护组件字符串映射表。 从逻辑上说，无法实现双方相互隐藏。这无非是 “关系” 的体现方式不同。我选择程序内的映射关系，有编译器检查。</p>
<h2 id="依赖倒置"><a href="#依赖倒置" class="headerlink" title="依赖倒置"></a>依赖倒置</h2><p>传统的过程性系统的设计方法倾向于使高层次的模块依赖于低层次的模块，抽象层次依赖于具体层次。<br>而依赖倒置则将{高层次模块，低层次模块}-&gt;{抽象接口}，这样无论上层还是下层的整个模块出现了替换，只要接口不变化，就不需要修改另一层次的模块。</p>
<p><strong>这里值得注意的是，低层次模块依赖了高层次模块中定义的接口。当我们把低层次模块拆分后，将其用于别的项目时，会出现问题。对此我的想法是：</strong></p>
<ol>
<li>如果高层次模块需要和底层次模块完全隔离，方便的替换整个低层次模块的实现，那么使用依赖倒置。</li>
<li>如果没有1中的需求，那么还是直接依赖低层次模块，我认为低层次模块本身的接口暴露合理，内部实现的改动也不会对高层次模块有什么影响。</li>
</ol>
<h3 id="采用接口的成本"><a href="#采用接口的成本" class="headerlink" title="采用接口的成本"></a>采用接口的成本</h3><ol>
<li>接口定义，接口维护，遵循类维护</li>
<li>如果暴露了一些定义的数据结构、类，则这些也需要抽象。会造成很多重复的代码。<br>我觉得还是尽量只在必要情况下使用接口，</li>
</ol>
<ul>
<li>足够底层的类，可以放到核心库中。让所有模块都依赖呗。</li>
<li>接口适用于 同级别模块间的服务交互</li>
</ul>
<h3 id="包装一下"><a href="#包装一下" class="headerlink" title="包装一下"></a>包装一下</h3><p>我们使用高层模块时，其实就是构造一个符合接口的东西而已。<br>底层模块A去遵循高层模块的协议，无疑让底层模块无法复用。这时候我们可以再新建一个类C，让C去遵循协议，C通过A来构建自己。</p>
<h2 id="单一职责和关注点分离原则"><a href="#单一职责和关注点分离原则" class="headerlink" title="单一职责和关注点分离原则"></a>单一职责和关注点分离原则</h2><p><strong>关注点分离</strong>要求每一个功能对应一个单独的任务，每一个功能都要在一个独立的模块中实现。每个模块都有自己的职责，而不会关注其他模块的职责。如果一个类包含多个职责，要求改其中的一个职责，则可能会影响该类里其他职责的实现。<br><strong>单一职责原则</strong>要求每个类只包含一个职责，所有方法都应该为了实现该职责。要修改一个类的职责，只涉及该类。</p>
<h3 id="例子：Record和Log写在一起？"><a href="#例子：Record和Log写在一起？" class="headerlink" title="例子：Record和Log写在一起？"></a>例子：Record和Log写在一起？</h3><p>场景：Record模块，存储了Crash的信息。我们需要生成某种格式的日志。Record把生成日志的代码通过分类实现。<br>这里通过category的实现，方便，不会引入单独的类。把格式化生成log的职责放在了record模块里。但是Log是个改动频繁的功能，兼具有相当多的扩展性(多种格式..)。仅是log当做Record的一个功能，职责和灵活性都说不过去。Record应<strong>仅关注信息的记录</strong>。把Log当做另一个同等级模块来看待。</p>
<p>做法1：把Log和Record拆分为同等级的模块，Log模块依赖于Record,生成相应的日志。<br>这里纠正一个错误，有同学说，既然存在依赖，那就用分类好了不需要拆分。<strong>模块拆分和依赖无关，关注的是职责分离和粒度控制，是通过现在情况和未来发展做出的判断。</strong></p>
<p><strong>从框架开发的角度来看</strong>，Record和Log都是独立的模块，不能互相依赖。Log模块需要元数据，我们可以定义Info协议，Log依赖Info协议。当需要生成log时，我们构造一个遵循Info协议的类RecordInfo，给Log使用即可。多了一层中间层，但是把 Record和Log隔离出来，两者都可以复用。 <strong>维护成本由 Log和Record 的使用者承担。</strong>这是做的很干净的写法，适用于需要复用的情况，如果仅仅把Log用在固定的场景，那么直接依赖元数据类也是可以的。</p>
<h2 id="策略控制"><a href="#策略控制" class="headerlink" title="策略控制"></a>策略控制</h2><p>现在对于 某个功能 有一个实现A， 此时，在A的实现的基础上出现了另一种分支，达到B的效果。</p>
<p>在A的代码中，修改逻辑是常用的做法，借此实现AB功能。<br>但这样破坏了原有的功能，使得逻辑日渐复杂。我认为相对合理的做法是，将AB的共同逻辑抽取，差异逻辑分开。如果实现代码很多，可以拆分成两个策略类。关于<code>func</code>还是<code>strategy class</code>可以根据代码量和复杂程度来权衡。</p>
<p>软件开发中是无法避免依赖的，我们可以把相关的逻辑放在类中，也可以放在函数中。我认为这本质上是一样的。粒度是开发过程中需要考虑的问题。合理的设计出最适用用与当下的框架，不过度设计。要知道我们无法从根本上改变软件逐渐增大的复杂度，我们能做的是改变自己的编码方式，将逻辑写的合理清晰就好了。</p>
<h2 id="创建模式的思考"><a href="#创建模式的思考" class="headerlink" title="创建模式的思考"></a>创建模式的思考</h2><ol>
<li>工厂模式 生产一类物品</li>
<li>抽象工厂模式 生产多类物品</li>
<li>生成器模式 构造复杂的产品</li>
</ol>
<p>工厂模式将实现代码与暴露的接口隔离。抽象工厂模式在工厂模式的基础上将多种工厂的能力统一暴露。生成器模式关注于复杂对象的步骤生成。</p>
<p>创建模式都将实现与产品隔离。生成器模式相较于抽象工厂模式，在对象的生成中更加细化，将生成的对象各个步骤隔离，各个步骤可以组合。而抽象工厂模式适用于简单的对象生成。</p>
<p><strong>我认为，本质上，创建者模式，通过依赖注入，以统一的接口分发不同的实现。可以根据实际情况，根据复杂度选择合适的做法。</strong></p>
<h2 id="契约式设计"><a href="#契约式设计" class="headerlink" title="契约式设计"></a>契约式设计</h2><p>DbC的核心思想是对软件系统中的元素之间相互合作以及“责任”与“义务”的比喻。这种比喻从商业活动中“客户”与“供应商”达成“契约”而得来。例如：</p>
<ul>
<li>供应商必须提供某种产品（责任），并且他有权期望客户已经付款（权利）。</li>
<li>客户必须付款（责任），并且有权得到产品（权利）。</li>
<li>契约双方必须履行那些对所有契约都有效的责任，如法律和规定等。</li>
</ul>
<p>同样的，如果在面向对象程序设计中一个类的函数提供了某种功能，那么它要：</p>
<ul>
<li>期望所有调用它的客户模块都保证一定的进入条件：这就是函数的先验条件—客户的义务和供应商的权利，这样它就不用去处理不满足先验条件的情况。</li>
<li>保证退出时给出特定的属性：这就是函数的后验条件—供应商的义务，显然也是客户的权利。</li>
<li>在进入时假定，并在退出时保持一些特定的属性：不变条件。</li>
</ul>
<h3 id="调用方和被调用方相互负责的看法"><a href="#调用方和被调用方相互负责的看法" class="headerlink" title="调用方和被调用方相互负责的看法"></a>调用方和被调用方相互负责的看法</h3><p>在写code中经常会遇到 不知道一些guard 条件到底写在哪好。<br>写在调用方，逻辑清晰一些。写在被调用方，可以减少代码冗余。</p>
<p>我个人觉得这样的写法比较合适:</p>
<ol>
<li>调用者体内会被改变的状态，在调用者做校验。</li>
<li>被调用者处理上下文的一些信息。</li>
<li>当被调用者的guard逻辑重复多次，考虑将判断逻辑抽象成函数。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/13/dependency/" data-id="ck6j1eplc000z63jg46gfd0zb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iosoom" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/10/iosoom/" class="article-date">
  <time datetime="2018-04-10T12:30:35.000Z" itemprop="datePublished">2018-04-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/APM/">APM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/10/iosoom/">iOS OOM</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近在做oom,简单的总结下相关知识</p>
<p><strong>Out Of Memory 是 Jetsam同过响应压力通知杀掉优先级内消耗内存太多的进程, 导致应用闪退的一种现象，难于捕获和分析。</strong></p>
<h2 id="技术点："><a href="#技术点：" class="headerlink" title="技术点："></a>技术点：</h2><pre><code>1. iOS 内存分配系统的实现
2. 如何抓到回调与如何监控
3. 数据结构设计
4. iOS abort机制
5. OOM事件捕获</code></pre><h2 id="iOS内存分配系统的实现（用户层级）"><a href="#iOS内存分配系统的实现（用户层级）" class="headerlink" title="iOS内存分配系统的实现（用户层级）"></a>iOS内存分配系统的实现（用户层级）</h2><p>iOS中，内存堆分配的基本控制者是 malloc_zone, 通常是default_zone. 实际上是一个 scallable zone. 我们的通过malloc 分配的内存都是 通过Zone中的空闲内存块链表中获取的. 实际上Zone 从VMPage获取4k对齐的内存(mvm_allocate_pages). 然后再分给我们小块的，效率高，我们通过malloc分配内存，就不必每次都需要申请vmpages. malloc 内存申请分为 tiny, small, large… </p>
<h3 id="虚拟内存分配相关的知识："><a href="#虚拟内存分配相关的知识：" class="headerlink" title="虚拟内存分配相关的知识："></a>虚拟内存分配相关的知识：</h3><p>vm_map, vm_map_entry, vm_object, vm_page, vm_object, vm_page<br>对虚拟内存页面的调用都在bsd/kern/kern_mman.c中实现。</p>
<h3 id="物理内存-pmap…"><a href="#物理内存-pmap…" class="headerlink" title="物理内存: pmap…"></a>物理内存: pmap…</h3><h2 id="iOS-abort-机制"><a href="#iOS-abort-机制" class="headerlink" title="iOS abort 机制"></a>iOS abort 机制</h2><h3 id="Pageout"><a href="#Pageout" class="headerlink" title="Pageout"></a>Pageout</h3><p>管理页面交换的策略，判断哪些页面需要写回到其后备存储。<br>垃圾回收线程 (vm_pageout_grabage_collect())  调用 consider_pressure_events -&gt; vm_dispatch_memory_pressure() -&gt; BSD -&gt; NOTE_VM_PRESSURE-&gt; 响应压力通知<br>如果进程并不是总能找到可以抛弃的内存，当这种协作方法失败时，Jetsam机制介入。</p>
<h3 id="Jetsam"><a href="#Jetsam" class="headerlink" title="Jetsam"></a>Jetsam</h3><p>通过响应压力通知杀掉优先级内消耗内存太多的进程。<br>BSD层起了一个内核优先级最高的线程VM_memorystatus，这个线程会在维护两个列表，一个是我们之前提到的基于进程优先级的进程列表，还有一个是所谓的内存快照列表，即保存了每个进程消耗的内存页memorystatus_jetsam_snapshot。<br>这个常驻线程接受从内核对于内存的守护程序pageout通过内核调用给每个App进程发送的内存压力通知，来处理事件，这个事件转发成上层的UI事件就是平常我们会收到的全局内存警告或者每个ViewController里面的didReceiveMemoryWarning。</p>
<h4 id="杀的类别"><a href="#杀的类别" class="headerlink" title="杀的类别"></a>杀的类别</h4><p>读了一下源码，发现 杀的机制有如下两种，他们大致的执行流程如下</p>
<p><strong>highwater 的处理 -&gt; 我们App占用的内存不要超过限制</strong><br>    1. 从优先级列表里循环寻找线程<br>    2. 判断是否满足p_memstat_memlimit的限制条件<br>    3. DiagnoseActive, FREEZE过滤<br>    4. 杀进程，杀到了exit, 否则继续循环</p>
<p><strong>memorystatus_act_aggressive处理 -&gt; 内存占用高按优先级杀</strong><br>    1. 根据policy加载 jld_bucket_count， 用来判断是否开杀<br>    2. 从JETSAM_PRIORITY_ELEVATED_INACTIVE 开始杀<br>    3. jld_bucket_count 和 memorystatus_jld_eval_period_msecs 判断是否开杀<br>    4. 根据优先级从低向高杀，直到memorystatus_avail_pages_below_pressure</p>
<h4 id="触发入口"><a href="#触发入口" class="headerlink" title="触发入口"></a>触发入口</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># static boolean_t</span></span><br><span class="line">memorystatus_action_needed(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_EMBEDDED</span></span><br><span class="line">    <span class="keyword">return</span> (is_reason_thrashing(kill_under_pressure_cause) ||</span><br><span class="line">            is_reason_zone_map_exhaustion(kill_under_pressure_cause) ||</span><br><span class="line">           memorystatus_available_pages &lt;= memorystatus_available_pages_pressure);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* CONFIG_EMBEDDED */</span></span></span><br><span class="line">    <span class="keyword">return</span> (is_reason_thrashing(kill_under_pressure_cause) ||</span><br><span class="line">            is_reason_zone_map_exhaustion(kill_under_pressure_cause));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_EMBEDDED */</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>针对这种情况我们可以</strong></p>
<p>memorystatus_action_needed 判断 -&gt; 规避Jetsam处理<br>    1. 是否因为thrashing(如果是EMBEDED则不会触发这种情况)<br>    2. 是否因为zone_map_exhaustion(判断Zone的消耗情况, vm_map 相关参数来做，感觉这个意义不大)<br>    3. 是否因为memorystatus_available_pages &lt;= memorystatus_available_pages_pressure(是否是EMBEDDED)(根据物理内存page占比计算得到) -&gt; boot_arguments…能取到(外部拿不到，只能走内核调试拿.. )</p>
<h3 id="watchdog"><a href="#watchdog" class="headerlink" title="watchdog"></a>watchdog</h3><p>为了避免应用陷入错误状态导致界面无响应，Apple 设计了看门狗 (WatchDog) 机制。一旦超时，强制杀死进程。在不同的生命周期，触发看门狗机制的超时时间有所不同：</p>
<table>
<thead>
<tr>
<th>生命周期</th>
<th>超时时间</th>
</tr>
</thead>
<tbody><tr>
<td>启动 Launch</td>
<td>20 s</td>
</tr>
<tr>
<td>恢复 Resume</td>
<td>10 s</td>
</tr>
<tr>
<td>悬挂 Suspend</td>
<td>10 s</td>
</tr>
<tr>
<td>退出 Quit</td>
<td>6 s</td>
</tr>
<tr>
<td>后台 Background</td>
<td>10 min</td>
</tr>
</tbody></table>
<h3 id="如何抓到回调与如何监控"><a href="#如何抓到回调与如何监控" class="headerlink" title="如何抓到回调与如何监控"></a>如何抓到回调与如何监控</h3><p><strong>抓到</strong>：libmalloc 中的 malloc_logger 函数指针。通过这个可以抓到所有malloc类分配。<br>vm 则可以根据hook或者私有变量，和 malloc_logger一致。</p>
<p><strong>监控</strong>: 每次抓到都获取调用栈，存储进自己定义的数据结构中。  这里为什么不会循环调用需要值得注意一下。是通过不同的逻辑分支，保证不会走到相同的带分配的逻辑分支。</p>
<h3 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h3><pre><code>1. 空间占用
2. 访问速度
3. 细节存储优化</code></pre><h3 id="OOM事件捕获"><a href="#OOM事件捕获" class="headerlink" title="OOM事件捕获"></a>OOM事件捕获</h3><ol>
<li>现有方案，排除法</li>
<li>存在的问题 applicationstate不准等</li>
<li>经验值+ANR 优化</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/10/iosoom/" data-id="ck6j1eplg001963jg8j8wej83" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-sharedlibraryandpic" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/15/sharedlibraryandpic/" class="article-date">
  <time datetime="2018-01-14T16:35:39.000Z" itemprop="datePublished">2018-01-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Hook/">Hook</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/15/sharedlibraryandpic/">fishhook与共享库和PIC</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>fishhook是不能hook同一个library内的符号调用的，在某个issus的解答如下。</p>
<blockquote>
<p>People have had issues with socket and/or connect in the past. One problem is that fishhook can only hook external calls, which means function calls within the same library generally cannot be hooked. In this case, calls to socket and connect from within the same library (libSystem) cannot be hooked. With the simulator, the system libraries are broken out into many sub-libraries, including libsystem_networking. With many sub-libraries, this means function calls from one sub-library to another can be hooked on the simulator, but on device where there’s just a single libSystem, those same calls are within the same library and cannot be hooked.</p>
</blockquote>
<p>这是由于fishhook利用 Macho-O dyld link 的 dynamically rebinding symbols实现所导致的。</p>
<p>这边文章就围绕这个话题来展开，解释一下la_symbol_ptr存在的原因。由于Mac OS 上使用 stubs, la_symbol_ptrs, stub_helper来实现延迟绑定的原理和Linux ELF差不多，这里就使用ELF的实现来解释。</p>
<h2 id="PIC位置无关代码的引入"><a href="#PIC位置无关代码的引入" class="headerlink" title="PIC位置无关代码的引入"></a>PIC位置无关代码的引入</h2><p>设想一个场景，因为Linux/Mac os使用的是虚拟内存系统，这意味着共享库引用的外部符号地址在不同进程的虚拟内存中是不同的，对应到物理内存中TEXT段也不同，所以必须拷贝多份。这显然是不可以接受的，内存中存在了大量拷贝，浪费RAM资源。</p>
<p>如果我们共享库对外部引用是位置无关的就好了，就不会存在这个问题。</p>
<h3 id="GOT-全局偏移表"><a href="#GOT-全局偏移表" class="headerlink" title="GOT 全局偏移表"></a>GOT 全局偏移表</h3><p>这时利用DATA段读写的特性，DATA段会在内存中有多份拷贝，并且DATA段和TEXT段的距离不变，在DATA段存储变化的地址，TEXT段使用指向DATA段对应位置的引用。这就解决了TEXT段共享的问题。这里我们引入了一个全局偏移量表，GOT。动态链接器会重定位GOT中的每个条目，使得它包含正确的绝对地址。</p>
<h3 id="PIC函数调用-和-PLT过程链接表"><a href="#PIC函数调用-和-PLT过程链接表" class="headerlink" title="PIC函数调用 和 PLT过程链接表"></a>PIC函数调用 和 PLT过程链接表</h3><p>使用GOT这种方式，我们每次调用函数都需要额外的三条指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">        call L1</span><br><span class="line">L1:   popl %ebx </span><br><span class="line">        addl $PROCOFF, %ebx</span><br><span class="line">        call *(%ebx)</span><br></pre></td></tr></table></figure>
<ol>
<li>将PC的值移到 ebx中</li>
<li>ebx 指向GOT中适当的条目</li>
</ol>
<p>这样的效率未免有些低。于是引入了 延迟绑定的技术，将过程地址的绑定推迟到第一次调用该过程时。第一次调用过程的运行时开销很大，但是其后的每次调用都只会花费一条指令和一个间接地存储器引用。</p>
<p><strong>过程</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call 8048464</span><br></pre></td></tr></table></figure>
<p>调用相应的PLT条目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jmp *0x8049684</span><br><span class="line">pushl $0x8</span><br><span class="line">jmp 8048444</span><br></pre></td></tr></table></figure>
<p>跳转到addvec</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/15/sharedlibraryandpic/" data-id="ck6j1epln001q63jg7hot073k" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/APM/">APM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hook/">Hook</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A0%94%E5%8F%91%E6%B5%81%E7%A8%8B/">研发流程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/">设计架构</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/02/12/iosdevdebug/">iOS开发必备的问题定位调试技巧</a>
          </li>
        
          <li>
            <a href="/2019/11/26/projectpodenv/">CocoaPods插件开发原理(二) 定制项目CocoaPods插件环境</a>
          </li>
        
          <li>
            <a href="/2019/10/05/cocoapodsdev/">CocoaPods插件开发原理(一) CocoaPods做了啥</a>
          </li>
        
          <li>
            <a href="/2019/09/28/CrashMonitorSystem/">崩溃捕获系统的原理（一）异常信号</a>
          </li>
        
          <li>
            <a href="/2018/09/30/dwarf%E5%92%8C%E7%AC%A6%E5%8F%B7%E5%8C%96/">DWARF和符号化</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 junyixie<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>