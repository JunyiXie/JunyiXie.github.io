{"pages":[{"title":"关于","text":"曾经专注过 iOS 开发 APM 移动高可用系统 Devops 热修复 现在专注于 端智能 Python虚拟机 曾经在 字节跳动 阿里巴巴工作过 现在就职于 字节跳动工作 如果你对 移动端开发 C++,C开发 人工智能 推理引擎 虚拟机 移动高可用系统 跨平台研发框架 热修复系统 基础组件 移动研发体系 … 感兴趣，请联系我 微信/邮箱，我们 北上深航 移动端/前端/后端 多个岗位均在招贤纳士 xie.junyi@outlook.com","link":"/about/index.html"},{"title":"Friend Links","text":"Lision","link":"/friends/index.html"},{"title":"project","text":"project: type: personalname: XJYCharturl: https://github.com/junyixie/xjychartintro: iOS Platform Chart type: Companyname: Tusourl: https://itunes.apple.com/cn/app/tu-shuo-tuso/id1019431091?mt=8intro: Tuso app. live photo and filter","link":"/project/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Aspects 源码分析","text":"简介Aspects是一个面向切面编程的库。如果想深入了解iOS Runtime中的消息发送机制，Aspects的源码是值得分析的。 项目主页Aspects 核心实现Aspects的核心实现就是利用Runtime中的消息分发机制： Aspects通过把selector的方法替换为msg_forward方法转发 转而调用 forwardInvocation（forwardInvocation的实现被Aspects替换，将原来的方法实现与添加的实现组合在了一起） 核心源码分析这是Aspects 面向切面编程的入口方法 123456- (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error { return aspect_add(self, selector, options, block, error);} 这段代码可以分三部分来看 aspect_isSelectorAllowedAndTrack 这个方法 对父子类同时hook一个方法进行了一些限制 aspect_getContainerForObject 通过Runtime添加关联值的方式 管理hook的方法 aspect_prepareClassAndHookSelector 这是核心的实现，涉及到动态生成子类，改变isa指针的指向，改变方法的实现 一系列操作 能否Hook 判断aspect_isSelectorAllowedAndTrack 中会判断方法能否被hook 12345678910// 判断当前这个类有没有曾经hock 过方法AspectTracker *tracker = swizzledClassesDict[currentClass];if ([tracker subclassHasHookedSelectorName:selectorName]) { NSSet *subclassTracker = [tracker subclassTrackersHookingSelectorName:selectorName]; NSSet *subclassNames = [subclassTracker valueForKey:@\"trackedClassName\"]; NSString *errorDescription = [NSString stringWithFormat:@\"Error: %@ already hooked subclasses: %@. A method can only be hooked once per class hierarchy.\", selectorName, subclassNames]; AspectError(AspectErrorSelectorAlreadyHookedInClassHierarchy, errorDescription); return NO;} 举个例子比如说:UIView hook 了 initWithFrame: 为 method1UIButton hook 了 initWithFrame: 为 method1 UIButton 调用 initWithFrame: 时 是 method1 ，method1 中的实现会 调用[super initWithFrame:] ，而[super initWithFrame:] 是 method1 这就造成了循环引用 最近发现了一片文章提供了解决重复hook的解决方案,阿里星牛逼！ 基于桥的全量方法Hook方案 - 探究苹果主线程检查实现 管理hook12345678910111213141516171819202122232425static id aspect_add(id self, SEL selector, AspectOptions options, id block, NSError **error) { NSCParameterAssert(self); NSCParameterAssert(selector); NSCParameterAssert(block); __block AspectIdentifier *identifier = nil; aspect_performLocked(^{ if (aspect_isSelectorAllowedAndTrack(self, selector, options, error)) { //一个实例 只有一个container //这是区分实例对象和类对象的关键 //实例对象可以有很多个，但是同一个类的类对象只能有一个 AspectsContainer *aspectContainer = aspect_getContainerForObject(self, selector); //原来的selector block identifier = [AspectIdentifier identifierWithSelector:selector object:self options:options block:block error:error]; if (identifier) { //container 里 存有 identifier (selector,block) [aspectContainer addAspect:identifier withOptions:options]; // Modify the class to allow message interception. aspect_prepareClassAndHookSelector(self, selector, error); } } }); return identifier;} 动态生成子类，改变isa指针 aspect_prepareClassAndHookSelector这是核心的实现，涉及到动态生成子类，改变isa指针，改变方法的实现 一系列操作 1234567891011121314151617181920212223static void aspect_prepareClassAndHookSelector(NSObject *self, SEL selector, NSError **error) { NSCParameterAssert(selector); //动态创建子类，改变forwardInvocation方法的实现 Class klass = aspect_hookClass(self, error); Method targetMethod = class_getInstanceMethod(klass, selector); IMP targetMethodIMP = method_getImplementation(targetMethod); if (!aspect_isMsgForwardIMP(targetMethodIMP)) { // Make a method alias for the existing method implementation, it not already copied. const char *typeEncoding = method_getTypeEncoding(targetMethod); SEL aliasSelector = aspect_aliasForSelector(selector); if (![klass instancesRespondToSelector:aliasSelector]) { //子类的aliasSelector的实现为 当前类的selector __unused BOOL addedAlias = class_addMethod(klass, aliasSelector, method_getImplementation(targetMethod), typeEncoding); NSCAssert(addedAlias, @\"Original implementation for %@ is already copied to %@ on %@\", NSStringFromSelector(selector), NSStringFromSelector(aliasSelector), klass); } //selector方法替换为_objc_msgForward // We use forwardInvocation to hook in. class_replaceMethod(klass, selector, aspect_getMsgForwardIMP(self, selector), typeEncoding); AspectLog(@\"Aspects: Installed hook for -[%@ %@].\", klass, NSStringFromSelector(selector)); }} 这个写法有点像KVO的实现。动态生成子类，hook子类的forwardInvocation方法，并且将isa指针指向subclass, 这种写法对于使用者，没有什么影响，可以当成原来的对象使用，Swizzling子类的方法，避免了去改变对象的类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#pragma mark - Hook Classstatic Class aspect_hookClass(NSObject *self, NSError **error) { NSCParameterAssert(self); //这里可以思考一下 class 方法 和 isa 的区别 //[self class] KVO可能改变了isa指针的指向 Class statedClass = self.class; // object_getClass 能准确的找到isa指针 Class baseClass = object_getClass(self); NSString *className = NSStringFromClass(baseClass); // Already subclassed //如果已经子类化了 就返回 if ([className hasSuffix:AspectsSubclassSuffix]) { return baseClass; //如果是类 就改掉类的forwardInvocation 而不是一个子类对象 // We swizzle a class object, not a single object. }else if (class_isMetaClass(baseClass)) { return aspect_swizzleClassInPlace((Class)self); //考虑到KVO,KVO的底层实现,交换了isa指针 // Probably a KVO'ed class. Swizzle in place. Also swizzle meta classes in place. }else if (statedClass != baseClass) { return aspect_swizzleClassInPlace(baseClass); } // Default case. Create dynamic subclass. const char *subclassName = [className stringByAppendingString:AspectsSubclassSuffix].UTF8String; Class subclass = objc_getClass(subclassName); if (subclass == nil) { // 通过创建新子类的方式 subclass = objc_allocateClassPair(baseClass, subclassName, 0); if (subclass == nil) { NSString *errrorDesc = [NSString stringWithFormat:@\"objc_allocateClassPair failed to allocate class %s.\", subclassName]; AspectError(AspectErrorFailedToAllocateClassPair, errrorDesc); return nil; } // forwardInvocation 替换成 (IMP)_ASPECTS_ARE_BEING_CALLED__ aspect_swizzleForwardInvocation(subclass); //子类的class方法返回当前被hook的对象的class aspect_hookedGetClass(subclass, statedClass); aspect_hookedGetClass(object_getClass(subclass), statedClass); objc_registerClassPair(subclass); } //将当前self设置为子类，这里其实只是更改了self的isa指针而已, 这里hook了子类的forwardInvocation方法，再次使用当前类时，其实是使用了子类的forwardInvocation方法。 object_setClass(self, subclass); return subclass;} Hook 方式解析目的是：大量的给目的方法打桩 , 打桩的代码相同 思路：传统hook , 直接创建一个新的方法，调用原来的方法，添加代码这样，如果如果要hook 大量的方法，则需要很多method定义 既然我们要给方法添加自己的实现， 等价于 调用方法之前/之后添加实现。 那么我们必须要找到方法是如何调用的 1. 通过符号表直接查找对应符号的IMP 2. objc_msgsend + resolveInstance... + forwordtarger... + forwardInvocation... 走objc_msgsend 必然会调用三个方法之一resolveInstance.,forwordtarger 拿不到原来方法的target 和 sel ,无法调用原来的实现 forwardInvocation 中的invocation 有target和sel，hook 这个方法，然后添加自己的实现，调用原来的方法 然后如何让方法每次都走objc_msgsend呢？把原来的 sel的IMP改成objc_msgsend. 12IMP msgForwardIMP = _objc_msgForward;class_replaceMethod(cls, originSelector, msgForwardIMP, originTypes); 这时我们需要保存原来的 IMP 然后hook forwardInvocation … 换成自己的实现，调用原来的IMP和新增的代码 然后… 还要注意 如果真的需要 forwardInvocation 的处理问题 ANYMethodLog https://github.com/qhd/ANYMethodLog 这个实现 简单点，考虑的情况少…Aspects https://github.com/steipete/Aspects 这个有针对 fowardInvocation 的处理 不同开源库实现的方式多种多样，总之… 你判断就得了呗 123456789101112// If no hooks are installed, call original implementation (usually to throw an exception)if (!respondsToAlias) { invocation.selector = originalSelector; SEL originalForwardInvocationSEL = NSSelectorFromString(AspectsForwardInvocationSelectorName); // origin forwardInvocation 处理 if ([self respondsToSelector:originalForwardInvocationSEL]) { ((void( *)(id, SEL, NSInvocation *))objc_msgSend)(self, originalForwardInvocationSEL, invocation); }else { [self doesNotRecognizeSelector:invocation.selector]; }} hook 父子类循环问题假设我们现在对UIView、UIButton都Hook了initWithFrame:这个方法，在调用[[UIView alloc] initWithFrame:]和[[UIButton alloc] initWithFrame:]都会定向到C函数qhd_forwardInvocation中，在UIView调用的时候没问题。但是在UIButton调用的时候，由于其内部实现获取了super initWithFrame:，就产生了循环定向的问题。 objc_msgsend(super…) 其实还是子类的self 父类调用 - (void)forwardInvocation:(NSInvocation *)anInvocation; 中的隐藏参数self 也是 其实是子类啊… emmm … 这就导致了循环…","link":"/2017/01/15/Aspects-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"title":"Cocoa 深入理解KVO","text":"深入理解KVO…… KVO的使用要实现will/didChangeValueForKey:方法 被kvo的实例 实际上在运行时被调用 12- (void)willChangeValueForKey:(NSString *)key; - (void)didChangeValueForKey:(NSString *)key; 触发 1234- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context; 因此要实现KVO,需要下列条件之一即可 实现了KVC setValue:forKey:会调用 willChangeValueForKey,didChangeValueForKey 有访问器方法(KVO后,会运行时重写setter方法,添加willChangeValueForKey,didChangeValueForKey) 显示调用will/didChangeValueForKey: 原理那系统是如何在框架层面支持 KVO的呢 核心 isa的改变 动态创建子类 替换重写setter方法 重写class方法 动态创建被观察对象的子类,重写setter方法,并且要管理一个对象的所有观察者. 动态创建子类 1234567891011121314151617181920// 子类名NSString *kvoclassName = [kXJYKVOPrefix stringByAppendingString:originalclassName];Class class = NSClassFromString(kvoclassName);if (class) {return class;}// class doesn't exist yet, make itClass originalclass = object_getClass(self);Class kvoclass = objc_allocateClassPair(originalclass, kvoclassName.UTF8String, 0);// 获得签名Method classMethod = class_getInstanceMethod(originalclass, @selector(class));const char *types = method_getTypeEncoding(classMethod);// 替换setter 实现class_addMethod(kvoClazz, @selector(class), (IMP)kvo_class, types);objc_registerClassPair(kvoclass);return kvoclass; 改变isa指针 isa指针的作用: isa指针指向实例的类(对于这里的情况，isa指针的内容请看我的另一片博客)实例通过isa指针找到类,可以得到方法列表，属性列表等信息当我们将isa指针指向子类时，就可以调用子类的方法，使用子类的属性等。于是，调用该实例的setter方法其实是调用了子类的setter方法。 管理观察者由于一个对象可能被多个观察者观察,所以可以用关联对象的方法来管理所有的观察者。 12345678XJYObservationInfo *info = [[XJYObservationInfo alloc]initWithObserver:self key:key block:block];// 维护改KVO观察者数组NSMutableArray *observers = objc_getAssociatedObject(self, (__bridge const void *)(kXJYKVOAssociatedObservers));if (!observers) {observers = [NSMutableArray array];objc_setAssociatedObject(self, (__bridge const void *)(kXJYKVOAssociatedObservers), observers, OBJC_ASSOCIATION_RETAIN_NONATOMIC);}[observers addObject:info]; 重写class方法 12345class_addMethod(kvoClazz, @selector(class), (IMP)kvo_class, types);static Class kvo_class(id self, SEL _cmd){return class_getSuperclass(object_getClass(self));} 子类 setter 的实现在这个派生类中重写基类中任何被观察属性的 setter 方法。派生类在被重写的 setter 方法实现真正的通知机制，就如前面手动实现键值观察那样。 额外扩充还记得Aspects中 对于KVO的特殊处理吗，KVO改变了实例对象的isa指针,在此处 Aspects对KVO过的实例进行了特殊的处理Aspects: 1234// Probably a KVO'ed class. Swizzle in place. Also swizzle meta classes in place.else if (statedClass != baseClass) {return aspect_swizzleClassInPlace(baseClass);} 1234object.class 由于KVO重写了class方法，所以不能准确的找到类object_getClass()方法可以准确的找到isa指针object.class 与 object_getClass(object)进行判断 来防止KVO导致的AOP无效","link":"/2017/04/20/Cocoa-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3KVO/"},{"title":"APM Crash系统","text":"整体架构 客户端 Crash/OOM/ANR 抓取 上报日志格式 Crash/OOM/卡顿 抓取这块技术有很多的开源方案， Crash抓取有 KSCrash PLCrash…OOM 可以参考腾讯的OOMDetector自己优化一下ANR 可以参考很多方案，这里就不细说了 日志上报格式上报的日志我认为最好兼容苹果的 symbolicatecrash 工具, 这就需要我们去理解 symbolicate 工作的原理，随后我们可以加上自己的内容，方便自己进行更多的功能扩展。 symbolicatecrash 的原理 解析头部信息是否符合规范 解析堆栈信息，符号表 信息 在文件中查找符号表的路径 根据堆栈信息去匹配相应符号表 使用atosl工具进行符号化 文本替换成符号化后的日志 服务端 符号化和解析服务 堆栈聚合服务 符号文件管理系统 符号化和解析服务我们可以把这块看成两个部分，1符号化，2解析服务 符号化符号化就是把地址翻译成对应的符号信息，比如说 把堆栈调用的地址 翻译成 调用方法的名称。苹果给我们在 MacOS 下提供了 atosl 工具，可以帮助我们完成这部分工作。但是这个工具仅仅可以在MacOS 下工作，对于大规模的用户日志来说，依赖于MacOS系统不容易部署维护，费用也十分昂贵，因此我们需要在Linux下实现一个相等功能的工具。 解析服务由于我们的日志是文本格式，我们需要提取其中的信息才可以将其用作符号化工具的输入，可以通过正则匹配的方式去处理这些信息。 工具实现 Linux 平台下可用的符号化工具 Linux 平台下可用的符号化工具总体来说，iOS符号化我们需要了解两部分知识， 1 Dwarf调试格式 2 Macho文件格式 Dwarf调试格式我们经常可以接触到的dsym文件是一个目录，其中包含了一个格式为Dwarf的调试信息文件。调试信息是在编译器生成机器码的时候一起产生的。它代表着可执行程序和源代码之间的关系。这个信息以预定义的格式进行编码，并同机器码一起存储。在DWARF里基本的描述项是调试信息项（DebuggingInformation Entry——DIE）。一个DIE有一个标签，它指明了这个DIE描述什么及一个填入了细节并进一步描述该项的属性列表。一个DIE（除了最顶层的）被一个父DIE包含（或者说拥有），并可能有兄弟DIE或子DIE。通过提取Dwarf文件中的调试信息和对应的堆栈进行匹配，就可以解出一些符号信息，包含调用行号文件名称等信息。 需要注意的一些知识点DW_AT_abstract_origin， DW_AT_specification A debugging information entry that represents a declaration thatcompletes another (earlier) non-defining declaration may have aDW_AT_specification attribute whose value is a reference to thedebugging information entry representing the non-defining declaration.A debugging information entry with a DW_AT_specification attributedoes not need to duplicate information provided by the debugginginformation entry referenced by that specification attribute.A DW_TAG_subprogram entry can contain a reference to a DW_AT_abstract_origin entry instead of &gt; duplicating the information. 这意味着 我们需要针对 DW_AT_abstract_origin 进行特别处理 Macho 文件格式上文中提到的符号文件，是Macho文件格式的。Macho文件中包含 SymbolTable 可以提取出符号的名称，对于系统库和外部符号（例如你的静态库中的符号），我们可以从SymbolTable中提取符号名称。 堆栈聚合服务因为导致用户Crash的问题大多是相同的，导致用户Crash的堆栈存在许多相似和相等的情况，我们需要把同一类堆栈聚合在一起，协助平台用户高效的解决问题。 系列文章接下来我会逐渐介绍这整套系统的设计和相关技术实现。","link":"/2018/09/16/CrashSymbolicateSystemDesign/"},{"title":"Dobby源码学习（一） Inline Hook","text":"Inline Hook方法拦截： 找到方法地址 remap 替换方法开头为跳转指令问题：替换的指令， b的 range 在 替换指令内。会不会有问题？ 构造跳转指令 _ Ldr(Register::X(17), &amp;address_ptr); _ br(Register::X(17)); _ PseudoBind(&amp;address_ptr); _ EmitInt64(address); 因为方法开头的指令被替换到其他页，因此需要：修正被替换的指令 fix pc 相关指令.. 添加跳转跳回指令","link":"/2020/03/25/DobbyRead/"},{"title":"崩溃捕获系统的原理（一）异常信号","text":"之前在头条搞了端监控，比较有意思的部分是Crash捕获，持续做了1年。开源的Crash捕获框架KSCrash,PLCrashReporter 都值得一看。当然也存在各自的问题。这边博客主要简单讲一下Mach系统的异常处理模型。 Crash捕获下面是Crash捕获处理系统几个核心的关键领域知识。感兴趣的可以自行了解一下，每一部分都值得研究，弄明白了 系统的异常处理机制，Dynamic Image, Thread Context，可以加深对iOS底层工作原理的理解。 UNIX signals 信号 Mach Exceptions Mach异常 Basic Thread details 线程现场信息 Binary image information 动态库信息 Frame pointer-based stack traces 基于fp的callstack回溯 Compact Unwind support \b辅助callstack回溯的 Compact Unwind信息 本片主要介绍的是异常和信号的处理。具体代码怎么抓 Mach / Signal Exception 可以看看开源的 KSCrash 和 PLCrashReporter. 异常处理流程 Mach异常模型 Mach异常和Signal的转换 软件异常 硬件异常触发流程 系统是怎么抓的crash? 为什么都是 EXC_CRASH 类型？ 首先要明确几个概念及其之间的联系：硬件异常, 软件异常,mach异常, Signal异常。这四种异常概念，自底向上构建了iOS系统的异常处理模型。 其之间的关系如下 Mach异常模型基于 mach message 机制, 可以 通过注册端口监听异常消息 可以为 host, task, thread 注册异常处理端口。(例如：小程序注册thread 级别的处理，然后自己处理异常。) 发送异常消息 mach异常信号的来源，可以看到通过两种途径： 硬件级别的触发异常 proc退出时会触发异常(EXC_CRASH)。 Mach异常和Signal的转换Mach异常如果不处理，默认会转化为Signal异常。内核注册了host-level的exception handler，负责将mach异常转换为对应的Signal信号。 12345678910111213141516171819202122232425262728293031/* Called with kernel funnel held */voidbsdinit_task(void){ proc_t p = current_proc(); struct uthread *ut; thread_t thread; process_name(\"init\", p); ux_handler_init(); thread = current_thread(); (void) host_set_exception_ports(host_priv_self(), EXC_MASK_ALL &amp; ~(EXC_MASK_RPC_ALERT),//pilotfish (shark) needs this port (mach_port_t) ux_exception_port, EXCEPTION_DEFAULT| MACH_EXCEPTION_CODES, 0); ut = (uthread_t)get_bsdthread_info(thread); bsd_init_task = get_threadtask(thread); init_task_failure_data[0] = 0;#if CONFIG_MACF mac_cred_label_associate_user(p-&gt;p_ucred); mac_task_label_update_cred (p-&gt;p_ucred, (struct task *) p-&gt;task);#endif load_init_program(p); lock_trace = 1;} 硬件异常触发流程 硬件异常会转化为Mach异常 123456789101112131415voidi386_exception( int exc, mach_exception_code_t code, mach_exception_subcode_t subcode){ mach_exception_data_type_t codes[EXCEPTION_CODE_MAX]; DEBUG_KPRINT_SYSCALL_MACH(\"i386_exception: exc=%d code=0x%llx subcode=0x%llx\\n\", exc, code, subcode); codes[0] = code; /* new exception interface */ codes[1] = subcode; exception_triage(exc, codes, 2); /*NOTREACHED*/} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354voidexception_triage( exception_type_t exception, mach_exception_data_t code, mach_msg_type_number_t codeCnt){ thread_t thread; task_t task; host_priv_t host_priv; lck_mtx_t *mutex; kern_return_t kr; assert(exception != EXC_RPC_ALERT); thread = current_thread(); /* * Try to raise the exception at the activation level. */ mutex = &amp;thread-&gt;mutex; kr = exception_deliver(thread, exception, code, codeCnt, thread-&gt;exc_actions, mutex); if (kr == KERN_SUCCESS || kr == MACH_RCV_PORT_DIED) goto out; /* * Maybe the task level will handle it. */ task = current_task(); mutex = &amp;task-&gt;lock; kr = exception_deliver(thread, exception, code, codeCnt, task-&gt;exc_actions, mutex); if (kr == KERN_SUCCESS || kr == MACH_RCV_PORT_DIED) goto out; /* * How about at the host level? */ host_priv = host_priv_self(); mutex = &amp;host_priv-&gt;lock; kr = exception_deliver(thread, exception, code, codeCnt, host_priv-&gt;exc_actions, mutex); if (kr == KERN_SUCCESS || kr == MACH_RCV_PORT_DIED) goto out; /* * Nobody handled it, terminate the task. */ (void) task_terminate(task);out: if ((exception != EXC_CRASH) &amp;&amp; (exception != EXC_RESOURCE) &amp;&amp; (exception != EXC_GUARD)) thread_exception_return(); return;} 软件异常通过kill() 直接抛出signal异常(软件)处理流程如下图所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243__private_extern__ void__abort(){ struct sigaction act; if (!CRGetCrashLogMessage()) CRSetCrashLogMessage(\"__abort() called\"); act.sa_handler = SIG_DFL; act.sa_flags = 0; sigfillset(&amp;act.sa_mask); (void)_sigaction(SIGABRT, &amp;act, NULL); sigdelset(&amp;act.sa_mask, SIGABRT); /* &lt;rdar://problem/7397932&gt; abort() should call pthread_kill to deliver a signal to the aborting thread * This helps gdb focus on the thread calling abort() */ if (__is_threaded) { /* Block all signals on all other threads */ sigset_t fullmask; sigfillset(&amp;fullmask); (void)_sigprocmask(SIG_SETMASK, &amp;fullmask, NULL); /* &lt;rdar://problem/8400096&gt; Set the workqueue killable */ __pthread_workqueue_setkill(1); (void)pthread_sigmask(SIG_SETMASK, &amp;act.sa_mask, NULL); (void)pthread_kill(pthread_self(), SIGABRT); } else { (void)_sigprocmask(SIG_SETMASK, &amp;act.sa_mask, NULL); (void)kill(getpid(), SIGABRT); } usleep(TIMEOUT); /* give time for signal to happen */ /* If for some reason SIGABRT was not delivered, we exit using __builtin_trap * which generates an illegal instruction on i386: &lt;rdar://problem/8400958&gt; * and SIGTRAP on arm. */ sigfillset(&amp;act.sa_mask); sigdelset(&amp;act.sa_mask, SIGILL); sigdelset(&amp;act.sa_mask, SIGTRAP); (void)_sigprocmask(SIG_SETMASK, &amp;act.sa_mask, NULL); __builtin_trap();} 系统是怎么抓的crash? 为什么都是 EXC_CRASH 类型？系统通过launchd监听了EXC_CRASH。EXC_CRASH 是一种特殊类型，囊括硬件和软件异常，什么都能抓。但是需要out-of-process 处理。(信号发出的时候，进程已经跪了)看进程退出逻辑，EXC_CRASH 基本上会囊括所有的崩溃类型。软硬件异常都会转化为Signal信号。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667voidproc_prepareexit(proc_t p, int rv, boolean_t perf_notify) { mach_exception_data_type_t code, subcode; struct uthread *ut; thread_t self = current_thread(); ut = get_bsdthread_info(self); /* If a core should be generated, notify crash reporter */ if (hassigprop(WTERMSIG(rv), SA_CORE) || ((p-&gt;p_csflags &amp; CS_KILLED) != 0)) { /* * Workaround for processes checking up on PT_DENY_ATTACH: * should be backed out post-Leopard (details in 5431025). */ if ((SIGSEGV == WTERMSIG(rv)) &amp;&amp; (p-&gt;p_pptr-&gt;p_lflag &amp; P_LNOATTACH)) { goto skipcheck; } /* * Crash Reporter looks for the signal value, original exception * type, and low 20 bits of the original code in code[0] * (8, 4, and 20 bits respectively). code[1] is unmodified. */ code = ((WTERMSIG(rv) &amp; 0xff) &lt;&lt; 24) | ((ut-&gt;uu_exception &amp; 0x0f) &lt;&lt; 20) | ((int)ut-&gt;uu_code &amp; 0xfffff); subcode = ut-&gt;uu_subcode; (void) task_exception_notify(EXC_CRASH, code, subcode); }skipcheck: /* Notify the perf server? */ if (perf_notify) { (void)sys_perf_notify(self, p-&gt;p_pid); } /* * Remove proc from allproc queue and from pidhash chain. * Need to do this before we do anything that can block. * Not doing causes things like mount() find this on allproc * in partially cleaned state. */ proc_list_lock(); LIST_REMOVE(p, p_list); LIST_INSERT_HEAD(&amp;zombproc, p, p_list); /* Place onto zombproc. */ /* will not be visible via proc_find */ p-&gt;p_listflag |= P_LIST_EXITED; proc_list_unlock();#ifdef PGINPROF vmsizmon();#endif /* * If parent is waiting for us to exit or exec, * P_LPPWAIT is set; we will wakeup the parent below. */ proc_lock(p); p-&gt;p_lflag &amp;= ~(P_LTRACED | P_LPPWAIT); p-&gt;p_sigignore = ~(sigcantmask); ut-&gt;uu_siglist = 0; proc_unlock(p);}","link":"/2019/09/28/CrashMonitorSystem/"},{"title":"理解线程安全","text":"线程安全问题的来源 线程安全是编程中的术语，指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。 可以看到这一切的诱因就是因为共享变量。如果我们的线程执行过程中，没有相互影响，就不会出现问题。 当我们的线程访问共享变量时，我们无法预测操作系统是否将为我们的线程选择一个正确的顺序。这就尴尬了！ 对多个线程对资源的访问，我们称之为 竞争。 由于两个或者多个进程竞争使用不能被同时访问的资源，使得这些进程有可能因为时间上推进的先后原因而出现问题，这叫做竞争条件（Race Condition）。 竞争条件分为两类 Mutex 不能被多个进程同时使用的资源 Synchronization 两个或多个进程彼此指针存在内在的制约关系 消费者生产者问题就是同步问题，它需要调度对共享资源的访问，是 Synchronization。 读者写者问题是互斥问题的一个概括。 消费者生产者问题 因为插入和取出项目都涉及更新共享变量，所以我们必须保证对缓冲区的访问是互斥的。但是只保证互斥访问是不够的，我们还需要调度对缓冲区的访问。如果缓冲区是满的，那么生产者必须等待直到有一个槽位变为可用。与之相似，如果缓冲区是空的，那么消费者必须等待直到有一个项目变为可用。 读者-写者问题 读者写者问题是互斥问题的一个概括。一组并发的线程要访问一个共享对象。写者必须拥有对对象独占的访问。 如何保证线程安全在我们需要访问共享变量的情况下，我们需要保证线程执行顺序的正确性。或者我们尽量避免使用共享变量。 进度图如果我们用 纵横坐标分别表示两个进程执行的指令顺序，那么操作共享变量的指令会构成一个二维的不安全区，当两条线程的执行轨迹会同时访问不安全区时，我们就认为执行是不安全的。(局限性：无法描述多处理器并发执行) 我们可以选择安全的轨迹线，或者使用信号量实现互斥。 锁思考一下，锁做了什么？ lock是在执行多线程时用于强行限制资源访问的同步机制，即用于在并发控制中保证对互斥要求的满足.对于竞争条件中的 Mutex 我们可以使用互斥锁处理。Synchronization 可以使用条件锁。使用lock是可以保证线程安全的，但不能保证线程的执行顺序。 原子性原子性（Atomic），一个事务包含多个操作，这些操作要么全部执行，要么全都不执行。 OC 中一个很经典的面试题是， property 设置 atomic 能保证线程安全吗？很多人都回答可以，这是压根没理解线程安全的体现。原子性不能保证线程安全原子性可以保证写操作一小块代码段是互斥的，但是并不能保证线程安全。 设置atomic之后，只是保证了 属性的赋值操作是互斥的，可惜只是该属性..不能保证我们整个代码的线程安全。 考虑一段代码. 123456self.a = 0;//1if (self.a == 0) { print(\"safe\");} else { print(\"unsafe\");} 当 self.a = 0; 执行完毕后 处理机调度，切换到另一个线程执行 1self.b = 0; 再次切换为原先的线程此时，结果是unsafe.我们原先的值被其他线程篡改了。并不能保证线程安全。 会想一下 那经典的 进度图，原子性无法阻止多个线程访问不安全区。 加锁之后，就保证 代码块 不会被多个进程访问，保证了线程安全。 12345678lock();self.a = 0;//1if (self.a == 0) { print(\"safe\");} else { print(\"unsafe\");}unlock(); 不可变性不可变性，这个跟线程安全关系大吗？显然，我们对共享变量的访问，会导致线程安全问题是因为我们对其进行了写操作。不可变可以避免代码编写中因为疏忽导致的问题。真正处理线程安全的时候，你遇到的，会是可变的共享变量！所以，这个对线程安全问题，没有用处。","link":"/2017/12/24/In-depthUnderStandingOfThreadSafety/"},{"title":"MachO（一） ObjC类结构的加载","text":"最近做的事情跟MachO中的ObjC内容十分相关。OC Runtime 通过加载MachO中的文件信息，将类的信息添加到运行时，理论上，我们也可以自己去 加载指定位置的类信息注册加载到Runtime中。 首先看看OBJC类结构在MachO中有哪些内容。本文通过MachoView, Hopper 进行分析。 12345678__TEXT, __objc_classname 类名列表__TEXT,__objc_methodname 方法名列表__TEXT,__objc_methtype 方法类型列表__DATA, __objc_classlist 记录镜像所定义的类，每个条目都是一个指针，指向到 __objc_data section__DATA,objc_imageinfo 记录 Objective-C 环境信息等，dyld 用它来判断镜像是否是 objc 镜像__DATA,__objc_const 存放类的元数据，包括：method list、variable list、property list、class info__DATA,__objc_data 存放真正的类数据，和 __objc_classlist 条目呼应__DATA,__objc_classrefs 类引用列表 我关注的主要内容是 ObjC 类如何被加载注册的。首先分析一下 大致的数据结构。 __objc_classlist其内容指向所定义类的地址，那就看看class定义的结构大致是什么样子的，通过MachOview查看 __objc_classlist的一个条目0x0000000000008100 hopper 看一下，位于__objc_data。hopper 中的 objc_class 这个结构在objc_runtime中是有的，之后分析runtime源码会用到。 123456789101112131415161718192021222324252627282930313233343536struct objc_class : objc_object { // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // 先是ro,后被设置为rw class_rw_t* data() { return (class_rw_t *)(bits &amp; FAST_DATA_MASK); } ...}struct objc_object {private: isa_t isa; ...}struct class_ro_t { uint32_t flags; uint32_t instanceStart; uint32_t instanceSize;#ifdef __LP64__ uint32_t reserved;#endif const uint8_t * ivarLayout; const char * name; method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; const uint8_t * weakIvarLayout; property_list_t *baseProperties; ...} 1234567891011121314151617181920212223242526272829303132333435_OBJC_CLASS_$_ExampleObject:0000000000008100 struct __objc_class { ; DATA XREF=0x8018 _OBJC_METACLASS_$_ExampleObject, // metaclass 元类 _OBJC_CLASS_$_NSObject, // superclass 父类 __objc_empty_cache, // cache 先不管 0x0, // vtable 先不管 __objc_class_ExampleObject_data // data objc_const段内 }元类_OBJC_METACLASS_$_ExampleObject:00000000000080d8 struct __objc_class { ; DATA XREF=_OBJC_CLASS_$_ExampleObject _OBJC_METACLASS_$_NSObject, // metaclass _OBJC_METACLASS_$_NSObject, // superclass __objc_empty_cache, // cache 0x0, // vtable __objc_metaclass_ExampleObject_data // data }看这个注释，是 class_ro_t__objc_class_ExampleObject_data:0000000000008090 struct __objc_data { ; &quot;ExampleObject&quot;, DATA XREF=_OBJC_CLASS_$_ExampleObject 0x80, // flags 8, // instance start 8, // instance size 0x0, 0x0, // ivar layout 0x7f5d, // name __objc_class_ExampleObject_methods, // base methods 0x0, // base protocols 0x0, // ivars 0x0, // weak ivar layout 0x0 // base properties } 结合源码查看一下 加载的过程。从别人的博客中看到 入口是 _objc_init。加载通过 注册dyld回调的方式。 1_dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);//map_images加载镜像 通过阅读一些大佬 https://zhangbuhuai.com/post/runtime.html 的博客，大致了解了OBJC加载的步骤，根据我最编译的简单的Dylib，大致过滤了一下需要关注的内容。 discover classes. 即从镜像提取类信息，并存到名为allocatedClasses的全局 hash table 中 // 提取信息，不看了 remap classes. 重新调整类之间的引用 // 没执行到不管了 fix up selector references. 提取方法，并注册到名为namedSelectors的全局 map table 中 fix up objc_msgSend_fixup // 没有这个内容，不管了 discover protocols. 提取 protocols，存储到全局 map table // 先不考虑 fix up @protocol references. 和类一样，protocol 也有继承关系，此过程 fixup 它们的依赖关系 // 先不考虑 realize non-lazy classes. realize 含有+load方法或者静态实例的类 realize future classes. realize 含有RO_FUTURE标识的类，这些类一般是 Core Foundation 中的类 discover categories. 提取 categories，存储到全局 map table Runtime 提供 void objc_registerClassPair(Class cls); 方法去注册类。 Class 类型就是 typedef struct objc_class *Class;, 看起来我们需要从MachO中读取数据，随后修正objc_class结构就能做到了。具体如何修正那就参考runtime自己的实现。 …","link":"/2020/04/01/MachOObjC/"},{"title":"Objective-C weak 关键字 实现 源码分析","text":"__weak1id __week obj1 = obj; 编译器的模拟代码 1234id obj1;obj1 = 0;objc_storeWeak(&amp;obj1, obj);objc_storeWeak(&amp;obj1, 0); objc_storeWeak函数把第二参数的赋值对象的地址作为键值，将第一参数的附有__weak修饰的变量的地址注册到weak表中。如果第二参数为0，则把变量的地址从weak表中删除。initWeak的实现 12345id objc_initWeak(id *object, id value){ *object = 0; return objc_storeWeak(object, value);} storeWeak是Objective-C的开源部分让我们来看看storeWeak到底是怎么实现的 objc_storeWeakstoreWeak的源码官方英文注释挺全的，可以直接理解~ 1234567891011121314151617181920212223// Clean up old value, if any.if (HaveOld) { weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);}// Assign new value, if any.if (HaveNew) { newObj = (objc_object *)weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, CrashIfDeallocating); // weak_register_no_lock returns nil if weak store should be rejected // Set is-weakly-referenced bit in refcount table. if (newObj &amp;&amp; !newObj-&gt;isTaggedPointer()) { newObj-&gt;setWeaklyReferenced_nolock(); } // Do not set *location anywhere else. That would introduce a race. *location = (id)newObj;}else { // No new value. The storage is not changed.} 来看看storeWeak的实现获取oldObj/newObj 1234567891011if (HaveOld) { oldObj = *location; oldTable = &amp;SideTables()[oldObj];} else { oldTable = nil;}if (HaveNew) { newTable = &amp;SideTables()[newObj];} else { newTable = nil;} 首先是根据weak指针找到其指向的老的对象： 1oldObj = *location; 然后获取到与新旧对象相关的SideTable对象： 12oldTable = &amp;SideTables()[oldObj];newTable = &amp;SideTables()[newObj]; &amp;SideTables()[oldObj]这是什么鬼??其时是 实现了一个类 StripedMap 重载了[]操作符(c++: 哪里都能看到我 233) 1234public: T&amp; operator[] (const void *p) { return array[indexForPointer(p)].value; } 下面要做的就是在老对象的weak表中移除指向信息，而在新对象的weak表中建立关联信息： 1234567if (HaveOld) { weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);}if (HaveNew) { newObj = weak_register_no_lock(&amp;newTable-&gt;weak_table, newObj,location); // weak_register_no_lock returns NULL if weak store should be rejected} 接下来让弱引用指针指向新的对象： 1*location = newObj; 最后会返回这个新对象： 1return newObj; 以上我们能发现weak的管理实际上跟weak_table有这千丝万缕的联系,接下来就对weak_table进行分析! weakTable(关先上源码还是先总结…我思考了很久…。。。。) weak表是一个弱引用表，实现为一个weak_table_t结构体，存储了所有对象相关的的所有的弱引用信息 其中weak_entry_t是存储在弱引用表中的一个内部结构体，它负责维护和存储指向一个对象的所有弱引用hash表。 weak_entry_t中的referrers 存储了指向weak对象的所有变量 来张图直观感受一下: 下面开始对这些结构体进行分析: SideTable是一个用C++实现的类，它的具体定义在NSObject.mm中12345678class SideTable {private: static uint8_t table_buf[SIDE_TABLE_STRIPE * SIDE_TABLE_SIZE];public: RefcountMap refcnts;//引用计数表 weak_table_t weak_table;//弱引用表 ......} weak表的结构定义: 12345678910/** * The global weak references table. Stores object ids as keys, * and weak_entry_t structs as their values. */struct weak_table_t { weak_entry_t *weak_entries; size_t num_entries; uintptr_t mask; uintptr_t max_hash_displacement;}; 这是一张存储全局弱引用对象的表object 的 ids 作为Hash表的keysweak_entry_t 作为他们的值. 来看weak_entry_t的结构体 12345678910111213141516struct weak_entry_t { DisguisedPtr&lt;objc_object&gt; referent; union { struct { weak_referrer_t *referrers; uintptr_t out_of_line : 1; uintptr_t num_refs : PTR_MINUS_1; uintptr_t mask; uintptr_t max_hash_displacement; }; struct { // out_of_line=0 is LSB of one of these (don't care which) weak_referrer_t inline_referrers[WEAK_INLINE_COUNT]; }; };}; referrers: 所有指向 referent 的指针referent: 指向内存上的weak对象的指针weak_referrer_t: referent对象的地址 现在我们可以得出什么结论了呢 OC中 弱引用变量的管理是利用 weak表(Hash表)来管理的 weak表中的weak_entries负责管理指向weak对象的变量 weak对象的释放释放对象时，废弃谁都不持有的对象的同时，程序的动作是怎么样的呢？ objc_release 因为引用计数为0所以执行dealloc objc rootDealloc objc dispose objc destructInstance objc clear dealloctaing 对象被废弃时最后调用的objc_clear_deallocating函数的动作如下：(1) 从weak表中获取废弃对象的地址为键值的记录。(2) 将包含在记录中的所有附有__weak修饰符变量的地址，赋值为nil(3) 从weak表中删除该记录。(4) 从引用计数表中删除废弃对象的地址为键值的记录。 由此可知，如果大量使用附有weak修饰符的变量，则会消耗相应的CPU资源。良策是只在需要避免循环引用时使用weak修饰符。 立即释放对象123{ id __weak obj = [[NSObject alloc] init];} 因为该源码将自己生成并持有的对象赋值给附有__weak修饰符的变量中，所以自己不能持有该对象，这是会被释放并且废弃。 使用附有__weak修饰符的变量，即是使用注册到autoreleasepool中的对象1234{ id __weak obj1 = obj; NSLog(@&quot;%@&quot;,obj1);} 编译器模拟的代码 123456id obj1;objc_initWeak(&amp;obj,obj);id tmp = objc_loadWeakRetained(&amp;obj);objc_autorelease(tmp);NSLog(@&quot;%@&quot;, tmp);objc_destoryWeak(&amp;obj1); 注意这两行代码 12id tmp = objc_loadWeakRetained(&amp;obj);objc_autorelease(tmp); 与赋值时相比，在使用附有__weak修饰符变量的情况下，增加了对objc_loadWeakRetained函数和objc_autorelease函数的调用。(1) objc_loadWeakRetained 函数取出附有__weak修饰符变量所引用的对象并retain(2) objc_autorelease 函数将对象注册到autoreleasepool中。 注意：每次使用weak修饰的变量，会使变量所引用的对象注册到autoreleasepool中。如果要避免这种情况可以将附有weak修饰符的变量赋值给附有__strong修饰符的变量后再次使用。 12id __weak o = obj;id tmp = o; allowWeakReference/retainWeakReference当allowsWeakReference/retainWeakReference实例方法(没有写入NSObject接口说明文档中)返回NO的情况。 12- (BOOL)allowsWeakReference;- (BOOL)retainWeakReference; 在赋值给__weak修饰符的变量时,如果allowsWeakReference方法返回NO，程序将异常终止。对象retain时,如果retainWeakReference方法返回NO, 该变量将使用nil 具体源码分析以上关于weak的 weak_register_no_lock weak_unregister_no_lock 。。。很多具体实现都没有讲…我把自己看的代码加上注释贴出来了…感兴趣的可以看一下具体的实现…感受源码实现的魅力 objc开源部分 weak_unregister_no_lock怎么理解呢objc_object **referrer? 12objc_object *referent = (objc_object *)referent_id;objc_object **referrer = (objc_object **)referrer_id; referent 是一个指针，指向内存上的对象的存储位置.referrer 只指向referent的指针 1*referrer = referent 我们要结合remove_referrer这个函数来理解 remove_referrer 123456for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) { if (entry-&gt;inline_referrers[i] == old_referrer) { entry-&gt;inline_referrers[i] = nil; return; } } 所以我们要拿到referrer 根据这个值来和entry链表中的指针进行比较，如果发现，就nil （指针搞得我都晕了…佩服c/c++系统工程师）（阅读源码真的是一件有意思的是哈哈） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564#include \"objc-private.h\"#include \"objc-weak.h\"#include &lt;stdint.h&gt;#include &lt;stdbool.h&gt;#include &lt;sys/types.h&gt;#include &lt;libkern/OSAtomic.h&gt;#define TABLE_SIZE(entry) (entry-&gt;mask ? entry-&gt;mask + 1 : 0)static void append_referrer(weak_entry_t *entry, objc_object **new_referrer);BREAKPOINT_FUNCTION( void objc_weak_error(void));/** * Unique hash function for object pointers only. * * @param key The object pointer * * @return Size unrestricted hash of pointer. */static inline uintptr_t hash_pointer(objc_object *key) { return ptr_hash((uintptr_t)key);}/** * Unique hash function for weak object pointers only. * * @param key The weak object pointer. * * @return Size unrestricted hash of pointer. */static inline uintptr_t w_hash_pointer(objc_object **key) { return ptr_hash((uintptr_t)key);}/** * Grow the entry's hash table of referrers. Rehashes each * of the referrers. * * @param entry Weak pointer hash set for a particular object. */__attribute__((noinline, used))static void grow_refs_and_insert(weak_entry_t *entry, objc_object **new_referrer){ assert(entry-&gt;out_of_line); size_t old_size = TABLE_SIZE(entry); size_t new_size = old_size ? old_size * 2 : 8; size_t num_refs = entry-&gt;num_refs; weak_referrer_t *old_refs = entry-&gt;referrers; entry-&gt;mask = new_size - 1; entry-&gt;referrers = (weak_referrer_t *) calloc(TABLE_SIZE(entry), sizeof(weak_referrer_t)); entry-&gt;num_refs = 0; entry-&gt;max_hash_displacement = 0; for (size_t i = 0; i &lt; old_size &amp;&amp; num_refs &gt; 0; i++) { if (old_refs[i] != nil) { append_referrer(entry, old_refs[i]); num_refs--; } } // Insert append_referrer(entry, new_referrer); if (old_refs) free(old_refs);}/** * Add the given referrer to set of weak pointers in this entry. * Does not perform duplicate checking (b/c weak pointers are never * added to a set twice). * * @param entry The entry holding the set of weak pointers. * @param new_referrer The new weak pointer to be added. */static void append_referrer(weak_entry_t *entry, objc_object **new_referrer){ // if is Array implementation if (! entry-&gt;out_of_line) { // Try to insert inline. for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) { if (entry-&gt;inline_referrers[i] == nil) { entry-&gt;inline_referrers[i] = new_referrer; return; } } // Couldn't insert inline. Allocate out of line. weak_referrer_t *new_referrers = (weak_referrer_t *) calloc(WEAK_INLINE_COUNT, sizeof(weak_referrer_t)); // This constructed table is invalid, but grow_refs_and_insert // will fix it and rehash it. for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) { new_referrers[i] = entry-&gt;inline_referrers[i]; } entry-&gt;referrers = new_referrers; entry-&gt;num_refs = WEAK_INLINE_COUNT; entry-&gt;out_of_line = 1; entry-&gt;mask = WEAK_INLINE_COUNT-1; entry-&gt;max_hash_displacement = 0; } assert(entry-&gt;out_of_line); if (entry-&gt;num_refs &gt;= TABLE_SIZE(entry) * 3/4) { return grow_refs_and_insert(entry, new_referrer); } //find a place to insert ref //weak_entry_remove() may bzero() some place size_t index = w_hash_pointer(new_referrer) &amp; (entry-&gt;mask); size_t hash_displacement = 0; while (entry-&gt;referrers[index] != NULL) { index = (index+1) &amp; entry-&gt;mask; hash_displacement++; } if (hash_displacement &gt; entry-&gt;max_hash_displacement) { entry-&gt;max_hash_displacement = hash_displacement; } weak_referrer_t &amp;ref = entry-&gt;referrers[index]; ref = new_referrer; entry-&gt;num_refs++;}/** * Remove old_referrer from set of referrers, if it's present. * Does not remove duplicates, because duplicates should not exist. * * @todo this is slow if old_referrer is not present. Is this ever the case? * * @param entry The entry holding the referrers. * @param old_referrer The referrer to remove. */static void remove_referrer(weak_entry_t *entry, objc_object **old_referrer){ if (! entry-&gt;out_of_line) { for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) { if (entry-&gt;inline_referrers[i] == old_referrer) { entry-&gt;inline_referrers[i] = nil; return; } } _objc_inform(\"Attempted to unregister unknown __weak variable \" \"at %p. This is probably incorrect use of \" \"objc_storeWeak() and objc_loadWeak(). \" \"Break on objc_weak_error to debug.\\n\", old_referrer); objc_weak_error(); return; } size_t index = w_hash_pointer(old_referrer) &amp; (entry-&gt;mask); size_t hash_displacement = 0; while (entry-&gt;referrers[index] != old_referrer) { index = (index+1) &amp; entry-&gt;mask; hash_displacement++; if (hash_displacement &gt; entry-&gt;max_hash_displacement) { _objc_inform(\"Attempted to unregister unknown __weak variable \" \"at %p. This is probably incorrect use of \" \"objc_storeWeak() and objc_loadWeak(). \" \"Break on objc_weak_error to debug.\\n\", old_referrer); objc_weak_error(); return; } } entry-&gt;referrers[index] = nil; entry-&gt;num_refs--;}/** * Add new_entry to the object's table of weak references. * Does not check whether the referent is already in the table. */static void weak_entry_insert(weak_table_t *weak_table, weak_entry_t *new_entry){ weak_entry_t *weak_entries = weak_table-&gt;weak_entries; assert(weak_entries != nil); //mask may keep entry in array size_t index = hash_pointer(new_entry-&gt;referent) &amp; (weak_table-&gt;mask); size_t hash_displacement = 0; //hash index 处理 while (weak_entries[index].referent != nil) { index = (index+1) &amp; weak_table-&gt;mask; hash_displacement++; } weak_entries[index] = *new_entry; weak_table-&gt;num_entries++; //update max_hash_displacement if (hash_displacement &gt; weak_table-&gt;max_hash_displacement) { weak_table-&gt;max_hash_displacement = hash_displacement; }}static void weak_resize(weak_table_t *weak_table, size_t new_size){ size_t old_size = TABLE_SIZE(weak_table); weak_entry_t *old_entries = weak_table-&gt;weak_entries; weak_entry_t *new_entries = (weak_entry_t *) calloc(new_size, sizeof(weak_entry_t)); weak_table-&gt;mask = new_size - 1; //new weak_table-&gt;weak_entries = new_entries; weak_table-&gt;max_hash_displacement = 0; weak_table-&gt;num_entries = 0; // restored by weak_entry_insert below //use pointer if (old_entries) { weak_entry_t *entry; weak_entry_t *end = old_entries + old_size; for (entry = old_entries; entry &lt; end; entry++) { if (entry-&gt;referent) { weak_entry_insert(weak_table, entry); } } free(old_entries); }}// Grow the given zone's table of weak references if it is full.static void weak_grow_maybe(weak_table_t *weak_table){ size_t old_size = TABLE_SIZE(weak_table); // Grow if at least 3/4 full. if (weak_table-&gt;num_entries &gt;= old_size * 3 / 4) { weak_resize(weak_table, old_size ? old_size*2 : 64); }}// Shrink the table if it is mostly empty.static void weak_compact_maybe(weak_table_t *weak_table){ size_t old_size = TABLE_SIZE(weak_table); // Shrink if larger than 1024 buckets and at most 1/16 full. if (old_size &gt;= 1024 &amp;&amp; old_size / 16 &gt;= weak_table-&gt;num_entries) { weak_resize(weak_table, old_size / 8); // leaves new table no more than 1/2 full }}/** * Remove entry from the zone's table of weak references. */static void weak_entry_remove(weak_table_t *weak_table, weak_entry_t *entry){ // remove entry if (entry-&gt;out_of_line) free(entry-&gt;referrers); //bzero()函数在由s指向的区域中放置n个0。 bzero(entry, sizeof(*entry)); weak_table-&gt;num_entries--; //maybe resize weak_table weak_compact_maybe(weak_table);}/** * Return the weak reference table entry for the given referent. * If there is no entry for referent, return NULL. * Performs a lookup. * * @param weak_table * @param referent The object. Must not be nil. * * @return The table of weak referrers to this object. */static weak_entry_t *weak_entry_for_referent(weak_table_t *weak_table, objc_object *referent){ assert(referent); weak_entry_t *weak_entries = weak_table-&gt;weak_entries; if (!weak_entries) return nil; size_t index = hash_pointer(referent) &amp; weak_table-&gt;mask; size_t hash_displacement = 0; while (weak_table-&gt;weak_entries[index].referent != referent) { index = (index+1) &amp; weak_table-&gt;mask; hash_displacement++; if (hash_displacement &gt; weak_table-&gt;max_hash_displacement) { return nil; } } return &amp;weak_table-&gt;weak_entries[index];}/** * Unregister an already-registered weak reference. * This is used when referrer's storage is about to go away, but referent * isn't dead yet. (Otherwise, zeroing referrer later would be a * bad memory access.) * Does nothing if referent/referrer is not a currently active weak reference. * Does not zero referrer. * * FIXME currently requires old referent value to be passed in (lame) * FIXME unregistration should be automatic if referrer is collected * * @param weak_table The global weak table. * @param referent The object. * @param referrer The weak reference. */voidweak_unregister_no_lock(weak_table_t *weak_table, id referent_id, id *referrer_id){ objc_object *referent = (objc_object *)referent_id; objc_object **referrer = (objc_object **)referrer_id; weak_entry_t *entry; if (!referent) return; if ((entry = weak_entry_for_referent(weak_table, referent))) { remove_referrer(entry, referrer); bool empty = true; //after unregister the entry's referrers is empty? // Hash implementation if (entry-&gt;out_of_line &amp;&amp; entry-&gt;num_refs != 0) { empty = false; } // Array implementation else { for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) { if (entry-&gt;inline_referrers[i]) { empty = false; break; } } } // if entry.references empty if (empty) { weak_entry_remove(weak_table, entry); } } // Do not set *referrer = nil. objc_storeWeak() requires that the // value not change.}/** * Registers a new (object, weak pointer) pair. Creates a new weak * object entry if it does not exist. * * @param weak_table The global weak table. * @param referent The object pointed to by the weak reference. * @param referrer The weak pointer address. */id weak_register_no_lock(weak_table_t *weak_table, id referent_id, id *referrer_id, bool crashIfDeallocating){ //object objc_object *referent = (objc_object *)referent_id; //The Point which point the object objc_object **referrer = (objc_object **)referrer_id; if (!referent || referent-&gt;isTaggedPointer()) return referent_id; // ensure that the referenced object is viable // judge is Allows Weak Reference bool deallocating; if (!referent-&gt;ISA()-&gt;hasCustomRR()) { deallocating = referent-&gt;rootIsDeallocating(); } else { BOOL (*allowsWeakReference)(objc_object *, SEL) = (BOOL(*)(objc_object *, SEL)) object_getMethodImplementation((id)referent, SEL_allowsWeakReference); if ((IMP)allowsWeakReference == _objc_msgForward) { return nil; } deallocating = ! (*allowsWeakReference)(referent, SEL_allowsWeakReference); } if (deallocating) { if (crashIfDeallocating) { _objc_fatal(\"Cannot form weak reference to instance (%p) of \" \"class %s. It is possible that this object was \" \"over-released, or is in the process of deallocation.\", (void*)referent, object_getClassName((id)referent)); } else { return nil; } } // now remember it and where it is being stored weak_entry_t *entry; if ((entry = weak_entry_for_referent(weak_table, referent))) { append_referrer(entry, referrer); } else { weak_entry_t new_entry; new_entry.referent = referent; new_entry.out_of_line = 0; new_entry.inline_referrers[0] = referrer; for (size_t i = 1; i &lt; WEAK_INLINE_COUNT; i++) { new_entry.inline_referrers[i] = nil; } weak_grow_maybe(weak_table); weak_entry_insert(weak_table, &amp;new_entry); } // Do not set *referrer. objc_storeWeak() requires that the // value not change. return referent_id;}#if DEBUGboolweak_is_registered_no_lock(weak_table_t *weak_table, id referent_id) { return weak_entry_for_referent(weak_table, (objc_object *)referent_id);}#endif/** * Called by dealloc; nils out all weak pointers that point to the * provided object so that they can no longer be used. * * @param weak_table * @param referent The object being deallocated. */void weak_clear_no_lock(weak_table_t *weak_table, id referent_id) { //referent objc objc_object *referent = (objc_object *)referent_id; //referent objc entry(which save many referents) weak_entry_t *entry = weak_entry_for_referent(weak_table, referent); if (entry == nil) { /// XXX shouldn't happen, but does with mismatched CF/objc //printf(\"XXX no entry for clear deallocating %p\\n\", referent); return; } // zero out references weak_referrer_t *referrers; size_t count; if (entry-&gt;out_of_line) { referrers = entry-&gt;referrers; count = TABLE_SIZE(entry); } else { referrers = entry-&gt;inline_referrers; count = WEAK_INLINE_COUNT; } //entry-&gt;referrers all nil for (size_t i = 0; i &lt; count; ++i) { objc_object **referrer = referrers[i]; if (referrer) { if (*referrer == referent) { *referrer = nil; } else if (*referrer) { _objc_inform(\"__weak variable at %p holds %p instead of %p. \" \"This is probably incorrect use of \" \"objc_storeWeak() and objc_loadWeak(). \" \"Break on objc_weak_error to debug.\\n\", referrer, (void*)*referrer, (void*)referent); objc_weak_error(); } } } weak_entry_remove(weak_table, entry);}/** * This function gets called when the value of a weak pointer is being * used in an expression. Called by objc_loadWeakRetained() which is * ultimately called by objc_loadWeak(). The objective is to assert that * there is in fact a weak pointer(s) entry for this particular object being * stored in the weak-table, and to retain that object so it is not deallocated * during the weak pointer's usage. * * @param weak_table * @param referrer The weak pointer address. *//* Once upon a time we eagerly cleared *referrer if we saw the referent was deallocating. This confuses code like NSPointerFunctions which tries to pre-flight the raw storage and assumes if the storage is zero then the weak system is done interfering. That is false: the weak system is still going to check and clear the storage later. This can cause objc_weak_error complaints and crashes. So we now don't touch the storage until deallocation completes.*/id weak_read_no_lock(weak_table_t *weak_table, id *referrer_id) { objc_object **referrer = (objc_object **)referrer_id; objc_object *referent = *referrer; //Detection Tagged Pointer if (referent-&gt;isTaggedPointer()) return (id)referent; weak_entry_t *entry; // referent == nil or entry == nil if (referent == nil || !(entry = weak_entry_for_referent(weak_table, referent))) { return nil; } //Custom RR denotes a custom retain-release implementation // if (! referent-&gt;ISA()-&gt;hasCustomRR()) { //???question if (! referent-&gt;rootTryRetain()) { return nil; } } //has isa else { BOOL (*tryRetain)(objc_object *, SEL) = (BOOL(*)(objc_object *, SEL)) object_getMethodImplementation((id)referent, SEL_retainWeakReference); //IMP != _objc_magForward if ((IMP)tryRetain == _objc_msgForward) { return nil; } //IMP != nil if (! (*tryRetain)(referent, SEL_retainWeakReference)) { return nil; } } return (id)referent;}","link":"/2017/02/01/Objective-C-weak-%E5%85%B3%E9%94%AE%E5%AD%97-%E5%AE%9E%E7%8E%B0-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"title":"Objective-C 深入理解中的消息机制和方法调用","text":"objc_msgSend 的背后在Objective-C中，消息在Runtime的时候才绑定到方法实现。编译器把 1[receiver message] 转换成 1objc_msgSend(receiver, selector) 这个messaging function 做了动态绑定所有的工作 首先找到selector 指定的 方法实现.相同的方法可以在不同的类中有不同的实现。被找到的方法实现取决于消息的接受者(类)。 然后调用方法实现，并传递方法所需的参数. 最后，将所调用方法的返回值 作为自身的返回值. 消息传递的关键在于 编译器为每个class和object建立的 结构体.每个类的结构体包含着两个必备的元素: 一个指向父类的指针 一个 class dispatch table.表中包含了method selectors 和 特定class相应方法实现的地址 实例中有一个isa指针，isa指向实例的class structure. 如图所示 通过isa指针，描述了类的继承关系 消息传递的过程 当一个消息被发送给一个对象，messaging function跟随对象的isa指针找到他的class structure,在dispatch table中寻找method selector. 如果没有找到selector,objc_msgsend 跟随该类实例的isa找到父类，尝试在父类的dispatch table中寻找selector 重复步骤2,直到isa指向NSObject Class为止。 一但objc_msgsend定位到了selector,该函数,调用dispatch table中的方法，并将其传递给接收对象的数据结构。 这是Runtime中选择所需方法实现的实现方式.在面向对象编程的术语中，这些methods和messages 是动态绑定的。 为了加速消息传递的过程，runtime 系统缓存了使用过的 selectors 和 方法实现的地址。 每个class都有特定的cache.并且它可以包含 继承的selector和 定义在类中的方法。 在OC编程中，你向对象发送消息是因为该对象实现了相应的方法，并且你希望调用该方法。在搜索dispatch tables之前，消息传递机制通常会首先检查接受方法的对象的cache。如果方法的selector在缓存中，调用method所需的时间仅仅比function call 稍微慢一点点一但程序预热cache之后，大多数消息调用都能从cache中找到。为了存放更多的方法，Cache会动态的增长。 深入理解消息转发过程以下是文档的中文翻译： resolveInstanceMethod:resolveInstanceMethod: 和 resolveClassMethod: 方法允许你为一个给定的 selector 动态的提供方法的实现。OC 方法在底层的C函数的实现中需要至少两个参数：self 和 _cmd。使用 class_addMethod 函数，你能够添加一个函数到一个类来作为方法使用。 forwardingTargetForSelector:如果一个对象实现了这个方法，并且返回了一个非空（以及非 self）的结果，返回的对象会用来作为一个新的接收对象，随后消息会被重新派发给这个新对象。（很明显，如果你在这个方法中返回了self，那这段代码将会坠入无限循环。）如果你这段方法在一个非 root 的类中实现，并且如果这个类根据给定的selector什么都不作返回，那么你应该返回一个 执行父类的实现后返回的结果。这个方法为对象在开销大的多的 forwardInvocation: 方法接管之前提供了一次转发未知消息的机会。这对你只是想简单的重新定位消息到另一个对象是非常有用的，并且相对普通转发更快一个数量级。如果转发的目的是捕捉到NSInvocation，或者操作参数，亦或者是在转发过程中返回一个值，那这个方法就没有用了。 forwardInvocation:当对象接受到一条自己不能响应的消息时，运行时会给接收者一次机会来把消息委托给另一个接收者。他委托的消息是通过NSInvocation对象来表示的，然后将这个对象作为 forwardInvocation: 的参数。接收者收到 forwardInvocation: 这条消息后可以选择转发这个NSInvacation对象给其他接收对象。（如果这个接收对象也不能响应这条消息，他也会给一次转发这条消息的机会。）因此 forwardInvocation: 允许在两个对象之间通过某个消息来建立关系。转发给其他对象的这种行为，从某种意义上来说，他“继承”了他所转发给的对象的一些特征。注意为了响应这个你无法识别的方法，你除了 forwardInvocation: 方法外，还必须重写 methodSignatureForSelector: 方法。在转发消息的机制中会从 methodSignatureForSelector: 方法来创建NSInvocation对象。所以你必须为给定的 selector 提供一个合适的 method signature ，可以通过预先设置一个或者向另一个对象请求一个。 forwardInvocation，forwardingTargetForSelector 的差异相较于 forwardingTargetForSelector 只能拿到 selector 来说， forwardInvocation 借助于invocation 可以获得参数和返回值等信息。 NSInvocation文档翻译NSInvocation:NSInvocation对象用于在对象之间和应用程序之间存储和转发消息，主要由NSTimer对象和分布式对象系统来完成。 NSInvocation对象包含Objective-C消息的所有元素：目标，选择器，参数和返回值。每个元素都可以直接设置，并在调度NSInvocation对象时自动设置返回值。 一个NSInvocation对象可以重复地分派给不同的目标;它的参数可以针对不同结果的调度时进行修改;甚至它的选择器可以变为另一个具有相同的方法签名（参数和返回类型）。这种灵活性使得NSInvocation对重复发送具有许多参数和变体的消息有用;而不是为每条消息重新输入一个稍微不同的表达式，每次在将其分派到新目标之前，都需要根据需要修改NSInvocation对象。 NSInvocation不支持具有可变数量的参数或联合参数的方法的调用。您应该使用invocationWithMethodSignature：类方法来创建NSInvocation对象;你不应该使用alloc和init来创建这些对象。 此类不保留默认包含的调用的参数。如果这些对象可能在创建NSInvocation实例和使用它的时间之间消失，则应该自己保留对象或调用retainArguments方法以使调用对象保留它们本身。 总结一下：可以拿到参数和返回值,可以改selecter(方法签名相同),可以把消息分发给多个对象。相较于 forwardingTargetForSelector 只能拿到selector 灵活了很多。 forwardingTargetForSelector 相较于 forwardInvocation 的优点This method gives an object a chance to redirect an unknown message sent to it before the much more expensive forwardInvocation: machinery takes over. This is useful when you simply want to redirect messages to another object and can be an order of magnitude faster than regular forwarding. It is not useful where the goal of the forwarding is to capture the NSInvocation, or manipulate the arguments or return value during the forwarding. 简而言之，只做简单的消息转发时， 它比forwardInvocation 对性能的消耗要少。 我们需要注意 forwardInvocation，forwardingTargetForSelector 都会给指定的对象 再走一次 objc_msgsend流程。 forwardInvocation 相较于 forwardingTargetForSelector 消耗更大 forwardInvocation 可以拿到参数和返回值,可以改selecter(方法签名相同),可以把消息分发给多个对象。相较于 forwardingTargetForSelector 只能拿到selector 灵活了很多。 来看看C++中的方法调度机制直接调度直接调度是最快的一种。它不仅有最少的汇编指令，而且编译器也可以做各种智能优化，比如内联代码，许多其它本文不会涉及的东西。直接调度也常常被称为静态调度。 表调度表调度是编译型语言中最常见的动态行为的实现方式。表调度在类声明中为每一个方法用一个函数指针的数组。大多数语言称之为“虚表”。每一个子类都有它自己的一张父类表的拷贝，表中每个被覆盖的方法都是不同于父类的函数指针。当子类添加新的方法的时候，这些方法就被追加到这个数组的后面。然后在运行时就会访问这个表来决定执行哪个方法。 V-Table 和 dispatch table 的不同之处这里的虚表 与 Objective-C 中的dispatch table 完全是两个概念.虚表包含了当前类和父类的函数指针。dispatch table 仅仅包含了当前类的selector和MethodIMP的地址。 其实 Objective-C 中也有 V-Table其实OC中也有V-Table 它用来存放 最常调用的方法来加速程序的性能。这些方法直接通过V-table 调用。（执行msg_send()会花费更多的时间)每一个对象都有一个vtable point 指向 一些方法的IMP.objc-runtime-new.m 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/************************************************************************ vtable dispatch* * Every class gets a vtable pointer. The vtable is an array of IMPs.* The selectors represented in the vtable are the same for all classes* (i.e. no class has a bigger or smaller vtable).* Each vtable index has an associated trampoline which dispatches to * the IMP at that index for the receiver class's vtable (after * checking for NULL). Dispatch fixup uses these trampolines instead * of objc_msgSend.* Fragility: The vtable size and list of selectors is chosen at launch * time. No compiler-generated code depends on any particular vtable * configuration, or even the use of vtable dispatch at all.* Memory size: If a class's vtable is identical to its superclass's * (i.e. the class overrides none of the vtable selectors), then * the class points directly to its superclass's vtable. This means * selectors to be included in the vtable should be chosen so they are * (1) frequently called, but (2) not too frequently overridden. In * particular, -dealloc is a bad choice.* Forwarding: If a class doesn't implement some vtable selector, that * selector's IMP is set to objc_msgSend in that class's vtable.* +initialize: Each class keeps the default vtable (which always * redirects to objc_msgSend) until its +initialize is completed.* Otherwise, the first message to a class could be a vtable dispatch, * and the vtable trampoline doesn't include +initialize checking.* Changes: Categories, addMethod, and setImplementation all force vtable * reconstruction for the class and all of its subclasses, if the * vtable selectors are affected.**********************************************************************/static const char * const defaultVtable[] = { \"allocWithZone:\", \"alloc\", \"class\", \"self\", \"isKindOfClass:\", \"respondsToSelector:\", \"isFlipped\", \"length\", \"objectForKey:\", \"count\", \"objectAtIndex:\", \"isEqualToString:\", \"isEqual:\", \"retain\", \"release\", \"autorelease\", };static const char * const defaultVtableGC[] = { \"allocWithZone:\", \"alloc\", \"class\", \"self\", \"isKindOfClass:\", \"respondsToSelector:\", \"isFlipped\", \"length\", \"objectForKey:\", \"count\", \"objectAtIndex:\", \"isEqualToString:\", \"isEqual:\", \"hash\", \"addObject:\", \"countByEnumeratingWithState:objects:count:\", };","link":"/2017/05/01/Objective-C-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%92%8C%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/"},{"title":"cocoapods 新feature 开发 Example, On Demand Resource","text":"2016年 苹果提出了On Demand Resource这一特性。目的在于下载游戏等资源减少包大小。不过CocoaPods尚未对该特性进行支持，这导致我们不能在Pod中使用On Demand Resource。对于组件化开发的app来说，没有这一功能的支持，基本无法使用On Demand Resource。 因此针对CocoaPods开发了在 podspec 中 定义 on_demand_resources 字段，支持pod仓库使用On Demand Resource。 例如这样 1s.on_demand_resources = [\"Fuck\", \"You\"] Feature 实现思路我们做的操作就是 用代码实现 在Xcode 中手动添加 On Demand Resource 的效果。 拖一个文件进工程 在Resource Tag 设置中添加该文件 通过git diff, 我们可以发现对Xcode工程文件的改动在于： 添加文件 PBXBuildFile PBXFileReference ，并打上tag 新增 project 的 KnownAssetTags Attributed 添加 该文件到 ResourcesBuildPhase 我们只需要操作CocoaPods帮我们完成这些就搞定。 12345678910111213141516171819202122/* Begin PBXBuildFile section */569293632420BFAA00E13D4A /* R1 in Resources */ = {isa = PBXBuildFile; fileRef = 569293622420BFAA00E13D4A /* R1 */; settings = {ASSET_TAGS = (OnDemand, ); }; };/* Begin PBXFileReference section */569293622420BFAA00E13D4A /* R1 */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = R1; sourceTree = \"&lt;group&gt;\"; };A927A3B416DCDE828F76E9A4 /* fuck */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text; name = fuck; path = \"../../CocoaPodsTestLibrary-master/fuck\"; sourceTree = \"&lt;group&gt;\"; };/* Begin PBXProject section */ 5692933E2420BEDF00E13D4A /* Project object */ = { isa = PBXProject; attributes = { KnownAssetTags = ( OnDemand,);/* Begin PBXResourcesBuildPhase section */ 569293442420BEDF00E13D4A /* Resources */ = { isa = PBXResourcesBuildPhase; buildActionMask = 2147483647; files = ( 569293632420BFAA00E13D4A /* R1 in Resources */,); 实现哈哈 像我这种Command Copy Paste 高手，做需求靠抄就行了。首先确定要抄什么！ on_demand_resources 的 语法看起来和 resources 有点像。。 podspec 的 dsl 就抄他怎么实现的。抄他！ 文件添加到工程和 cocoapods将 xcconfig 添加到工程里比较像，抄他！！ 文件添加到build phase 并且打标签 和 添加资源文件比较像，抄他！！！ 一般iOS开发基本不会熟悉CocoaPods的源码，又是Ruby写的… 如何调试看一下我以前的文章。如何分析调试工程也参考我之前的文章。 新增Podspec DSL我找了一个类似新增podspec语法的 pull request, 大致知道了新增语法该该什么。 dsl.rb linter.rb specification.rb 首先要定位到CocoaPods中对 podspec 的处理流程，我直接写个错误的语法，通过报错的调用栈定位到了位置。 发现CocoaPods 将 Podspec中的内容 当作Ruby代码去执行 (ruby 的 eval)。知道了这个，就很容易摸清楚 podspec dsl 如何实现的了, 可以直接调试。通过调试，发现dsl的定义在 Core/lib/specification/dsl.rb中定义的。OK照葫芦画瓢，复制粘贴一下 resource 的 抄上… dsl 定义 12345678910111213141516171819# @!method on_demand_resources=(on_demand_resources)## A list of on_demand_resources that should be copied into the target bundle.## @example## spec.on_demand_resources = 'Resources/HockeySDK.bundle'## @example## spec.on_demand_resources = ['Images/*.png', 'Sounds/*']## @param [String, Array&lt;String&gt;] resources# The on_demand_resources shipped with the Pod.#attribute :on_demand_resources, :container =&gt; Array, :file_patterns =&gt; true, :singularize =&gt; true podspec 数据消费和lint 12345678910# @return [Array&lt;String&gt;] A hash where the key represents the# paths of the on_demand_resources to copy and the values the paths of# the on_demand_resources that should be copied.#spec_attr_accessor :on_demand_resources# Performs validations related to the `on_demand_resources` attribute.#def _validate_on_demand_resources(on_demand_resource)end 添加 On Demand Resource 文件哎，通过调试，找到了 cocoapods 集成Pods 到 Xcode Target 的关键文件。lib/cocoapods/installer/user_project_integrator/target_integrator.rb。 之后的操作又是通过调试和代码分析找到类似的功能如何实现，去理解CocoaPods的整个架构，再来实现我们的功能。CocoaPods的设计确实十分优秀，改的很爽。 1234567891011121314151617181920212223242526272829303132333435363738394041424344# Integrates the targets of the user projects with the on demand resources## @return [void]#def add_on_demand_resources attributes = target.user_project.root_object.attributes asset_tags = (attributes[\"KnownAssetTags\"] ||= []) unless asset_tags.include?(\"OnDemand\") asset_tags &lt;&lt; \"OnDemand\" end attributes[\"KnownAssetTags\"] = asset_tags target.user_project.root_object.attributes = attributes on_demand_resources_group = target.user_project.main_group[\"on_demand_resources\"] unless on_demand_resources_group on_demand_resources_group = target.user_project.main_group.new_group(\"on_demand_resources\", target.sandbox.root) end pb_target = target.user_project.objects_by_uuid[target.user_target_uuids[0]] old_on_demand_resource_file_refs = on_demand_resources_group.files pb_target.remove_on_demand_resources(old_on_demand_resource_file_refs) on_demand_resources_group.clear on_demand_resource_file_refs = [] target.pod_targets.each do |pod_target| pod_target.file_accessors.each {|file_accessor| file_accessor.on_demand_resources.each {|on_demand_resource| on_demand_resource_pathname = Pathname.new(File.expand_path(on_demand_resource)) file_ref = on_demand_resources_group.files.find {|file| file.real_path == on_demand_resource_pathname} unless file_ref file_ref = on_demand_resources_group.new_file(on_demand_resource) on_demand_resource_file_refs &lt;&lt; file_ref end } } end pb_target.add_on_demand_resources(on_demand_resource_file_refs)end lib/xcodeproj/project/object/native_target.rb 1234567891011121314151617181920212223242526272829# remove on demand resource files to the resources build phase of the target.## @param [Array&lt;PBXFileReference&gt;] on_demand_resource_file_references# the files references of the on demand resources to the target.## @return [void]#def remove_on_demand_resources(on_demand_resource_file_references) on_demand_resource_file_references.each do |file| resources_build_phase.remove_file_reference(file) endend# Adds on demand resource files to the resources build phase of the target.## @param [Array&lt;PBXFileReference&gt;] on_demand_resource_file_references# the files references of the on demand resources to the target.## @return [void]#def add_on_demand_resources(on_demand_resource_file_references) on_demand_resource_file_references.each do |file| next if resources_build_phase.include?(file) build_file = project.new(PBXBuildFile) build_file.file_ref = file build_file.settings = (build_file.settings ||= {}).merge({\"ASSET_TAGS\" =&gt; [\"OnDemand\"]}) resources_build_phase.files &lt;&lt; build_file endend 分析阅读CocoaPods源码的几个关键名词PodTarget pod的targetAggregateTarget 需要集成pod的项目的target，例如我们app的targetSandbox CocoaPods对于 我们Pods 和 工程的 沙盒文件处理DSL podfile podspec中定义的语法defind_method CocoaPods 通过动态生成方法的方式，处理简单的语法","link":"/2020/03/19/cocoapods-new-feature/"},{"title":"CocoaPods插件开发原理(一) CocoaPods做了啥","text":"最近入职手淘，搞了一下基于CocoaPods的工程化的升级改造优化。自己也是第一次接触这块，写篇文章总结一下。 开发基础CocoaPods插件开发会涉及到的各种概念。 RubyGems: Ruby程序包管理器Gemfile: 定义你的应用依赖哪些第三方包，bundle根据该配置去寻找这些包。Gem: 封装起来的Ruby应用程序或代码库。Bundle: 根据Gemfile安装插件 CocoaPods调试 克隆CocoaPods代码. 安装RubyMine. 通过RubyMine打开工程，会提示install gems.. 点点点… add Configurations CocoaPods产物分析针对于代码工程项目来说，CocoaPods和Xcode的一系列操作，最终都会体现到 build 过程中。 可以看到 主要是 compile, link. 资源文件的处理。 对于CocoaPods来说，他的处理结果体现在对Xcode工程配置文件的一系列操作。根据pod install 后查 看 diff, 可以简单的分析一下 做了什么。 主要关注 project 文件的diff xcconfig 的diff resource 脚本 TestCocoaPods.xcodeproj/project.pbxproj: 工程配置文件。http://www.monobjc.net/xcode-project-file-format.html 可以看到对于原始的project, 主要做了以下处理： 1. 配置xcconfig 2. framework链接 Pods_TestCocoaPods.framework 3. 增加 Check Pods Manifest.lock , resource 资源拷贝 操作 *工程文件的diff, 主要是增加文件引用，build phase. * 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576PBXBuildFile section:E01C29225DD71613589489FA /* Pods_TestCocoaPods.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = CB005D1B7C8E0A3D6341DB9D /* Pods_TestCocoaPods.framework */; };PBXFileReference section:105074B73663D0E4918F3F90 /* Pods-TestCocoaPods.release.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = &quot;Pods-TestCocoaPods.release.xcconfig&quot;; path = &quot;Target Support Files/Pods-TestCocoaPods/Pods-TestCocoaPods.release.xcconfig&quot;; sourceTree = &quot;&lt;group&gt;&quot;; };60972A114A3E4366A5836A94 /* Pods-TestCocoaPods.debug.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = &quot;Pods-TestCocoaPods.debug.xcconfig&quot;; path = &quot;Target Support Files/Pods-TestCocoaPods/Pods-TestCocoaPods.debug.xcconfig&quot;; sourceTree = &quot;&lt;group&gt;&quot;; };CB005D1B7C8E0A3D6341DB9D /* Pods_TestCocoaPods.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Pods_TestCocoaPods.framework; sourceTree = BUILT_PRODUCTS_DIR; };PBXFrameworksBuildPhase:files = ( E01C29225DD71613589489FA /* Pods_TestCocoaPods.framework in Frameworks */,);PBXGroup:22AD612E85507BD42F801917 /* Frameworks */ = { isa = PBXGroup; children = ( CB005D1B7C8E0A3D6341DB9D /* Pods_TestCocoaPods.framework */, ); name = Frameworks; sourceTree = &quot;&lt;group&gt;&quot;;};563D16002378227800AFB290 = { isa = PBXGroup; children = ( C7867C96DA44D37863BEC94B /* Pods */, 22AD612E85507BD42F801917 /* Frameworks */, ); sourceTree = &quot;&lt;group&gt;&quot;;};C7867C96DA44D37863BEC94B /* Pods */ = { isa = PBXGroup; children = ( 60972A114A3E4366A5836A94 /* Pods-TestCocoaPods.debug.xcconfig */, 105074B73663D0E4918F3F90 /* Pods-TestCocoaPods.release.xcconfig */, ); name = Pods; path = Pods; sourceTree = &quot;&lt;group&gt;&quot;;};PBXNativeTarget:buildPhases = ( 66B2CF8865E26539A7BF8BC7 /* [CP] Check Pods Manifest.lock */,);PBXShellScriptBuildPhase:/* Begin PBXShellScriptBuildPhase section */ 66B2CF8865E26539A7BF8BC7 /* [CP] Check Pods Manifest.lock */ = { isa = PBXShellScriptBuildPhase; buildActionMask = 2147483647; files = ( ); inputFileListPaths = ( ); inputPaths = ( &quot;${PODS_PODFILE_DIR_PATH}/Podfile.lock&quot;, &quot;${PODS_ROOT}/Manifest.lock&quot;, ); name = &quot;[CP] Check Pods Manifest.lock&quot;; outputFileListPaths = ( ); outputPaths = ( &quot;$(DERIVED_FILE_DIR)/Pods-TestCocoaPods-checkManifestLockResult.txt&quot;, ); runOnlyForDeploymentPostprocessing = 0; shellPath = /bin/sh; shellScript = &quot;diff \\&quot;${PODS_PODFILE_DIR_PATH}/Podfile.lock\\&quot; \\&quot;${PODS_ROOT}/Manifest.lock\\&quot; &gt; /dev/null\\nif [ $? != 0 ] ; then\\n # print error to STDERR\\n echo \\&quot;error: The sandbox is not in sync with the Podfile.lock. Run &apos;pod install&apos; or update your CocoaPods installation.\\&quot; &gt;&amp;2\\n exit 1\\nfi\\n# This output is used by Xcode &apos;outputs&apos; to avoid re-running this script phase.\\necho \\&quot;SUCCESS\\&quot; &gt; \\&quot;${SCRIPT_OUTPUT_FILE_0}\\&quot;\\n&quot;; showEnvVarsInLog = 0; };/* End PBXShellScriptBuildPhase section */XCBuildConfiguration:563D16232378227900AFB290 /* Debug */ = { baseConfigurationReference = 60972A114A3E4366A5836A94 /* Pods-TestCocoaPods.debug.xcconfig */;} Target Support Files/Pods-TestCocoaPods/Pods-TestCocoaPods.debug.xcconfig:主要处理了 头文件路径，库路径，链接配置 12345678FRAMEWORK_SEARCH_PATHS = $(inherited) &quot;${PODS_ROOT}/AliColor&quot;GCC_PREPROCESSOR_DEFINITIONS = $(inherited) COCOAPODS=1LD_RUNPATH_SEARCH_PATHS = $(inherited) &apos;@executable_path/Frameworks&apos; &apos;@loader_path/Frameworks&apos;OTHER_LDFLAGS = $(inherited) -ObjC -framework &quot;AliColor&quot;PODS_BUILD_DIR = ${BUILD_DIR}PODS_CONFIGURATION_BUILD_DIR = ${PODS_BUILD_DIR}/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)PODS_PODFILE_DIR_PATH = ${SRCROOT}/.PODS_ROOT = ${SRCROOT}/Pods CocoaPods Framework 资源管理在Github找了MJRefresh,其里面包含了一些资源文件。pod install 之后，build phase 中有 Pods-xxx-framework.sh 其中对资源文件做了处理 主要的内容如下: 123456789# Use filter instead of exclude so missing patterns don&apos;t throw errors.echo &quot;rsync --delete -av &quot;${RSYNC_PROTECT_TMP_FILES[@]}&quot; --filter \\&quot;- CVS/\\&quot; --filter \\&quot;- .svn/\\&quot; --filter \\&quot;- .git/\\&quot; --filter \\&quot;- .hg/\\&quot; --filter \\&quot;- Headers\\&quot; --filter \\&quot;- PrivateHeaders\\&quot; --filter \\&quot;- Modules\\&quot; \\&quot;${source}\\&quot; \\&quot;${destination}\\&quot;&quot;rsync --delete -av &quot;${RSYNC_PROTECT_TMP_FILES[@]}&quot; --filter &quot;- CVS/&quot; --filter &quot;- .svn/&quot; --filter &quot;- .git/&quot; --filter &quot;- .hg/&quot; --filter &quot;- Headers&quot; --filter &quot;- PrivateHeaders&quot; --filter &quot;- Modules&quot; &quot;${source}&quot; &quot;${destination}&quot;# Strip invalid architectures so &quot;fat&quot; simulator / device frameworks work on deviceif [[ &quot;$(file &quot;$binary&quot;)&quot; == *&quot;dynamically linked shared library&quot;* ]]; thenstrip_invalid_archs &quot;$binary&quot;fi# Resign the code if required by the build settings to avoid unstable apps code_sign_if_enabled &quot;${destination}/$(basename &quot;$1&quot;)&quot; Build 一下，看看Log，可以看到拷贝了资源文件 12345678910111213141516171819202122232425262728PhaseScriptExecution [CP]\\ Embed\\ Pods\\ Frameworks /Users/xiejunyi/Library/Developer/Xcode/DerivedData/TestCocoaPods-emoajnwkneawvvazmpgriocqboko/Build/Intermediates.noindex/TestCocoaPods.build/Debug-iphonesimulator/TestCocoaPods.build/Script-2FE0977B29313E1B2691D262.sh (in target &apos;TestCocoaPods&apos; from project &apos;TestCocoaPods&apos;) cd /Users/xiejunyi/Library/Mobile\\ Documents/com~apple~CloudDocs/codes/Demos/TestCocoaPods /bin/sh -c /Users/xiejunyi/Library/Developer/Xcode/DerivedData/TestCocoaPods-emoajnwkneawvvazmpgriocqboko/Build/Intermediates.noindex/TestCocoaPods.build/Debug-iphonesimulator/TestCocoaPods.build/Script-2FE0977B29313E1B2691D262.shmkdir -p /Users/xiejunyi/Library/Developer/Xcode/DerivedData/TestCocoaPods-emoajnwkneawvvazmpgriocqboko/Build/Products/Debug-iphonesimulator/TestCocoaPods.app/Frameworksrsync --delete -av --filter P .*.?????? --filter &quot;- CVS/&quot; --filter &quot;- .svn/&quot; --filter &quot;- .git/&quot; --filter &quot;- .hg/&quot; --filter &quot;- Headers&quot; --filter &quot;- PrivateHeaders&quot; --filter &quot;- Modules&quot; &quot;/Users/xiejunyi/Library/Developer/Xcode/DerivedData/TestCocoaPods-emoajnwkneawvvazmpgriocqboko/Build/Products/Debug-iphonesimulator/MJRefresh/MJRefresh.framework&quot; &quot;/Users/xiejunyi/Library/Developer/Xcode/DerivedData/TestCocoaPods-emoajnwkneawvvazmpgriocqboko/Build/Products/Debug-iphonesimulator/TestCocoaPods.app/Frameworks&quot;building file list ... doneMJRefresh.framework/MJRefresh.framework/Info.plistMJRefresh.framework/MJRefreshMJRefresh.framework/MJRefresh.bundle/MJRefresh.framework/MJRefresh.bundle/arrow@2x.pngMJRefresh.framework/MJRefresh.bundle/en.lproj/MJRefresh.framework/MJRefresh.bundle/en.lproj/Localizable.stringsMJRefresh.framework/MJRefresh.bundle/ko.lproj/MJRefresh.framework/MJRefresh.bundle/ko.lproj/Localizable.stringsMJRefresh.framework/MJRefresh.bundle/zh-Hans.lproj/MJRefresh.framework/MJRefresh.bundle/zh-Hans.lproj/Localizable.stringsMJRefresh.framework/MJRefresh.bundle/zh-Hant.lproj/MJRefresh.framework/MJRefresh.bundle/zh-Hant.lproj/Localizable.stringsMJRefresh.framework/_CodeSignature/MJRefresh.framework/_CodeSignature/CodeResourcessent 240510 bytes received 238 bytes 481496.00 bytes/sectotal size is 239605 speedup is 1.00Code Signing /Users/xiejunyi/Library/Developer/Xcode/DerivedData/TestCocoaPods-emoajnwkneawvvazmpgriocqboko/Build/Products/Debug-iphonesimulator/TestCocoaPods.app/Frameworks/MJRefresh.framework with Identity -/usr/bin/codesign --force --sign - --preserve-metadata=identifier,entitlements &apos;/Users/xiejunyi/Library/Developer/Xcode/DerivedData/TestCocoaPods-emoajnwkneawvvazmpgriocqboko/Build/Products/Debug-iphonesimulator/TestCocoaPods.app/Frameworks/MJRefresh.framework&apos;/Users/xiejunyi/Library/Developer/Xcode/DerivedData/TestCocoaPods-emoajnwkneawvvazmpgriocqboko/Build/Products/Debug-iphonesimulator/TestCocoaPods.app/Frameworks/MJRefresh.framework: replacing existing signature 以上基本涵盖了一个简单工程，CocoaPods进行的主要操作。 下一篇 CocoaPods插件开发原理(二) 定制项目CocoaPods插件环境下一篇 CocoaPods插件开发原理(三) 调试与开发CocoaPods插件","link":"/2019/10/05/cocoapodsdev/"},{"title":"cpython3.8瘦身到0.95mb","text":"","link":"/2020/10/05/cpythonstrip/"},{"title":"Block ABI 文档阅读","text":"记得很久很久以前。。。有本iOS开发进阶的书籍讲了block实现。通过分析clang生成的代码来反推block的原理。卧槽最近搜了一下block，发现clang是有abi文档的。。。看了一下文档果然清晰许多。结合最近遇到的问题实践了一下block的知识。 Block ABI文档，详细的介绍了Block的构成及其内存管理相关的实现。参考这片文档。https://clang.llvm.org/docs/Block-ABI-Apple.html Block数据结构通过这个数据结构，Block对外界变量的使用，Block内存管理，一目了然。 123456789101112131415161718192021222324252627282930313233struct Block_literal_1 { void *isa; // initialized to &amp;_NSConcreteStackBlock or &amp;_NSConcreteGlobalBlock int flags; int reserved; void (*invoke)(void *, ...); struct Block_descriptor_1 { unsigned long int reserved; // NULL unsigned long int size; // sizeof(struct Block_literal_1) // optional helper functions void (*copy_helper)(void *dst, void *src); // IFF (1&lt;&lt;25) void (*dispose_helper)(void *src); // IFF (1&lt;&lt;25) // required ABI.2010.3.16 const char *signature; // IFF (1&lt;&lt;30) } *descriptor; // imported variables // 引用 struct Block_byref_foo { void *isa; struct _block_byref_foo *forwarding; int flags; //refcount; int size; // helper functions called via Block_copy() and Block_release() void (*byref_keep)(void *dst, void *src); void (*byref_dispose)(void *); typeof(marked_variable) marked_variable; } *byref_foo; // 常量拷贝 const int x; struct __block_literal_3 *const existingBlock; ...}; 利用Block的布局定位Crash最近看同事解决一个crash, 挂在了_Block_release，并且没有相关的app调用栈。针对这种crash，如果不去拿到block的信息，是没法定位的。这个问题最后是通过手动复现+调试去解决的。 1234Thread 0 Crashed:0 libobjc.A.dylib 0x000000018879c140 _objc_release :16 (in libobjc.A.dylib)1 libsystem_blocks.dylib 0x000000018864da48 _Block_release :152 (in libsystem_blocks.dylib)2 libsystem_blocks.dylib 0x000000018864da48 _Block_release :152 (in libsystem_blocks.dylib) 在crash崩溃的时候，其实是可以尝试对崩溃现场使用到的相关内存进行数据解析，获取有用的信息。kscrash 包含对对象的数据解析，但是并没有block。这片文章就看一下block的实现原理，然后进行解析。 非常简单，block的函数实现地址 保存在了结构体内的 invoke 变量。取出地址，再符号化就可以对应出代码行了。 1234567891011121314151617// 定义block结构，方便取值，这个参考ABI。typedef struct fake_block_literal { void *isa; int flags; int reserved; void (*invoke)(struct fake_block_literal *); // 调用地址 struct fake_block_descriptor *descriptor;} fake_block_literal;typedef struct fake_block_descriptor { unsigned long int reserved; unsigned long int Block_size; void (*copy_helper)(struct fake_block_literal *dst, struct fake_block_literal *src); void (*dispose_helper)(struct fake_block_literal *);} fake_block_descriptor;fake_block_literal *block_literal = (__bridge fake_block_literal *)address; 结束语ARC,Block这种通过编译器和运行时一起完成的语言feature，通过编译器文档进行学习是快速理解原理的好办法。下周，看看ARC的实现。","link":"/2020/02/19/crashruntimeinfo/"},{"title":"关于架构和编码的思考","text":"长期更新，记录我对设计架构的理解 控制反转A,B,C三个组件，如果可以互相调用，则ABC互相依赖。在大型项目中，这种会造成组件间耦合紧密的问题。 思考一下，组件间调用的本质 有组件的实例 接口 拥有组件的实例，我们直接拥有另一个组件，这显然是依赖的。 如何在尽量减少依赖的情况下解决这些问题呢？ 可以通过反射的方式, 需要建立 {组件}&lt;-&gt;{字符串} 的映射表，把关系转移到了配置文件中，这种方式存在安全性问题，因为没有编译器的强类型检查。 建立映射关系。我们可以 建立Class和某种物件的映射， 因为有protocol的存在，接口的问题被解决了。于是建立Class和Protocol的映射，可以获得实例的同时也知晓接口。这就构成了一个组件调用的基础条件。并且我们需要一个manager替我们管理映射。 在2中，依赖关系变成了如下{组件}-&gt;{manager}-&gt;{interface} 组件的耦合转移到了组件和interface的耦合。这在工程维护中存在一个问题，我们需要维护一个庞大的protocol列表。不过相比于组件间相互依赖，这种做法好了很多。 接口类映射 和 反射 的选择我个人愿意维护protocols，而不是维护组件字符串映射表。 从逻辑上说，无法实现双方相互隐藏。这无非是 “关系” 的体现方式不同。我选择程序内的映射关系，有编译器检查。 依赖倒置传统的过程性系统的设计方法倾向于使高层次的模块依赖于低层次的模块，抽象层次依赖于具体层次。而依赖倒置则将{高层次模块，低层次模块}-&gt;{抽象接口}，这样无论上层还是下层的整个模块出现了替换，只要接口不变化，就不需要修改另一层次的模块。 这里值得注意的是，低层次模块依赖了高层次模块中定义的接口。当我们把低层次模块拆分后，将其用于别的项目时，会出现问题。对此我的想法是： 如果高层次模块需要和底层次模块完全隔离，方便的替换整个低层次模块的实现，那么使用依赖倒置。 如果没有1中的需求，那么还是直接依赖低层次模块，我认为低层次模块本身的接口暴露合理，内部实现的改动也不会对高层次模块有什么影响。 采用接口的成本 接口定义，接口维护，遵循类维护 如果暴露了一些定义的数据结构、类，则这些也需要抽象。会造成很多重复的代码。我觉得还是尽量只在必要情况下使用接口， 足够底层的类，可以放到核心库中。让所有模块都依赖呗。 接口适用于 同级别模块间的服务交互 包装一下我们使用高层模块时，其实就是构造一个符合接口的东西而已。底层模块A去遵循高层模块的协议，无疑让底层模块无法复用。这时候我们可以再新建一个类C，让C去遵循协议，C通过A来构建自己。 单一职责和关注点分离原则关注点分离要求每一个功能对应一个单独的任务，每一个功能都要在一个独立的模块中实现。每个模块都有自己的职责，而不会关注其他模块的职责。如果一个类包含多个职责，要求改其中的一个职责，则可能会影响该类里其他职责的实现。单一职责原则要求每个类只包含一个职责，所有方法都应该为了实现该职责。要修改一个类的职责，只涉及该类。 例子：Record和Log写在一起？场景：Record模块，存储了Crash的信息。我们需要生成某种格式的日志。Record把生成日志的代码通过分类实现。这里通过category的实现，方便，不会引入单独的类。把格式化生成log的职责放在了record模块里。但是Log是个改动频繁的功能，兼具有相当多的扩展性(多种格式..)。仅是log当做Record的一个功能，职责和灵活性都说不过去。Record应仅关注信息的记录。把Log当做另一个同等级模块来看待。 做法1：把Log和Record拆分为同等级的模块，Log模块依赖于Record,生成相应的日志。这里纠正一个错误，有同学说，既然存在依赖，那就用分类好了不需要拆分。模块拆分和依赖无关，关注的是职责分离和粒度控制，是通过现在情况和未来发展做出的判断。 从框架开发的角度来看，Record和Log都是独立的模块，不能互相依赖。Log模块需要元数据，我们可以定义Info协议，Log依赖Info协议。当需要生成log时，我们构造一个遵循Info协议的类RecordInfo，给Log使用即可。多了一层中间层，但是把 Record和Log隔离出来，两者都可以复用。 维护成本由 Log和Record 的使用者承担。这是做的很干净的写法，适用于需要复用的情况，如果仅仅把Log用在固定的场景，那么直接依赖元数据类也是可以的。 策略控制现在对于 某个功能 有一个实现A， 此时，在A的实现的基础上出现了另一种分支，达到B的效果。 在A的代码中，修改逻辑是常用的做法，借此实现AB功能。但这样破坏了原有的功能，使得逻辑日渐复杂。我认为相对合理的做法是，将AB的共同逻辑抽取，差异逻辑分开。如果实现代码很多，可以拆分成两个策略类。关于func还是strategy class可以根据代码量和复杂程度来权衡。 软件开发中是无法避免依赖的，我们可以把相关的逻辑放在类中，也可以放在函数中。我认为这本质上是一样的。粒度是开发过程中需要考虑的问题。合理的设计出最适用用与当下的框架，不过度设计。要知道我们无法从根本上改变软件逐渐增大的复杂度，我们能做的是改变自己的编码方式，将逻辑写的合理清晰就好了。 创建模式的思考 工厂模式 生产一类物品 抽象工厂模式 生产多类物品 生成器模式 构造复杂的产品 工厂模式将实现代码与暴露的接口隔离。抽象工厂模式在工厂模式的基础上将多种工厂的能力统一暴露。生成器模式关注于复杂对象的步骤生成。 创建模式都将实现与产品隔离。生成器模式相较于抽象工厂模式，在对象的生成中更加细化，将生成的对象各个步骤隔离，各个步骤可以组合。而抽象工厂模式适用于简单的对象生成。 我认为，本质上，创建者模式，通过依赖注入，以统一的接口分发不同的实现。可以根据实际情况，根据复杂度选择合适的做法。 契约式设计DbC的核心思想是对软件系统中的元素之间相互合作以及“责任”与“义务”的比喻。这种比喻从商业活动中“客户”与“供应商”达成“契约”而得来。例如： 供应商必须提供某种产品（责任），并且他有权期望客户已经付款（权利）。 客户必须付款（责任），并且有权得到产品（权利）。 契约双方必须履行那些对所有契约都有效的责任，如法律和规定等。 同样的，如果在面向对象程序设计中一个类的函数提供了某种功能，那么它要： 期望所有调用它的客户模块都保证一定的进入条件：这就是函数的先验条件—客户的义务和供应商的权利，这样它就不用去处理不满足先验条件的情况。 保证退出时给出特定的属性：这就是函数的后验条件—供应商的义务，显然也是客户的权利。 在进入时假定，并在退出时保持一些特定的属性：不变条件。 调用方和被调用方相互负责的看法在写code中经常会遇到 不知道一些guard 条件到底写在哪好。写在调用方，逻辑清晰一些。写在被调用方，可以减少代码冗余。 我个人觉得这样的写法比较合适: 调用者体内会被改变的状态，在调用者做校验。 被调用者处理上下文的一些信息。 当被调用者的guard逻辑重复多次，考虑将判断逻辑抽象成函数。","link":"/2018/04/13/dependency/"},{"title":"DWARF和符号化","text":"DWARF 格式简介DWARF: 它是可执行程序与源代码关系的一个紧凑的表示. 大多数现代编程语言是块结构的：每个实体（例如，一个类定义或一个函数）被包含在另一个实体中。在一个C程序里，每个文件可能包含多个数据定义、多个变量定义，及多个函数。DWARF遵循这个模型，它也是块结构的。在DWARF里基本的描述项是调试信息项（DebuggingInformation Entry——DIE）。一个DIE有一个标签，它指明了这个DIE描述什么及一个填入了细节并进一步描述该项的属性列表。一个DIE（除了最顶层的）被一个父DIE包含（或者说拥有），并可能有兄弟DIE或子DIE。属性可能包含各种值：常量（比如一个函数名），变量（比如一个函数的起始地址），或对另一个DIE的引用（比如一个函数的返回值类型）。 利用DWARF符号化符号化地址，我们期望的结果是，获取地址对应的函数名称和调用行数等信息。DWARF调试格式中携带了大量信息，当然包括函数名称和地址。因此如果我们提供的调用地址能在函数中找到信息，优先使用DWARF中的符号信息进行符号化。 在 DWARF 中，这些信息主要由 DW_AT_subprogram 和 line table 承载。我们只需要根据地址在 DWARF 文件中找到对应的 信息。 函数名称DW_AT_Subprogram 中可以获取到的信息 很容易看到，Dwarf调试信息中精心设计了 函数信息的具体表示，我们可以获取名称和类型等重要的信息。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859601$: DW_TAG_unspecified_type DW_AT_name(\"void\") ...2$ DW_TAG_base_type DW_AT_name(\"int\") ...3$: DW_TAG_class_type DW_AT_name(\"A\") ...4$: DW_TAG_pointer_type DW_AT_type(reference to 3$) ...5$: DW_TAG_const_type DW_AT_type(reference to 3$) ...6$: DW_TAG_pointer_type DW_AT_type(reference to 5$) ...7$: DW_TAG_subprogram DW_AT_name(\"func1\") DW_AT_type(reference to 1$) DW_AT_object_pointer(reference to 8$) ! References a formal parameter in this member function ...8$: DW_TAG_formal_parameter DW_AT_artificial(true) DW_AT_name(\"this\") DW_AT_type(reference to 4$) ! Makes type of 'this' as 'A*' =&gt; ! func1 has not been marked const or volatile DW_AT_location ... ...9$: DW_TAG_formal_parameter DW_AT_name(x1) DW_AT_type(reference to 2$) ...10$: DW_TAG_subprogram DW_AT_name(\"func2\") DW_AT_type(reference to 1$) DW_AT_object_pointer(reference to 11$) ! References a formal parameter in this member function ...11$: DW_TAG_formal_parameter DW_AT_artificial(true) DW_AT_name(\"this\") DW_AT_type(reference to 6$) ! Makes type of 'this' as 'A const*' =&gt; ! func2 marked as const DW_AT_location ... ...12$: DW_TAG_subprogram DW_AT_name(\"func3\") DW_AT_type(reference to 1$) ... ! No 'this' formal parameter =&gt; func3 is static13$: DW_TAG_formal_parameter DW_AT_name(x3) DW_AT_type(reference to 2$) ... 内联函数处理对于内联函数，编译器会将其在多处展开。可以通过 DW_AT_inline 标志判断其展开的状态和判断其是否是”abstract instance entry”.基于存储空间的考虑，把 某个内联函数构造成 “abstract instance entry” 提供名称等信息，可以避免多个具体内联函数展开的重复空间消耗。 12345678910111213141516171819202122232425262728293031323334353637383940414243 ! Abstract instance for OUTER !OUTER.AI.1.1: DW_TAG_subprogram DW_AT_name(\"OUTER\") DW_AT_inline(DW_INL_declared_inlined) ! No low/high PCsOUTER.AI.1.2: DW_TAG_formal_parameter DW_AT_name(\"OUTER_FORMAL\") DW_AT_type(reference to integer) ! No locationOUTER.AI.1.3: DW_TAG_variable DW_AT_name(\"OUTER_LOCAL\") DW_AT_type(reference to integer) ! No location ! ! Abstract instance for INNER !INNER.AI.1.1: DW_TAG_subprogram DW_AT_name(\"INNER\") DW_AT_inline(DW_INL_declared_inlined) ! No low/high PCsINNER.AI.1.2: DW_TAG_formal_parameter DW_AT_name(\"INNER_FORMAL\") DW_AT_type(reference to integer) ! No locationINNER.AI.1.3: DW_TAG_variable DW_AT_name(\"INNER_LOCAL\") DW_AT_type(reference to integer) ! No location ... 0 ! No DW_TAG_inlined_subroutine (concrete instance) ! for INNER corresponding to calls of INNER ... 0Figure 66. Inlining example #1: abstract instance concrete instance 表示编译时，某处内联函数的展开。它最主要的信息就是 DW_AT_low_pc,DW_AT_high_pc 通过pc地址信息，我们可以将函数调用地址定位到具体的DWARF debug entry。由于存在 “abstract instance”，”concrete instance” 的某些属性会被省略，因此我们需要通过 DW_AT_abstract_origin 属性去找到对应的 abstract instance entry，获取被省略掉的信息。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 ! Concrete instance for call \"OUTER(7)\" !OUTER.CI.1.1: DW_TAG_inlined_subroutine ! No name DW_AT_abstract_origin(reference to OUTER.AI.1.1) DW_AT_low_pc(...) DW_AT_high_pc(...)OUTER.CI.1.2: DW_TAG_formal_parameter ! No name DW_AT_abstract_origin(reference to OUTER.AI.1.2) DW_AT_const_value(7)OUTER.CI.1.3: DW_TAG_variable ! No name DW_AT_abstract_origin(reference to OUTER.AI.1.3) DW_AT_location(...) ! ! No DW_TAG_subprogram (abstract instance) for INNER ! ! Concrete instance for call INNER(OUTER_LOCAL) ! INNER.CI.1.1: DW_TAG_inlined_subroutine ! No name DW_AT_abstract_origin(reference to INNER.AI.1.1) DW_AT_low_pc(...) DW_AT_high_pc(...) DW_AT_static_link(...)INNER.CI.1.2: DW_TAG_formal_parameter ! No name DW_AT_abstract_origin(reference to INNER.AI.1.2) DW_AT_location(...)INNER.CI.1.3: DW_TAG_variable ! No name DW_AT_abstract_origin(reference to INNER.AI.1.3) DW_AT_location(...) ... 0 ! Another concrete instance of INNER within OUTER ! for the call \"INNER(31)\" ... 0 非定义调试信息项处理当函数定义并不在声明区域时，subprogram DIE 就会有 DW_AT_specification 属性，指向相关的函数定义DIE.对于带有 DW_AT_specification 的调试信息项，我们需要进行特殊处理。 定位地址对应Dwarf debug infobacktrace() 我们可以拿到 image 的 loadaddress 和 address调用地址。 进而得到文件虚拟地址fileVmAddress = address - (loadaddress - imageFileVmTextAddress) 通过文件虚拟地址后通过 .debug_aranges 查找到指定的 DWARF compile unit，进而查找到具体的DIE. 从属性中获取我们需要的信息。 .debug_aranges 是DWARF 中包含 debug info entry offset的 Section。DWARF compile unit 是编译单元，在这里我们可以理解为文件或文件中的片段。也是DIE 行号信息对于一个文件，我们将其编译后，其产出汇编代码类似于这种形式，在原始文件中的行对应着多条汇编指令。对于行号的查找我们只需要 将符号的运行时地址转换为文件的虚拟地址，在该文件的行号信息中进行范围查找即可。 12345678910111213141516171819201: int2: main() 0x239: push pb 0x23a: mov bp,sp3: {4: printf(“Omit needless words\\n”); 0x23c: mov ax,0xaa 0x23f: push ax 0x240: call _printf 0x243: pop cx5: exit(0); 0x244: xor ax,ax 0x246: push ax 0x247: call _exit 0x24a: pop cx6: } 0x24b: pop bp 0x24c: ret7: 0x24d: 对应的编码类似于: SPECIAL(n,m) 制定了行号增加和地址增加 123456789Opcode Operand Byte Stream--------------------------------------------------------------------------------DW_LNS_advance_pc LEB128(0x239) 0x2, 0xb9, 0x04SPECIAL(2, 0) 0xbSPECIAL(2, 3) 0x38SPECIAL(1, 8) 0x82SPECIAL(1, 7) 0x73DW_LNS_advance_pc LEB128(2) 0x2, 0x2DW_LNE_end_sequence 0x0, 0x1, 0x1 利用symtab符号化当我们代码编译的时候，可以选择产生调试信息。也可以不产生调试信息，作为降级方案，我们仍可采用symbtab所包含的信息进行符号化。symtab段我们可以提取到具体符号的地址，对应字符串表中的偏移地址，很容易就取到对应的符号名称。 具体可以参考各种实现，这里贴一段fishhook里的代码段 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162static void rebind_symbols_for_image(struct rebindings_entry *rebindings, const struct mach_header *header, intptr_t slide) { Dl_info info; if (dladdr(header, &amp;info) == 0) { return; } printf(\"dli_fname:%s \\ndli_sname:%s\", info.dli_fname, info.dli_sname); segment_command_t *cur_seg_cmd; segment_command_t *linkedit_segment = NULL; struct symtab_command* symtab_cmd = NULL; struct dysymtab_command* dysymtab_cmd = NULL; uintptr_t cur = (uintptr_t)header + sizeof(mach_header_t); for (uint i = 0; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) { cur_seg_cmd = (segment_command_t *)cur; if (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) { if (strcmp(cur_seg_cmd-&gt;segname, SEG_LINKEDIT) == 0) { linkedit_segment = cur_seg_cmd; } } else if (cur_seg_cmd-&gt;cmd == LC_SYMTAB) { symtab_cmd = (struct symtab_command*)cur_seg_cmd; } else if (cur_seg_cmd-&gt;cmd == LC_DYSYMTAB) { dysymtab_cmd = (struct dysymtab_command*)cur_seg_cmd; } } if (!symtab_cmd || !dysymtab_cmd || !linkedit_segment || !dysymtab_cmd-&gt;nindirectsyms) { return; } // Find base symbol/string table addresses uintptr_t linkedit_base = (uintptr_t)slide + linkedit_segment-&gt;vmaddr - linkedit_segment-&gt;fileoff; nlist_t *symtab = (nlist_t *)(linkedit_base + symtab_cmd-&gt;symoff); char *strtab = (char *)(linkedit_base + symtab_cmd-&gt;stroff); // Get indirect symbol table (array of uint32_t indices into symbol table) uint32_t *indirect_symtab = (uint32_t *)(linkedit_base + dysymtab_cmd-&gt;indirectsymoff); cur = (uintptr_t)header + sizeof(mach_header_t); for (uint i = 0; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) { cur_seg_cmd = (segment_command_t *)cur; if (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) { if (strcmp(cur_seg_cmd-&gt;segname, SEG_DATA) != 0 &amp;&amp; strcmp(cur_seg_cmd-&gt;segname, SEG_DATA_CONST) != 0) { continue; } for (uint j = 0; j &lt; cur_seg_cmd-&gt;nsects; j++) { section_t *sect = (section_t *)(cur + sizeof(segment_command_t)) + j; if ((sect-&gt;flags &amp; SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS) { perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab); } if ((sect-&gt;flags &amp; SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS) { perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab); } } } }} 优化符号化工具提供了 将函数地址 转化为 具体名称等信息的能力。但是提供大规模的符号化能力，需要在 网络I/O,缓存,Server端进一步的优化，这些优化我会写在内网Wiki上 hhhhh… 写在最后符号化仅是DWARF提供能力的冰山一角，作为提供给 lldb, gdb等调试器的文件格式，蕴含着大量的信息，也就是说，上传了DWARF文件，也相当于应用裸奔了…","link":"/2018/09/30/dwarf%E5%92%8C%E7%AC%A6%E5%8F%B7%E5%8C%96/"},{"title":"链接和App启动速度优化","text":"最近看了链接相关的知识，结合 WWDC 2篇Session 和 iOS 启动优化 做一下总结. 1 链接相关的基础知识1.1 从main.c到一个可执行目标文件我们的源程序main.c 经过C预处理器 翻译成一个ASCII中间文件 main.i,接下来 驱动程序运行C编译器，它将main.i翻译成一个ASCII汇编语言文件main.s,然后驱动程序运行汇编器，它讲main.s翻译成一个可重定位目标文件main.o,链接器程序将main.o和一些必要的系统目标文件组合起来,创建一个可执行目标文件。在运行时,main.o还可以和一些共享目标文件链接。 预处理 在该阶段，编译器将上述代码中的stdio.h编译进来，并且用户可以使用gcc的选项”-E”进行查看，该选项的作用是让gcc在预处理结束后停止编译过程。预处理阶段主要处理#include和#define，它把 #include包含进来的.h 文件插入到#include所在的位置 把源程序中使用到的用#define定义的宏用实际的字符串代替 hello.c gcc -E hello.c -o hello.i 12345678#include&lt;stdio.h&gt; int main() { printf(\"Hello world!\\n\"); return 0; } hello.i 编译阶段 接下来进行的是编译阶段，在这个阶段中，Gcc首先要检查代码的规范性、是否有语法错误等，以确定代码的实际要做的工作，在检查无误后，Gcc把代码翻译成汇编语言。用户可以使用”-S”选项来进行查看，该选项只进行编译而不进行汇编，生成汇编代码。 gcc -S hello.c -o hello.s 12345678910111213141516171819202122232425262728293031323334 .section __TEXT,__text,regular,pure_instructions .macosx_version_min 10, 12 .globl _main .p2align 4, 0x90_main: ## @main .cfi_startproc## BB#0: pushq %rbpLcfi0: .cfi_def_cfa_offset 16Lcfi1: .cfi_offset %rbp, -16 movq %rsp, %rbpLcfi2: .cfi_def_cfa_register %rbp subq $16, %rsp leaq L_.str(%rip), %rdi movl $0, -4(%rbp) movb $0, %al callq _printf xorl %ecx, %ecx movl %eax, -8(%rbp) ## 4-byte Spill movl %ecx, %eax addq $16, %rsp popq %rbp retq .cfi_endproc .section __TEXT,__cstring,cstring_literalsL_.str: ## @.str .asciz \"Hello world! \\n\".subsections_via_symbols 汇编阶段 汇编阶段把.s文件翻译成二进制机器指令文件.o，如命令gcc -c hello.s -o hello.o，其中-c告诉gcc进行汇编处理。这步生成的文件是二进制文件，直接用文本工具打开看到的将是乱码，我们需要反汇编工具如IDA的帮助才能读懂它 链接阶段 在编译之后，就进入到了链接阶段。我们hello.c 中是没有定义printf的。我们需要把hello.o中的printf符号和它的定义相关联，\b重定位hello.o和相关的模块，生成一个可执行目标文件.此时我们的printf符号就能正常调用了. 链接使用ld工具.如果没有特别的指定,gcc会到系统默认的搜索路径/usr/lib下进行查找,找到合适的函数库，进行链接. gcc hello.o -o hello.out 生成可执行文件 ./hello.out 运行可执行文件 1Hello world! 1.2 链接的分类 静态链接 动态链接 静态链接像Linux LD程序这样的静态链接器以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的，可以加载和运行的可执行目标文件为输出。 动态链接共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链接.由一个叫做动态链接器的程序来执行的。 1.3 链接的任务 符号解析目标文件定义和引用符号，符号解析的目的是将每个符号引用正好和一个符号定义关联起来 重定位编译器和链接器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，是他们指向这个内存位置。 可重定位目标文件 链接器是以可重定位目标文件作为输入的，要想理解链接的过程，首先应该了解可重定位目标文件。 setion 解释 ELF头 系统的字的大小，字节顺序，ELF头的大小，目标文件的类型，机器类型，节头部表的文件偏移，节头部表中条目的大小和数量 .text 已编译程序的机器代码 .rodata 只读数据 .data 已初始化的全局和静态C变量 .bss 未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量 .symtab 一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。 .rel.text 重定位条目，一个.text节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这个位置。 .rel.data 重定位条目，被模块引用或定义的所有全局变量的重定位信息。 .debug 一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的C源文件。 .line 原始C源程序中的行号和.text节中机器指令间的映射。 .strtab 一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。字符串表就是以null结尾的字符串的序列。 节头目表 不同节的位置和大小。 我们在链接中做的工作主要是：\b\b符号解析.text,.data段的符号引用，重定位目标文件。 符号和符号表 在我们的一个可重定位目标模块中，通常会使用在当前模块和其他模块中定义的函数和全局变量，我们称之为符号。每个可重定位目标模块都有一个符号表，它包含m定义和引用符号的信息。 ELF符号表条目 12345678typedef struct { int name; char type:4,binding:4; char reserved;//没用 short section; long value; long size;}Elf64_Symbol; Name: 字符串表中的字节偏移 Value:符号的地址 Size:目标的大小 Type:函数或者是数据 Bingding:符号是本地的还是全局的 使用nm命令我们可以看到：$ nm mymalloc.o 12345 U ___real_free U ___real_malloc0000000000000050 T ___wrap_free0000000000000000 T ___wrap_malloc U _printf 12___wrap_free,___wrap_malloc 是已定义的符号，在text段，有相应的内存地址.___real_free,_printf,___real_malloc 是未定义的符号 符号解析 模块引用了符号，我们需要将符号和一个确定的符号定义关联起来，这样我们的程序才可以正常的执行下去。对于\b引用和定义在相同模块中的局部符号，符号解析是很简单明了的。但是当编译器遇到不是在当前模块中定义的符号时，只能假设该符号已经在其他模块中定义，生成一个链接器符号表条目，把它交给链接器处理。 重定位 一但链接器完成了符号解析这一步，就把代码中的每个符号引用和正好一个符号定义关联起来（即它的一个输入目标模块中的一个），此时，链接器就知道它的输入目标模块中的代码节和数据节的确切大小。现在就可以开始重定位步骤，在这个步骤中重定位将合并输入模块，并为每个符号分配运行时地址。 重定位由两步组成： 重定位节和符号定义 链接器将所有相同类型的节合并为同一类型的新的聚合节。 链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成后，程序中的每条指令和全局变量都有唯一的运行时内存地址了。 重定位节中的符号引用 链接器依赖可重定位条目的数据结构，修改代码节和数据节中对每个符号的引用，使它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目标模块中成为可重定位条目的数据结构。 可重定位条目 当汇编器生成一个目标模块时，它并不知道数据和代码最终放在内存中的什么位置。他也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。所以，无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。 代码的可重定位条目在.rel.text节中，已初始化数据的重定位条目放在.rel.data中. 12345typedef struct { long offset;// 需要被修改引用的节偏移 long type:32,symbol:32;// type:如何修改新的引用,symbol:标示被修改引用应该指向的符号 long addend;// 一些类型的重定位要使用它对被修改引用的值做偏移调整}Elf64_Rela; 两种基本的重定位类型： PC 相对地址引用 一个PC相对地址就是 距程序计数器(PC)的当前运行值的偏移量 绝对地址引用 1.4 动态链接共享库静态库有一些明显的缺点，比如： 静态库更新后需要显式地将他们的程序与更新了的库重新链接。 静态库的代码会被复制到每个运行进程的文本段中。 共享库，动态链接共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链接.由一个叫做动态链接器的程序来执行的。 共享库的共享方式 给定文件系统中一个库只有一个.so文件。 内存中，一个共享库的.text节的一个副本可以被不同的正在运行的进程共享。\b 共享库的链接时机 在运行时由动态链接器练\b链接和加载 \b在调用程序被加载和开始执行时 根据需要在程序调用 dlopen 库的函数时 PIC 借助GOT,PLT实现第一次调用外部函数： 1. 调用外部符号，程序进入相应的PLT条目 2. 把 调用的 ID压入栈后，跳转到PLT[0] 3. PLT[0]通过GOT[1]间接的把动态链接器的一个参数压入栈中，然后通过GOT[2]间接的跳转进动态链接器中。动态链接器使用两个栈条目来确定 外部函数的 远行时为止，用这个地址重写GOT[4],再把控制权传给 函数。 后续再次调用： 1. 控制传递到PLT相应条目 2. 通过相应的GOT条目直接转移控制到 函数 PLT[0]: 特殊条目，它跳转到动态链接器中GOT[0]和GOT[1]包含动态链接器在解析函数地址时会使用的信息。GOT[2]是动态链接器在ld-linux.so模块中的入口点。 1.4 加载可执行目标文件加载器将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。 需要注意的是： 由于.data段有对齐要求，所以代码段和数据段之间是有间隙的 链接器会使用ASLR技术,每次区域运行时区域的地址都会改变，但是相对地址不会改变。 Linux下的加载 父shell进程生成一个子进程，它是父进程的一个复制 子进程通过execve系统调用启动加载器 加载器删除子进程现有的虚拟内存段，并创建一组新的代码，数据，堆和栈段 将虚拟地址空间中的页映射到可执行文件的页大小的片（chunk） ，新的代码和数据段被初始化为可执行文件的内容 加载器跳转到_start地址，最终会调用应用程序的main 函数。 注意：除了一些头部信息，在加载过程中没有任何从磁盘到内存的数据复制。直到CPU引用一个被映射的虚拟页时才会进行复制，此时，操作系统利用它的页面调度机制，自动将页面从磁盘传送到内存。 2 Apple App Start And Dyld2.1 dyld当内核完成映射进程的工作后会将名字为dyld的Mach-O文件映射到进程中的随机地址，它将PC寄存器设为dyld的地址并运行. Fix-ups由于代码签名，我们无法修改__TEXT段的内容,我们可以通过PIC（Position Independent Code）将dyld修改的引用的地址存储到__DATA中. 在Linux中是通过GOT(Global Offset Table)和PLT(Procedure Linkage Table)实现的. \bdyld的时间线：Load dylibs -&gt; Rebase -&gt; Bind -&gt; ObjC -&gt; Initalizers Load Load dylibs:dylibs映射到内存上。 Rebase和Binding Rebase：在镜像内部调整指针的指向. Binding：将指针指向镜像外部的内容 Rebase和Binding:使用PIC技术重定位__DATA中对应__TEXT中符号的指针 可以通过命令行查看 rebase 和 bind 相关的资源指针：xcrun dyldinfo -rebase -bind -lazy_bind xxx.app/xxx\b诸如此类的输出 123456789101112__DATA __la_symbol_ptr 0x1000341C8 0x04C3 libobjc _objc_setAssociatedObject__DATA __la_symbol_ptr 0x1000341D0 0x04E4 libobjc _objc_setProperty_nonatomic_copy__DATA __la_symbol_ptr 0x1000341D8 0x050C libobjc _objc_storeStrong__DATA __la_symbol_ptr 0x1000341E0 0x0525 libobjc _objc_storeWeak__DATA __la_symbol_ptr 0x1000341E8 0x053C libobjc _objc_unsafeClaimAutoreleasedReturnValue__DATA __la_symbol_ptr 0x1000341F0 0x056C libSystem _pow__DATA __la_symbol_ptr 0x1000341F8 0x0578 libSystem _sin__DATA __la_symbol_ptr 0x100034200 0x0584 libSystem _sinf__DATA __la_symbol_ptr 0x100034208 0x0591 libswiftCore _swift_getObjCClassMetadata__DATA __la_symbol_ptr 0x100034210 0x05B4 libswiftCore _swift_getObjectType__DATA __la_symbol_ptr 0x100034218 0x05D0 libswiftCore _swift_unknownRelease__DATA __la_symbol_ptr 0x100034220 0x05ED libswiftCore _swift_unknownRetain ObjC Runtime ObjC 数据结构中有class DATA structure 有很多指针，例如指向 methods 和 super 的指针。这些指针的Fixed-up是通过 rebasing 和 binding.可以说我们\b类中method_list中的很多信息都是通过 Fix-ups 来维护的 因为Objc的动态性,Objc 可以通过类名来实例化对象, 这意味着 ObjC runtime 需要维护 一张哈希表，负责class name和class的映射.因此当你加载dylib的时候，dylib中定义的类都会被注册到表中。 更新类定义\b 没有C++中易碎的基类问题，因为 Fix-ups已经更新了__DATA 因此类中ivar相对于类实例起始地址的offset也被更新了. ObjC 可以定义类别，类别可以改变 类的方法,但是 类别的定义可能和类不在同一个 image 中，在加载过程中，也需要做Fix-up,修复方法的指针. 将category中的method 加到class method_list 的前面，这样我们 在OC 运行时顺序\b查找方法表，先找的是 category 定义的方法. ObjC 的 selector 是唯一的 Initializers C++ 为静态创建的对象生成初始化器 Objc +load 方法，已经废弃,建议使用 +initialize 2.2 启动调用顺序initialize -&gt; dyld -&gt; main() -&gt; UIApplicationMain() 3 dyld3在WWDC 2017 上，苹果宣布已经使用 dyld3 来作为系统app的动态链接器 dyld3可以分成三个部分 一个进程外的 mach-o 分析器和编译器 处理可能影响启动速度的searchpath @rpaths 和 环境变量，解析mach-o二进制文件，完成符号解析的工作. 一个进程内的引擎 执行启动收尾处理 验证启动收尾，映射动态链接库 一个启动收尾缓存服务 系统程序收尾被直接加入到共享缓存，使用这个工具在系统中运行和分析每个mach-o文件，将它们放入共享缓存，使它映射到缓存中，所有dylib都使用它来启动. 对于第三方程序，在程序安装或系统更新时，生成启动收尾处理（因为系统库那时已经发生更改） 为什么启动收尾可以提高启动速度?通过启动收尾，缓存了 符号相对于库中的偏移位置， 这就避免了以后启动程序进程再次进行符号链接的时间消耗。直接从磁盘读取缓存的启动收尾，验证是否正确即可. 4 优化方案App 的启动时间: dylib和App可执行文件的加载时间 + - (BOOL)Application:(UIApplication *)Application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions执行时间. 加载images 使用更少的非系统dylibs 合并多个dylibs 使用静态库 Rebase/Binding 减少Objc 类数量，减少selector数量，减少C++虚函数数量，使用Swift struct InitializerExplict Initializer 使用 +initialize 而不是 +load 不要使用 atribute((constructor)) 将方法显式标记为初始化器,而是让初始化方法调用时才执行.可以使用 dispatch_once(),pthread_once(),std::once() Implict Initializer 在调用的地方使用初始化器 只用简单值类型赋值（POD:Plain Old Data），这样静态链接器会预先计算 __DATA 中的数据，无需再进行 fix-up 工作 使用编译器 warning 标志 -Wglobal-constructors 来发现隐式初始化代码。 苹果还建议更多使用 Swift。Swift 在设计上能避免很多 C、C++ 和 OC 的陷阱；Swift 没有初始化过程；Swift 也不允许不对齐的结构体。这些都对启动时间的优化有一定帮助 5 参考 2017 WWDC Session 413 2016 WWDC Session 406 《深入理解计算机系统》","link":"/2017/10/27/dyld3withappstart/"},{"title":"iOS Core Animation性能调优 笔记","text":"高效绘图一些关键词软件绘图上下文：指代软件绘图（意即：不由GPU协助 的绘图）软件绘图通常是由Core Graphics框架完成来完成 绘制速度 OpenGL&gt;Core Animation&gt;Core Graphics 消耗可观的内存 CALayer 只需要一些与自己相关 的内存：只有它的寄宿图会消耗一定的内存空间。即使直接赋给 contents 属性一 张图片，也不需要增加额外的照片存储大小。如果相同的一张图片被多个图层作 为 contents 属性，那么他们将会共用同一块内存，而不是复制内存块。如果你实现了 -drawLayer:inContext: -drawRect:这两个方法中的任意一个方法，图层就创建了了一个绘制上下文，这个上下文需要的大小的内存可从这个算式得出：图层宽图 层高4字节，宽高的单位均为像素。对于一个在Retina iPad上的全屏图层来说，这 个内存量就是 204815264字节，相当于12MB内存，图层每次重绘的时候都需要 重新抹掉内存然后重新分配。 你应该避免重绘你的视图。提高绘制性能 的秘诀就在于尽量避免去绘制。 矢量图形我们用Core Graphics来绘图的一个通常原因就是只是用图片或是图层效果不能 轻易地绘制出矢量图形。矢量绘图包含一下这些： 任意多边形（不仅仅是一个矩形） 斜线或曲线 文本 渐变 Core Animation为这些图形类型的绘制提供了专门的类，并给他们提供硬件支持 （第六章『专有图层』有详细提到）。 CAShapeLayer 可以绘制多边形，直线和 曲线。 CATextLayer 可以绘制文本。 CAGradientLayer 用来绘制渐变。这些总体上都比Core Graphics更快，同时他们也避免了创造一个寄宿图。 脏矩形，Mac OS和iOS设备将会把屏幕区分为需要重绘的区域和 不需要重绘的区域。那些需要重绘的部分被称作『脏区域』。在实际应用中，鉴于 非矩形区域边界裁剪和混合的复杂性，通常会区分出包含指定视图的矩形位置，而 这个位置就是『脏矩形』。但是Core Animation通常并不了 解你的自定义绘图代码，它也不能自己计算出脏区域的位置。然而，你的确可以提 供这些信息。 当你检测到指定视图或图层的指定部分需要被重绘，你直接调用 - setNeedsDisplayInRect: 来标记它，然后将影响到的矩形作为参数传入。这样就 会在一次视图刷新时调用视图的 -drawRect: 图层代理的 -drawLayer:inContext: 异步绘制UIKit的单线程天性意味着寄宿图通畅要在主线程上更新，这意味着绘制会打断用 户交互，甚至让整个app看起来处于无响应状态。针对这个问题，有一些方法可以用到：一些情况下，我们可以推测性地提前在另 外一个线程上绘制内容，然后将由此绘出的图片直接设置为图层的内容。这实现起 来可能不是很方便，但是在特定情况下是可行的。Core Animation提供了一些选 择： CATiledLayer 和 drawsAsynchronously 属性。 图像IO优化从闪存驱动器或者网络中加载和显示图片 加载和潜伏 加载 解压 线程加载 图像加载的优化 异步加载图片，避免主线程堵塞 注意事项，异步加载图片造成的问题 由于视图在UICollectionView会被循环利用，我们加载图片的时候不能确定是否被不同的索引重新复用。为了避免图片加载到错误的视图中，我们在加载前把单元格打上索引的标签，然后在设置图片的时候检测标签是否发生了改变。+ 延迟解压当加载图片的时候，iOS通常会延迟解压图片的时间，直到加载到内存之后。这就会在准备绘制图片的时候影响性能，因为需要在绘制之前进行解压 +imageNamed: 这个方法会在加载图片后立刻解压,但是只对应用资源束中的图片有效 +imageWithContentsOfFile:会延迟解压图片的时间，直到加载到内存之后 另一种立刻加载图片的方法就是把它设置成图层内容，或者是UIImageView的image属性。不幸的是，这又需要在主线程执行，所以不会对性能有所提升。 第三种方式就是绕过UIKit，像下面这样使用ImageIO框架： 12345678NSInteger index = indexPath.row;NSURL *imageURL = [NSURL fileURLWithPath:self.imagePaths[index]];NSDictionary *options = @{(__bridge id)kCGImageSourceShouldCache: @YES};CGImageSourceRef source = CGImageSourceCreateWithURL((__bridge CFURLRef)imageURL, NULL);CGImageRef imageRef = CGImageSourceCreateImageAtIndex(source, 0,(__bridge CFDictionaryRef)options);UIImage *image = [UIImage imageWithCGImage:imageRef];CGImageRelease(imageRef);CFRelease(source); 这样就可以使用kCGImageSourceShouldCache来创建图片，强制图片立刻解压，然后在图片的生命周期保留解压后的版本。 最后一种方式就是使用UIKit加载图片，但是立刻会知道CGContext中去。图片必须要在绘制之前解压，所以就强制了解压的及时性。这样的好处在于绘制图片可以再后台线程（例如加载本身）执行，而不会阻塞UI。 有两种方式可以为强制解压提前渲染图片： 将图片的一个像素绘制成一个像素大小的CGContext。这样仍然会解压整张图片，但是绘制本身并没有消耗任何时间。这样的好处在于加载的图片并不会在特定的设备上为绘制做优化，所以可以在任何时间点绘制出来。同样iOS也就可以丢弃解压后的图片来节省内存了。 将整张图片绘制到CGContext中，丢弃原始的图片，并且用一个从上下文内容中新的图片来代替。这样比绘制单一像素那样需要更加复杂的计算，但是因此产生的图片将会为绘制做优化，而且由于原始压缩图片被抛弃了，iOS就不能够随时丢弃任何解压后的图片来节省内存了。 需要注意的是苹果特别推荐了不要使用这些诡计来绕过标准图片解压逻辑（所以也是他们选择用默认处理方式的原因），但是如果你使用很多大图来构建应用，那如果想提升性能，就只能和系统博弈了。 如果不使用+imageNamed:，那么把整张图片绘制到CGContext可能是最佳的方式了。尽管你可能认为多余的绘制相较别的解压技术而言性能不是很高，但是新创建的图片（在特定的设备上做过优化）可能比原始图片绘制的更快。 123456789101112131415161718192021222324252627- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath{ //dequeue cell UICollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:@\"Cell\" forIndexPath:indexPath]; ... //switch to background thread dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^{ //load image NSInteger index = indexPath.row; NSString *imagePath = self.imagePaths[index]; UIImage *image = [UIImage imageWithContentsOfFile:imagePath]; //redraw image using device context UIGraphicsBeginImageContextWithOptions(imageView.bounds.size, YES, 0); [image drawInRect:imageView.bounds]; image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); //set image on main thread, but only if index still matches up dispatch_async(dispatch_get_main_queue(), ^{ if (index == cell.tag) { imageView.image = image; } }); }); return cell;} CATiledLayer如第6章“专用图层”中的例子所示，CATiledLayer可以用来异步加载和显示大型图片，而不阻塞用户输入。但是我们同样可以使用CATiledLayer在UICollectionView中为每个表格创建分离的CATiledLayer实例加载传动器图片，每个表格仅使用一个图层。这样使用CATiledLayer有几个潜在的弊端： CATiledLayer的队列和缓存算法没有暴露出来，所以我们只能祈祷它能匹配我们的需求 CATiledLayer需要我们每次重绘图片到CGContext中，即使它已经解压缩，而且和我们单元格尺寸一样（因此可以直接用作图层内容，而不需要重绘）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#import \"ViewController.h\"#import@interface ViewController()@property (nonatomic, copy) NSArray *imagePaths;@property (nonatomic, weak) IBOutlet UICollectionView *collectionView;@end@implementation ViewController- (void)viewDidLoad{ //set up data self.imagePaths = [[NSBundle mainBundle] pathsForResourcesOfType:@\"jpg\" inDirectory:@\"Vacation Photos\"]; [self.collectionView registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@\"Cell\"];}- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section{ return [self.imagePaths count];}- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath{ //dequeue cell UICollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:@\"Cell\" forIndexPath:indexPath]; //add the tiled layer CATiledLayer *tileLayer = [cell.contentView.layer.sublayers lastObject]; if (!tileLayer) { tileLayer = [CATiledLayer layer]; tileLayer.frame = cell.bounds; tileLayer.contentsScale = [UIScreen mainScreen].scale; tileLayer.tileSize = CGSizeMake(cell.bounds.size.width * [UIScreen mainScreen].scale, cell.bounds.size.height * [UIScreen mainScreen].scale); tileLayer.delegate = self; [tileLayer setValue:@(indexPath.row) forKey:@\"index\"]; [cell.contentView.layer addSublayer:tileLayer]; } //tag the layer with the correct index and reload tileLayer.contents = nil; [tileLayer setValue:@(indexPath.row) forKey:@\"index\"]; [tileLayer setNeedsDisplay]; return cell;}- (void)drawLayer:(CATiledLayer *)layer inContext:(CGContextRef)ctx{ //get image index NSInteger index = [[layer valueForKey:@\"index\"] integerValue]; //load tile image NSString *imagePath = self.imagePaths[index]; UIImage *tileImage = [UIImage imageWithContentsOfFile:imagePath]; //calculate image rect CGFloat aspectRatio = tileImage.size.height / tileImage.size.width; CGRect imageRect = CGRectZero; imageRect.size.width = layer.bounds.size.width; imageRect.size.height = layer.bounds.size.height * aspectRatio; imageRect.origin.y = (layer.bounds.size.height - imageRect.size.height)/2; //draw tile UIGraphicsPushContext(ctx); [tileImage drawInRect:imageRect]; UIGraphicsPopContext();}@end 需要解释几点：CATiledLayer的tileSize属性单位是像素，而不是点，所以为了保证瓦片和表格尺寸一致，需要乘以屏幕比例因子。在-drawLayer:inContext:方法中，我们需要知道图层属于哪一个indexPath以加载正确的图片。这里我们利用了CALayer的KVC来存储和检索任意的值，将图层和索引打标签。 分辨率交换视网膜分辨率（根据苹果市场定义）代表了人的肉眼在正常视角距离能够分辨的最小像素尺寸。但是这只能应用于静态像素。当观察一个移动图片时，你的眼睛就会对细节不敏感，于是一个低分辨率的图片和视网膜质量的图片没什么区别了。+ 如果需要快速加载和显示移动大图，简单的办法就是欺骗人眼，在移动传送器的时候显示一个小图（或者低分辨率），然后当停止的时候再换成大图。这意味着我们需要对每张图片存储两份不同分辨率的副本，但是幸运的是，由于需要同时支持Retina和非Retina设备，本来这就是普遍要做到的。如果从远程源或者用户的相册加载没有可用的低分辨率版本图片，那就可以动态将大图绘制到较小的CGContext，然后存储到某处以备复用。为了做到图片交换，我们需要利用UIScrollView的一些实现UIScrollViewDelegate协议的委托方法（和其他类似于UITableView和UICollectionView基于滚动视图的控件一样）： 123- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate;- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView; 你可以使用这几个方法来检测传送器是否停止滚动，然后加载高分辨率的图片。只要高分辨率图片和低分辨率图片尺寸颜色保持一致，你会很难察觉到替换的过程（确保在同一台机器使用相同的图像程序或者脚本生成这些图片）。 缓存如果有很多张图片要显示，最好不要提前把所有都加载进来，而是应该当移出屏幕之后立刻销毁。通过选择性的缓存，你就可以避免来回滚动时图片重复性的加载了。 +imageNamed:方法之前我们提到使用[UIImage imageNamed:]加载图片有个好处在于可以立刻解压图片而不用等到绘制的时候。但是[UIImage imageNamed:]方法有另一个非常显著的好处：它在内存中自动缓存了解压后的图片，即使你自己没有保留对它的任何引用。 对于iOS应用那些主要的图片（例如图标，按钮和背景图片），使用[UIImage imageNamed:]加载图片是最简单最有效的方式。在nib文件中引用的图片同样也是这个机制，所以你很多时候都在隐式的使用它。 但是[UIImage imageNamed:]并不适用任何情况。它为用户界面做了优化，但是并不是对应用程序需要显示的所有类型的图片都适用。有些时候你还是要实现自己的缓存机制，原因如下： [UIImage imageNamed:]方法仅仅适用于在应用程序资源束目录下的图片，但是大多数应用的许多图片都要从网络或者是用户的相机中获取，所以[UIImage imageNamed:]就没法用了。 [UIImage imageNamed:]缓存用来存储应用界面的图片（按钮，背景等等）。如果对照片这种大图也用这种缓存，那么iOS系统就很可能会移除这些图片来节省内存。那么在切换页面时性能就会下降，因为这些图片都需要重新加载。对传送器的图片使用一个单独的缓存机制就可以把它和应用图片的生命周期解耦。 [UIImage imageNamed:]缓存机制并不是公开的，所以你不能很好地控制它。例如，你没法做到检测图片是否在加载之前就做了缓存，不能够设置缓存大小，当图片没用的时候也不能把它从缓存中移除。 自定义缓存 构建一个所谓的缓存系统非常困难。菲尔 卡尔顿曾经说过：“在计算机科学中只有两件难事：缓存和命名”。 如果要写自己的图片缓存的话，那该如何实现呢？让我们来看看要涉及哪些方面： 选择一个合适的缓存键 - 缓存键用来做图片的唯一标识。如果实时创建图片，通常不太好生成一个字符串来区分别的图片。在我们的图片传送带例子中就很简单，我们可以用图片的文件名或者表格索引。 提前缓存 - 如果生成和加载数据的代价很大，你可能想当第一次需要用到的时候再去加载和缓存。提前加载的逻辑是应用内在就有的，但是在我们的例子中，这也非常好实现，因为对于一个给定的位置和滚动方向，我们就可以精确地判断出哪一张图片将会出现。 缓存失效 - 如果图片文件发生了变化，怎样才能通知到缓存更新呢？这是个非常困难的问题（就像菲尔 卡尔顿提到的），但是幸运的是当从程序资源加载静态图片的时候并不需要考虑这些。对用户提供的图片来说（可能会被修改或者覆盖），一个比较好的方式就是当图片缓存的时候打上一个时间戳以便当文件更新的时候作比较。 缓存回收 - 当内存不够的时候，如何判断哪些缓存需要清空呢？这就需要到你写一个合适的算法了。幸运的是，对缓存回收的问题，苹果提供了一个叫做NSCache通用的解决方案 NSCacheNSCache和NSDictionary类似。你可以通过-setObject:forKey:和-object:forKey:方法分别来插入，检索。和字典不同的是，NSCache在系统低内存的时候自动丢弃存储的对象。 NSCache用来判断何时丢弃对象的算法并没有在文档中给出，但是你可以使用-setCountLimit:方法设置缓存大小，以及-setObject:forKey:cost:来对每个存储的对象指定消耗的值来提供一些暗示。 指定消耗数值可以用来指定相对的重建成本。如果对大图指定一个大的消耗值，那么缓存就知道这些物体的存储更加昂贵，于是当有大的性能问题的时候才会丢弃这些物体。你也可以用-setTotalCostLimit:方法来指定全体缓存的尺寸。 NSCache是一个普遍的缓存解决方案，我们创建一个比传送器案例更好的自定义的缓存类。（例如，我们可以基于不同的缓存图片索引和当前中间索引来判断哪些图片需要首先被释放）。但是NSCache对我们当前的缓存需求来说已经足够了；没必要过早做优化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#import \"ViewController.h\"@interface ViewController()@property (nonatomic, copy) NSArray *imagePaths;@property (nonatomic, weak) IBOutlet UICollectionView *collectionView;@end@implementation ViewController- (void)viewDidLoad{ //set up data self.imagePaths = [[NSBundle mainBundle] pathsForResourcesOfType:@\"png\" inDirectory:@\"Vacation Photos\"]; //register cell class [self.collectionView registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@\"Cell\"];}- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section{ return [self.imagePaths count];}- (UIImage *)loadImageAtIndex:(NSUInteger)index{ //set up cache static NSCache *cache = nil; if (!cache) { cache = [[NSCache alloc] init]; } //if already cached, return immediately UIImage *image = [cache objectForKey:@(index)]; if (image) { //如果为NSNull 这意味着，会有代码对其进行赋值，所以这里赋值一个nil,即可。不用担心，image 的赋值不会出现问题。 return [image isKindOfClass:[NSNull class]]? nil: image; } //设定为NSNull 后面的代码会在随后的执行中进行赋值 //set placeholder to avoid reloading image multiple times [cache setObject:[NSNull null] forKey:@(index)]; //switch to background thread dispatch_async( dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^{ //load image NSString *imagePath = self.imagePaths[index]; UIImage *image = [UIImage imageWithContentsOfFile:imagePath]; //redraw image using device context UIGraphicsBeginImageContextWithOptions(image.size, YES, 0); [image drawAtPoint:CGPointZero]; image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); //set image for correct image view dispatch_async(dispatch_get_main_queue(), ^{ //cache the image [cache setObject:image forKey:@(index)]; //display the image NSIndexPath *indexPath = [NSIndexPath indexPathForItem: index inSection:0]; UICollectionViewCell *cell = [self.collectionView cellForItemAtIndexPath:indexPath]; UIImageView *imageView = [cell.contentView.subviews lastObject]; imageView.image = image; }); }); //not loaded yet return nil;}- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath{ //dequeue cell UICollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:@\"Cell\" forIndexPath:indexPath]; //add image view UIImageView *imageView = [cell.contentView.subviews lastObject]; if (!imageView) { imageView = [[UIImageView alloc] initWithFrame:cell.contentView.bounds]; imageView.contentMode = UIViewContentModeScaleAspectFit; [cell.contentView addSubview:imageView]; } //set or load image for this index imageView.image = [self loadImageAtIndex:indexPath.item]; //preload image for previous and next index if (indexPath.item &lt; [self.imagePaths count] - 1) { [self loadImageAtIndex:indexPath.item + 1]; } if (indexPath.item &gt; 0) { [self loadImageAtIndex:indexPath.item - 1]; } return cell;}@end 果然效果更好了！当滚动的时候虽然还有一些图片进入的延迟，但是已经非常罕见了。缓存意味着我们做了更少的加载。这里提前加载逻辑非常粗暴，其实可以把滑动速度和方向也考虑进来，但这已经比之前没做缓存的版本好很多了。 图层性能隐式绘制寄宿图可以通过Core Graphics直接绘制，也可以直接载入一个图片文件并赋值 给 contents 属性，或事先绘制一个屏幕之外的 CGContext 上下文。在之前的两 章中我们讨论了这些场景下的优化。但是除了常见的显式创建寄宿图，你也可以通 过以下三种方式创建隐式的：1，使用特性的图层属性。2，特定的视图。3，特定 的图层子类。 文本都是直接将文本绘制在图层的寄宿图中。事实上这 两种方式用了完全不同的渲染方式：在iOS 6及之前， UILabel 用WebKit的HTML 渲染引擎来绘制文本，而 CATextLayer 用的是Core Text.后者渲染更迅速，所以 在所有需要绘制大量文本的情形下都优先使用它吧。但是这两种方法都用了软件的 方式绘制，因此他们实际上要比硬件加速合成方式要慢。(iOS Text Kit) CATextLayer和UILabel不论如何，尽可能地避免改变那些包含文本的视图的frame，因为这样做的话文 本就需要重绘。例如，如果你想在图层的角落里显示一段静态的文本，但是这个图 层经常改动，你就应该把文本放在一个子图层中。 光栅化在第四章『视觉效果』中我们提到了 CALayer 的 shouldRasterize 属性，它 可以解决重叠透明图层的混合失灵问题。同样在第12章『速度的曲调』中，它也是 作为绘制复杂图层树结构的优化方法。 启用 shouldRasterize 属性会将图层绘制到一个屏幕之外的图像。然后这个图 像将会被缓存起来并绘制到实际图层的 contents 和子图层。如果有很多的子图层 或者有复杂的效果应用，这样做就会比重绘所有事务的所有帧划得来得多。但是光 栅化原始图像需要时间，而且还会消耗额外的内存。（shouldRasterize，如果视图加载内容经常变化，会大量消耗内存和CPU 导致掉帧） 当我们使用得当时，光栅化可以提供很大的性能优势（如你在第12章所见），但 是一定要避免作用在内容不断变动的图层上，否则它缓存方面的好处就会消失，而 且会让性能变的更糟。 离屏渲染当图层属性的混合体被指定为在未预合成之前不能直接在屏幕中绘制时，屏幕外 渲染就被唤起了。屏幕外渲染并不意味着软件绘制，但是它意味着图层必须在被显 示之前在一个屏幕外上下文中被渲染（不论CPU还是GPU）。图层的以下属性将会 触发屏幕外绘制： 圆角 图层蒙版 阴影 屏幕外渲染和我们启用光栅化时相似，除了它并没有像光栅化图层那么消耗大， 子图层并没有被影响到，而且结果也没有被缓存，所以不会有长期的内存占用。但 是，如果太多图层在屏幕外渲染依然会影响到性能。 有时候我们可以把那些需要屏幕外绘制的图层开启光栅化以作为一个优化方式， 前提是这些图层并不会被频繁地重绘。 对于那些需要动画而且要在屏幕外渲染的图层来说，你可以用 CAShapeLayer ，contentsCenter，shadowPath 较少地影响到性能。 CAShapeLayercornerRadius和maskToBounds独立作用的时候都不会有太大的性能问题，但是当他俩结合在一起，就触发了屏幕外渲染。有时候你想显示圆角并沿着图层裁切子图层的时候，你可能会发现你并不需要沿着圆角裁切，这个情况下用CAShapeLayer就可以避免这个问题了。2 你想要的只是圆角且沿着矩形边界裁切，同时还不希望引起性能问题。其实你可以用现成的UIBezierPath的构造器+bezierPathWithRoundedRect:cornerRadius:（见清单15.1）.这样做并不会比直接用cornerRadius更快，但是它避免了性能问题。混合和过度绘制在第12章有提到，GPU每一帧可以绘制的像素有一个最大限制（就是所谓的fill rate），这个情况下可以轻易地绘制整个屏幕的所有像素。但是如果由于重叠图层的关系需要不停地重绘同一区域的话，掉帧就可能发生了。 **GPU会放弃绘制那些完全被其他图层遮挡的像素**，但是要计算出一个图层是否被遮挡也是相当复杂并且会消耗处理器资源。同样，合并不同图层的透明重叠像素（即混合）消耗的资源也是相当客观的。所以为了加速处理进程，不到必须时刻不要使用透明图层。任何情况下，你应该这样做： - 给视图的backgroundColor属性设置一个固定的，不透明的颜色 - 设置opaque属性为YES 这样做减少了混合行为（因为编译器知道在图层之后的东西都不会对最终的像素颜色产生影响）并且计算得到了加速，避免了过度绘制行为因为Core Animation可以舍弃所有被完全遮盖住的图层，而不用每个像素都去计算一遍。 如果用到了图像，尽量避免透明除非非常必要。如果图像要显示在一个固定的背景颜色或是固定的背景图之前，你没必要相对前景移动，你只需要预填充背景图片就可以避免运行时混色了。 如果是文本的话，一个白色背景的UILabel（或者其他颜色）会比透明背景要更高效。 最后，明智地使用shouldRasterize属性，可以将一个固定的图层体系折叠成单张图片，这样就不需要每一帧重新合成了，也就不会有因为子图层之间的混合和过度绘制的性能问题了。减少图层数量","link":"/2017/01/24/iOS-Core-Animation%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"},{"title":"iOS开发必备的问题定位调试技巧","text":"好久没写科普文.. 在iOS开发的过程中难免遇到各种问题，本文将结合作者这么多年（其实也没几年）的擦屁股和挖坑经验，总结一套调试方法，让你在遇到问题时不盲目，有切入点，可以自己一步一步分析去解决问题。 逻辑问题调试 崩溃问题调试 内存问题调试 逻辑问题调试在阅读一份完全不熟悉的代码时，不知道从何入手，如何找到自己感兴趣的部分。这里介绍几个手段定位到你感兴趣的点： 关键字搜索ripgrep https://github.com/BurntSushi/ripgrep 这个工具，可以通过关键字快速过滤出你感兴趣的内容。 最近，在解崩溃时遇到 KERN_PROTECTION_FAILURE 这个异常类型，想了解一下在什么情况下会产生。于是直接在xnu源码中搜索, 就可以快速定位到错误产生的相关代码，了解其原理。 123456789101112131415161718192021222324252627282930313233343536373839$ rg -C 10 \" = KERN_PROTECTION_FAILURE\"bsd/vm/vm_unix.c859- task = p-&gt;task;860- task_reference(task);861-862- /* If we aren't root and target's task access port is set... */863- if (!kauth_cred_issuser(kauth_cred_get()) &amp;&amp;864- p != current_proc() &amp;&amp;865- (task_get_task_access_port(task, &amp;tfpport) == 0) &amp;&amp;866- (tfpport != IPC_PORT_NULL)) {867-868- if (tfpport == IPC_PORT_DEAD) {869: error = KERN_PROTECTION_FAILURE;870- goto tfpout;871- }872-873- /*874- * Drop the proc_find proc ref before making an upcall875- * to taskgated, since holding a proc_find876- * ref while making an upcall can cause deadlock.877- */878- proc_rele(p);879- p = PROC_NULL;osfmk/vm/vm_fault.c3632- */3633- if (fault_type == VM_PROT_READ &amp;&amp;3634- (prot &amp; VM_PROT_EXECUTE) &amp;&amp;3635- !(prot &amp; VM_PROT_READ) &amp;&amp;3636- pmap_enforces_execute_only(pmap)) {3637- vm_object_unlock(object);3638- vm_map_unlock_read(map);3639- if (real_map != map) {3640- vm_map_unlock(real_map);3641- }3642: kr = KERN_PROTECTION_FAILURE;3643- goto done;3644- }3645-#endif 日志输出内容搜索程序运行日志中的输出，很多内容都是写死在代码中的，这个是搜索利器，通过输出，定位到具体的函数。 当使用 otool -Vt 去反编译 text段时，可以看到，otool 可以反编译出 字符串常量的使用。literal pool for: “you”, 一看 “literal pool for:”极有可能存在在代码 printf中。 12340000000000001fb0 movq %rsi, -0x10(%rbp)0000000000001fb4 leaq 0x15(%rip), %rsi ## literal pool for: &quot;you&quot;0000000000001fbb movq %rsi, -0x18(%rbp)0000000000001fbf leaq 0xe(%rip), %rsi ## literal pool for: &quot;fuck&quot; 通过该关键字搜索 直接定位到了输出内容的地方。 123456789101112131415161718192021222324# xiejunyi @ 192 in ~/cctools-886 on git:master x [16:49:41] $ rg -C 10 \"literal pool for:\" otool/arm_disasm.c5250- info-&gt;indirect_symbols, info-&gt;nindirect_symbols,5251- info-&gt;symbols, NULL, info-&gt;nsymbols, info-&gt;strings,5252- info-&gt;strings_size);5253- if(name != NULL)5254- fprintf(stream, \"\\t@ symbol stub for: %s\", name);5255- else{5256- uint64_t reference_type;5257- reference_type = LLVMDisassembler_ReferenceType_In_PCrel_Load;5258- name = guess_literal_pointer(addr, pc, &amp;reference_type, info);5259- if(name != NULL){5260: fprintf(stream, \" literal pool for: \");5261- if(reference_type ==5262- LLVMDisassembler_ReferenceType_Out_LitPool_CstrAddr)5263- fprintf(stream, \"\\\"%s\\\"\", name);5264- else5265- fprintf(stream, \"%s\", name);5266- }5267- }5268- }5269-}5270- 调试打断点通过上面的文本搜索，你可能已经定位到了关键函数。这时，如果你可以对代码进行调试，在目标函数设置断点可以看到调用栈，快速了解代码的执行逻辑。我在分析ld对symboltabl处理时打了几个断点 然后通过调用栈了解相关的程序执行逻辑。main -&gt; 执行ld pass -&gt; 构建序数表 -&gt; 构建nametable 通过log一般靠谱点的项目中会有各种日志打印，通常需要自行打开。我们在使用一些工具的时候也会打开调试日志进行分析，常见的是通过–verbose选项。\b在代码中，很容易就可以找到一些打印输入，然后将其开启。通过代码作者的log，我们可以了解代码运行时的一些关键信息。 这是ld64的 printStatistics log 1234567891011 ld total time: 343.4 seconds ( 100.0%) option parsing time: 0.2 milliseconds ( 0.0%) object file processing: 0.0 milliseconds ( 0.0%) resolve symbols: 5.3 milliseconds ( 0.0%) build atom list: 0.0 milliseconds ( 0.0%) passess: 343.4 seconds ( 99.9%) write output: 0.7 milliseconds ( 0.0%)pageins=6169353, pageouts=3545, faults=247734135processed 1 object files, totaling 2,720 bytesprocessed 0 archive files, totaling 0 bytesprocessed 35 dylib files 代码中也存在 通过开关打开的log，找到slog的设置入口，打开即可。 12if (_s_log ) fprintf(stderr, \"could not order %s as %u because it was already laid out earlier by %s as %u\\n\", atom-&gt;name(), index, _followOnStarts[atom]-&gt;name(), _ordinalOverrideMap[atom] ); 崩溃问题调试查看和分析崩溃日志程序崩溃时，给开发者解决问题的最主要的信息就是崩溃日志了。iOS系统自带crash捕获和日志生成功能，可以通过xcode查看设备中存储崩溃日志 通过crash日志，可以看到程序崩溃时的现场信息，主要关注调用栈信息和崩溃类型。 如何分析crashlog就不详细展开了，可以网上搜一搜相关的文章。这里提几个点： 反编译代码 通过崩溃函数的汇编代码获取更多的信息（例如：常见的野指针问题我们可以分析出哪个对象野了） 常见崩溃问题的了解，crash watchdog oom 野指针 循环调用导致栈溢出… Xcode中debug程序使用 xcode debug 程序时，Xcode的调试器 会自动监听程序的exception端口，当崩溃发生时，xcode会帮我们保留现场。开启Exception BreakPoint 崩溃时，Xcode会自动定位到崩溃的代码行。 内存问题调试循环引用iOS开发中常见的内容问题是 循环引用，xcode8引入了memory graph这一神器来分析这类问题。在Xcode下方的工具栏中进入， 如下代码 可以看到 obj1 obj2 循环引用了。 1234567891011121314151617181920212223242526272829@interface TestClass : NSObject@property (nonatomic, strong) NSMutableArray *array;@end@implementation TestClass- (instancetype)init { if (self = [super init]) { self.array = @[].mutableCopy; } return self;}@end@interface ViewController ()@property (nonatomic, strong) NSMutableArray *array;@end@implementation ViewController- (void)viewDidLoad { [super viewDidLoad]; TestClass *obj1 = [TestClass new]; TestClass *obj2 = [TestClass new]; [obj1.array addObject:obj2]; [obj2.array addObject:obj1];}@end 通过memory graph 可以直观的看到 对象间的引用关系 对象分配的调用栈（需要打开Malloc Stack） 有内存问题的对象列表 野指针可通过下图两个工具排查","link":"/2020/02/12/iosdevdebug/"},{"title":"iOS OOM","text":"最近在做oom,简单的总结下相关知识 Out Of Memory 是 Jetsam同过响应压力通知杀掉优先级内消耗内存太多的进程, 导致应用闪退的一种现象，难于捕获和分析。 技术点：1. iOS 内存分配系统的实现 2. 如何抓到回调与如何监控 3. 数据结构设计 4. iOS abort机制 5. OOM事件捕获iOS内存分配系统的实现（用户层级）iOS中，内存堆分配的基本控制者是 malloc_zone, 通常是default_zone. 实际上是一个 scallable zone. 我们的通过malloc 分配的内存都是 通过Zone中的空闲内存块链表中获取的. 实际上Zone 从VMPage获取4k对齐的内存(mvm_allocate_pages). 然后再分给我们小块的，效率高，我们通过malloc分配内存，就不必每次都需要申请vmpages. malloc 内存申请分为 tiny, small, large… 虚拟内存分配相关的知识：vm_map, vm_map_entry, vm_object, vm_page, vm_object, vm_page对虚拟内存页面的调用都在bsd/kern/kern_mman.c中实现。 物理内存: pmap…iOS abort 机制Pageout管理页面交换的策略，判断哪些页面需要写回到其后备存储。垃圾回收线程 (vm_pageout_grabage_collect()) 调用 consider_pressure_events -&gt; vm_dispatch_memory_pressure() -&gt; BSD -&gt; NOTE_VM_PRESSURE-&gt; 响应压力通知如果进程并不是总能找到可以抛弃的内存，当这种协作方法失败时，Jetsam机制介入。 Jetsam通过响应压力通知杀掉优先级内消耗内存太多的进程。BSD层起了一个内核优先级最高的线程VM_memorystatus，这个线程会在维护两个列表，一个是我们之前提到的基于进程优先级的进程列表，还有一个是所谓的内存快照列表，即保存了每个进程消耗的内存页memorystatus_jetsam_snapshot。这个常驻线程接受从内核对于内存的守护程序pageout通过内核调用给每个App进程发送的内存压力通知，来处理事件，这个事件转发成上层的UI事件就是平常我们会收到的全局内存警告或者每个ViewController里面的didReceiveMemoryWarning。 杀的类别读了一下源码，发现 杀的机制有如下两种，他们大致的执行流程如下 highwater 的处理 -&gt; 我们App占用的内存不要超过限制 1. 从优先级列表里循环寻找线程 2. 判断是否满足p_memstat_memlimit的限制条件 3. DiagnoseActive, FREEZE过滤 4. 杀进程，杀到了exit, 否则继续循环 memorystatus_act_aggressive处理 -&gt; 内存占用高按优先级杀 1. 根据policy加载 jld_bucket_count， 用来判断是否开杀 2. 从JETSAM_PRIORITY_ELEVATED_INACTIVE 开始杀 3. jld_bucket_count 和 memorystatus_jld_eval_period_msecs 判断是否开杀 4. 根据优先级从低向高杀，直到memorystatus_avail_pages_below_pressure 触发入口123456789101112# static boolean_tmemorystatus_action_needed(void){#if CONFIG_EMBEDDED return (is_reason_thrashing(kill_under_pressure_cause) || is_reason_zone_map_exhaustion(kill_under_pressure_cause) || memorystatus_available_pages &lt;= memorystatus_available_pages_pressure);#else /* CONFIG_EMBEDDED */ return (is_reason_thrashing(kill_under_pressure_cause) || is_reason_zone_map_exhaustion(kill_under_pressure_cause));#endif /* CONFIG_EMBEDDED */} 针对这种情况我们可以 memorystatus_action_needed 判断 -&gt; 规避Jetsam处理 1. 是否因为thrashing(如果是EMBEDED则不会触发这种情况) 2. 是否因为zone_map_exhaustion(判断Zone的消耗情况, vm_map 相关参数来做，感觉这个意义不大) 3. 是否因为memorystatus_available_pages &lt;= memorystatus_available_pages_pressure(是否是EMBEDDED)(根据物理内存page占比计算得到) -&gt; boot_arguments…能取到(外部拿不到，只能走内核调试拿.. ) watchdog为了避免应用陷入错误状态导致界面无响应，Apple 设计了看门狗 (WatchDog) 机制。一旦超时，强制杀死进程。在不同的生命周期，触发看门狗机制的超时时间有所不同： 生命周期 超时时间 启动 Launch 20 s 恢复 Resume 10 s 悬挂 Suspend 10 s 退出 Quit 6 s 后台 Background 10 min 如何抓到回调与如何监控抓到：libmalloc 中的 malloc_logger 函数指针。通过这个可以抓到所有malloc类分配。vm 则可以根据hook或者私有变量，和 malloc_logger一致。 监控: 每次抓到都获取调用栈，存储进自己定义的数据结构中。 这里为什么不会循环调用需要值得注意一下。是通过不同的逻辑分支，保证不会走到相同的带分配的逻辑分支。 数据结构设计1. 空间占用 2. 访问速度 3. 细节存储优化OOM事件捕获 现有方案，排除法 存在的问题 applicationstate不准等 经验值+ANR 优化","link":"/2018/04/10/iosoom/"},{"title":"dyld(2) lazy bind 和 dyld_stub_binder","text":"dyld会在程序首次执行lazy symbol的时候对其进行绑定操作。这片文章分析一下绑定的过程。 1234_main:...0000000100000f6f call imp___stubs__objc_alloc... 可以看到 当调用 objc_alloc 函数时，实际跳转到 imp___stubs__objc_alloc 1234imp___stubs__objc_alloc:00000001000065d0 nop ; CODE XREF=-[AppDelegate application:configurationForConnectingSceneSession:options:]+13200000001000065d4 ldr x16, #0x10000801000000001000065d8 br x16 其指令会跳转到 lazy symbol ptr section 中 0x100008010 地址的 0000000100006648 12345678; Section __la_symbol_ptr; Range: [0x100008010; 0x100008050[ (64 bytes); File offset : [32784; 32848[ (64 bytes); Flags: 0x7; S_LAZY_SYMBOL_POINTERS_objc_alloc_ptr:0000000100008010 dq 0x0000000100006648 ; DATA XREF=imp___stubs__objc_alloc+4 1234567sub_100006648:0000000100006648 ldr w16, #0x100006650 ; DATA XREF=_objc_alloc_ptr000000010000664c b 0x1000066300000000100006650 db 0x00 ; '.' ; DATA XREF=sub_1000066480000000100006651 db 0x00 ; '.'0000000100006652 db 0x00 ; '.'0000000100006653 db 0x00 ; '.' 随后跳转到 loc_100006630， 这一步存储必要的信息，调用dyld内部的dyld_stub_binder函数。 12345678910111213141516171819; Section __stub_helper; Range: [0x100006630; 0x1000066a8[ (120 bytes); File offset : [26160; 26280[ (120 bytes); Flags: 0x80000400; S_REGULAR; S_ATTR_PURE_INSTRUCTIONS; S_ATTR_SOME_INSTRUCTIONSloc_100006630:0000000100006630 adr x17, #0x100008008 ; CODE XREF=sub_100006648+4, sub_100006654+4, sub_100006660+4, sub_10000666c+4, sub_100006678+4, sub_100006684+4, sub_100006690+40000000100006634 nop0000000100006638 stp x16, x17, [sp, #-0x10]!000000010000663c nop0000000100006640 ldr x16, #0x1000080000000000100006644 br x16dyld_stub_binder_100008000:0000000100008000 dq dyld_stub_binder ; DATA XREF=-[AppDelegate application:configurationForConnectingSceneSession:options:]+180, 0x1000066400000000100008008 dq 0x0000000000000000 ; DATA XREF=0x100006630 注意 0000000100006638 stp x16, x17, [sp, #-0x10]!, 这里有个 bind info offset(x16) 压入到栈中的操作。 x17 的内容为 0x0000000000000000。根据下文 dyld_stub_binder , 是address of ImageLoader cache。是dyld自行修改的内容。 跳转到 0x100008000地址 的 dyld_stub_binder 上面的内容网上很多，下面来看一下dyld是怎么利用macho linkedit 段的数据，进行符号绑定的。 (1) dyld_stub_binder程序源码如下， 注意关键进行绑定操作的函数 __Z21_dyld_fast_stub_entryPvl dyld::fastBindLazySymbol。读了一下指令，可以和上文压栈的寄存器对应上。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#if __arm64__ /* * sp+0 lazy binding info offset * sp+8 address of ImageLoader cache // 从哪里来的呢 */.text.align 2.globl dyld_stub_binderdyld_stub_binder:stp fp, lr, [sp, #-16]!mov fp, spsub sp, sp, #240stp x0,x1, [fp, #-16] ; x0-x7 are int parameter registersstp x2,x3, [fp, #-32]stp x4,x5, [fp, #-48]stp x6,x7, [fp, #-64]stp x8,x9, [fp, #-80] ; x8 is used for struct returnsstp q0,q1, [fp, #-128] ; q0-q7 are vector/fp parameter registersstp q2,q3, [fp, #-160]stp q4,q5, [fp, #-192]stp q6,q7, [fp, #-224]ldr x0, [fp, #24] ; move address ImageLoader cache to 1st parameterldr x1, [fp, #16] ; move lazy info offset 2nd parameter; call dyld::fastBindLazySymbol(loadercache, lazyinfo)bl __Z21_dyld_fast_stub_entryPvlmov x16,x0 ; save target function address in lr; restore parameter registersldp x0,x1, [fp, #-16]ldp x2,x3, [fp, #-32]ldp x4,x5, [fp, #-48]ldp x6,x7, [fp, #-64]ldp x8,x9, [fp, #-80]ldp q0,q1, [fp, #-128]ldp q2,q3, [fp, #-160]ldp q4,q5, [fp, #-192]ldp q6,q7, [fp, #-224]mov sp, fpldp fp, lr, [sp], #16add sp, sp, #16 ; remove meta-parameters#if __arm64e__ // Note arm64e executables will never hit this line as they don't have lazy binding. // However, arm64 binaries running on an arm64e system will hit this line but the // authentication won't have any effect there.braaz x16#elsebr x16#endif#endif (2) dyld 源码查看一下 fastBindLazySymbol 的实现方式(2.1) lazy bind info 简介:简要介绍一下lazy bind info主要包含的内容信息。这是dyld绑定时主要利用的信息。 BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB: segment(1) //MachO中第几个Segement offset(224) // 偏移量224。根据segment起始地址+ 偏移量，可以找到lazy symbol ptr section 中 pointer 对应的位置 dylib(4)动态库加载序号。LC_LOAD_DYLIB. (2.2)doBindFastLazySymbol的过程 getLazyBindingInfo(lazyBindingInfoOffset, start, end, &amp;segIndex, &amp;segOffset, &amp;libraryOrdinal, &amp;symbolName, &amp;doneAfterBind)// 获取lazy bind 信息 uintptr_t address = segActualLoadAddress(segIndex) + segOffset; //获取需要绑定的lazy symbol ptr的地址 result = bindAt(context, this, address, BIND_TYPE_POINTER, symbolName, 0, 0, libraryOrdinal, NULL, lazy , NULL, true);// 绑定 (2.3)uintptr_t ImageLoaderMachOCompressed::resolve的过程 *targetImage = libImage((unsigned int)libraryOrdinal-1);// 获取外部符号所在的动态库 symbolAddress = resolveTwolevel(context, symbolName, *targetImage, this, (unsigned)libraryOrdinal, weak_import, runResolver, targetImage); // 根据符号名称找到外部符号地址。通过export_info 进行快速查找。 (2.4)uintptr_t ImageLoaderMachO::bindLocation的过程 将lazy symbol ptr地址的值设置为 symbolAddress","link":"/2020/03/04/lazybind/"},{"title":"libmalloc &quot;malloc&quot; 探究","text":"之前腾讯开源了 OOMDetector 用于监控内存分配，在集成到我司项目时, 修复了一些bug崩溃，优化了性能，在内存不是频繁分配的App上是有用武之地的。 OOMDetector 监控内存分配的核心处理 是通过 libmalloc库 中的 malloc_logger 指针实现的。 我之前一直疑惑 OOMDetector 的监控方式是否能够完善的监控到应用层面的&quot;malloc&quot;内存分配。这就有必要探究下应用层的内存分配API iOS “malloc” 内存分配iOS上都通过kernel进行内存分配，将虚拟内存页映射到应用内存空间上。我们在应用层可以通过mmap实现这种内存分配。 不过大多数情况下我们都通过“malloc”进行内存分配, 我们可以使用malloc来获取内存，而不用每次都请求vmpage映射。而malloc分配的内存实质上都是从vmpage映射获取的。 你一定注意到了 “malloc”, 是的，它代表calloc, realloc, valloc, malloc_zone_malloc, malloc_zone_calloc, malloc_zone_valloc, malloc_zone_realloc, malloc_zone_batch_malloc 等方法，本质上他们的分配都应该被归于一类，都是利用 scalable_zone 进行分配的。 顺便提一下，C++ new的分配 其实现也是用 libc 中的 malloc 进行分配的new_opnt.cc libmalloc 分析default_zone本着质疑的精神，一般我是不会相信空口无凭的文章的，因此，可以从libmalloc中找到答案。 首先找到 malloc, calloc等函数.. 的实现，因为原理类似，就不一一举出。 123456789101112131415161718192021void *malloc(size_t size){ void *retval; retval = malloc_zone_malloc(default_zone, size); if (retval == NULL) { errno = ENOMEM; } return retval;}void *calloc(size_t num_items, size_t size){ void *retval; retval = malloc_zone_calloc(default_zone, num_items, size); if (retval == NULL) { errno = ENOMEM; } return retval;} 首先来看看这个 default_zone 是什么东西, 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142typedef struct { malloc_zone_t malloc_zone; uint8_t pad[PAGE_MAX_SIZE - sizeof(malloc_zone_t)];} virtual_default_zone_t;static virtual_default_zone_t virtual_default_zone__attribute__((section(\"__DATA,__v_zone\")))__attribute__((aligned(PAGE_MAX_SIZE))) = { NULL, NULL, default_zone_size, default_zone_malloc, default_zone_calloc, default_zone_valloc, default_zone_free, default_zone_realloc, default_zone_destroy, DEFAULT_MALLOC_ZONE_STRING, default_zone_batch_malloc, default_zone_batch_free, &amp;default_zone_introspect, 9, default_zone_memalign, default_zone_free_definite_size, default_zone_pressure_relief};static malloc_zone_t *default_zone = &amp;virtual_default_zone.malloc_zone;static void *default_zone_malloc(malloc_zone_t *zone, size_t size){ zone = runtime_default_zone(); return zone-&gt;malloc(zone, size);}MALLOC_ALWAYS_INLINEstatic inline malloc_zone_t *runtime_default_zone() { return (lite_zone) ? lite_zone : inline_malloc_default_zone();} 可以看到 default_zone 通过这种方式来初始化 1234567static inline malloc_zone_t *inline_malloc_default_zone(void){ _malloc_initialize_once(); // _malloc_printf(ASL_LEVEL_INFO, \"In inline_malloc_default_zone with %d %d\\n\", malloc_num_zones, malloc_has_debug_zone); return malloc_zones[0];} 随后的调用如下_malloc_initialize -&gt; create_scalable_zone -&gt; create_scalable_szone 最终我们创建了 szone_t 类型的对象，通过类型转换，得到了我们的 default_zone。 1234malloc_zone_t *create_scalable_zone(size_t initial_size, unsigned debug_flags) { return (malloc_zone_t *) create_scalable_szone(initial_size, debug_flags);} “malloc”上文代码段中写道malloc 中调用了 malloc_zone_malloc, 看看malloc_zone_malloc 的实现是什么 1234567891011121314151617181920212223void *malloc_zone_malloc(malloc_zone_t *zone, size_t size){ MALLOC_TRACE(TRACE_malloc | DBG_FUNC_START, (uintptr_t)zone, size, 0, 0); void *ptr; if (malloc_check_start &amp;&amp; (malloc_check_counter++ &gt;= malloc_check_start)) { internal_check(); } if (size &gt; MALLOC_ABSOLUTE_MAX_SIZE) { return NULL; } ptr = zone-&gt;malloc(zone, size); // if lite zone is passed in then we still call the lite methods if (malloc_logger) { malloc_logger(MALLOC_LOG_TYPE_ALLOCATE | MALLOC_LOG_TYPE_HAS_ZONE, (uintptr_t)zone, (uintptr_t)size, 0, (uintptr_t)ptr, 0); } MALLOC_TRACE(TRACE_malloc | DBG_FUNC_END, (uintptr_t)zone, size, (uintptr_t)ptr, 0); return ptr;} 其分配实现是 zone-&gt;malloc 根据之前的分析，就是szone_t结构体对象中对应的malloc实现。 在创建szone之后，做了一系列如下的初始化操作。 1234567891011121314151617// Initialize the security token.szone-&gt;cookie = (uintptr_t)malloc_entropy[0];szone-&gt;basic_zone.version = 9;szone-&gt;basic_zone.size = (void *)szone_size;szone-&gt;basic_zone.malloc = (void *)szone_malloc;szone-&gt;basic_zone.calloc = (void *)szone_calloc;szone-&gt;basic_zone.valloc = (void *)szone_valloc;szone-&gt;basic_zone.free = (void *)szone_free;szone-&gt;basic_zone.realloc = (void *)szone_realloc;szone-&gt;basic_zone.destroy = (void *)szone_destroy;szone-&gt;basic_zone.batch_malloc = (void *)szone_batch_malloc;szone-&gt;basic_zone.batch_free = (void *)szone_batch_free;szone-&gt;basic_zone.introspect = (struct malloc_introspection_t *)&amp;szone_introspect;szone-&gt;basic_zone.memalign = (void *)szone_memalign;szone-&gt;basic_zone.free_definite_size = (void *)szone_free_definite_size;szone-&gt;basic_zone.pressure_relief = (void *)szone_pressure_relief; 在magazine_malloc.c有着对应的实现。 malloc_loggermalloc_logger 在 libmalloc 中的以下方法内被调用 malloc_zone_malloc malloc_zone_calloc malloc_zone_valloc malloc_zone_realloc malloc_zone_free malloc_zone_free_definite_size malloc_zone_memalign 等函数中被调用，我们 “malloc” 系列的方法都会调用到这些函数 如果你使用 malloc_logger 回调，那么 “malloc” 分配你都可以监控到. OOMDetector 中也针对不同的分配做了不同的处理。因此使用malloc_logger回调是可以监控到 “malloc”分配的，验证了文章开头的猜测。 总结以malloc_logger为线索，探究了一下libmalloc的源码，确定了OOMDetector的原理。当然最重要的是建立对 iOS 内存分配的整体理解。 本文只写了对”malloc”内存分配的理解，以后有时间，会写一下 XNU内存管理相关的文章。","link":"/2018/06/13/libmalloc/"},{"title":"lli源码阅读","text":"最近需要了解一下解释器的实现。通过阅读lli学习了一波。","link":"/2020/04/08/lliread/"},{"title":"dyld(1) MachO Linkedit 段","text":"Linkedit 段 包含了动态链接相关的数据信息，dyld基于linkedit段提供的数据进行动态链接，想要了解dyld的工作原理和流程，研究一下linkedit段的内容是个不错的方式。 DyldInfo符号绑定 Binding Info &amp;&amp; Lazy Binding Info123456789101112/* * Dyld binds an image during the loading process, if the image * requires any pointers to be initialized to symbols in other images. * The bind information is a stream of byte sized * opcodes whose symbolic names start with BIND_OPCODE_. * Conceptually the bind information is a table of tuples: * &lt;seg-index, seg-offset, type, symbol-library-ordinal, symbol-name, addend&gt; * The opcodes are a compressed way to encode the table by only * encoding when a column changes. In addition simple patterns * like for runs of pointers initialzed to the same value can be * encoded in a few bytes. */ seg-index: segment idxseg-offset: offsettypesymbol-library-ordinal: 所在库的加载序号 LC_LOAD_DYLIBsymbol-nameaddend 通过 seg-index, seg-offset, symbol-library-ordinal 我们便可以确认符号在运行时的地址。","link":"/2020/03/03/macholinkedit/"},{"title":"imp_implementationWithBlock 的内部实现 trampoline","text":"imp_implementationWithBlock 把 block 转化为imp, 是如何实现的呢？ block的函数调用，需要传递block对象，这需要我们在 调用imp的时候，能够找到block对象。 看看objc是如何实现的。 具体实现的思路是，将block对象存在 trampoline’s data 中。trampoline data 和 text page offset 为2个page size(由申请的时候决定) 返回的imp是一个跳板。 这个跳板技术可用于hook, 怎么搞，自行发挥想象吧 12345678910111213IMP trampoline(int aMode, uintptr_t index) { assert(validIndex(index)); char *base = (char *)trampolinesForMode(aMode); char *imp = base + index*slotSize();#if __arm__ imp++; // trampoline is Thumb instructions#endif#if __has_feature(ptrauth_calls) imp = ptrauth_sign_unauthenticated(imp, ptrauth_key_function_pointer, 0);#endif return (IMP)imp;} 执行时，TrampolineEntry 为跳板，通过 偏移量取到 block对象，随后进行调用。 1234567891011121314151617181920212223L_objc_blockTrampolineImpl: /* x0 == self x17 == address of called trampoline&apos;s data (2 pages before its code) lr == original return address */ mov x1, x0 // _cmd = self ldr p0, [x17] // self = block object add p15, p0, #BLOCK_INVOKE // x15 = &amp;block-&gt;invoke ldr p16, [x15] // x16 = block-&gt;invoke TailCallBlockInvoke x16, x15 // pad up to TrampolineBlockPagePair header size nop nop nop .macro TrampolineEntry // load address of trampoline data (two pages before this instruction) adr x17, -2*PAGE_MAX_SIZE b L_objc_blockTrampolineImpl.endmacro","link":"/2020/04/10/objcblockimp/"},{"title":"Method Swizzling 的正确途径","text":"iOS 平台开发，有时会使用到Method Swizzling, 但Method Swizzling 在使用过程中有许多需要注意的问题，本文将介绍将会产生的问题，并且分析 RSSwizzle 是如何解决这些问题的。 在Objective-C 中方法交换有什么危险What are the Dangers of Method Swizzling in Objective C?stackoverflow 上的这个回答十分精彩。 - Method swizzling 并不是原子操作 - 改变了不是我们自己代码的行为 - 有可能出现命名冲突 - Swizzling 改变方法的参数 - Swizzles 顺序问题 - 难于理解 - 难于DebugSwizzling 改变方法的参数 例子使用method_exchangeImplementations更改方法的实现，会导致一个问题，origin_imp 如果使用了 _cmd 参数，hook之后的_cmd 是不符合预期的。 hook touchesBegan 过的同学应该遇到这种问题。 1- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event; 这个函数里面 调用了 forwardTouchMethod , 反汇编后类似这种。 123- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { forwardTouchMethod(self, _cmd, touches, event);} 123456789101112131415161718192021222324252627282930static void forwardTouchMethod(id self, SEL _cmd, NSSet *touches, UIEvent *event) { // The responder chain is used to figure out where to send the next touch UIResponder *nextResponder = [self nextResponder]; if (nextResponder &amp;&amp; nextResponder != self) { // Not all touches are forwarded - so we filter here. NSMutableSet *filteredTouches = [NSMutableSet set]; [touches enumerateObjectsUsingBlock:^(UITouch *touch, BOOL *stop) { // Checks every touch for forwarding requirements. if ([touch _wantsForwardingFromResponder:self toNextResponder:nextResponder withEvent:event]) { [filteredTouches addObject:touch]; }else { // This is interesting legacy behavior. Before iOS 5, all touches are forwarded (and this is logged) if (!_UIApplicationLinkedOnOrAfter(12)) { [filteredTouches addObject:touch]; // Log old behavior static BOOL didLog = 0; if (!didLog) { NSLog(@\"Pre-iOS 5.0 touch delivery method forwarding relied upon. Forwarding -%@ to %@.\", NSStringFromSelector(_cmd), nextResponder); } } } }]; // here we basically call [nextResponder touchesBegan:filteredTouches event:event]; [nextResponder performSelector:_cmd withObject:filteredTouches withObject:event]; }} 如果我们exchange了 imp, [nextResponder performSelector:_cmd withObject:filteredTouches withObject:event]; 是没有相应的实现的，_cmd 就变成了 我们替换的 sel. 显然，nextResponder没有实现相应的方法，就会crash。 正确的hook方式方案一:直接替换 method 的 IMP.method_setImplementation, 在新的IMP中调用原始的 IMP. RSSwizzleRSSwizzle 实现方式 1. 根据block生成NEW IMP 2. replace 目标方法的实现 3. block可以获取原来的IMP 核心交换代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869static void swizzle(Class classToSwizzle, SEL selector, RSSwizzleImpFactoryBlock factoryBlock){ Method method = class_getInstanceMethod(classToSwizzle, selector); NSCAssert(NULL != method, @\"Selector %@ not found in %@ methods of class %@.\", NSStringFromSelector(selector), class_isMetaClass(classToSwizzle) ? @\"class\" : @\"instance\", classToSwizzle); NSCAssert(blockIsAnImpFactoryBlock(factoryBlock), @\"Wrong type of implementation factory block.\"); __block OSSpinLock lock = OS_SPINLOCK_INIT; // To keep things thread-safe, we fill in the originalIMP later, // with the result of the class_replaceMethod call below. __block IMP originalIMP = NULL; // This block will be called by the client to get original implementation and call it. RSSWizzleImpProvider originalImpProvider = ^IMP{ // It's possible that another thread can call the method between the call to // class_replaceMethod and its return value being set. // So to be sure originalIMP has the right value, we need a lock. OSSpinLockLock(&amp;lock); IMP imp = originalIMP; OSSpinLockUnlock(&amp;lock); if (NULL == imp){ // If the class does not implement the method // we need to find an implementation in one of the superclasses. Class superclass = class_getSuperclass(classToSwizzle); imp = method_getImplementation(class_getInstanceMethod(superclass,selector)); } return imp; }; RSSwizzleInfo *swizzleInfo = [RSSwizzleInfo new]; swizzleInfo.selector = selector; swizzleInfo.impProviderBlock = originalImpProvider; // We ask the client for the new implementation block. // We pass swizzleInfo as an argument to factory block, so the client can // call original implementation from the new implementation. id newIMPBlock = factoryBlock(swizzleInfo); const char *methodType = method_getTypeEncoding(method); NSCAssert(blockIsCompatibleWithMethodType(newIMPBlock,methodType), @\"Block returned from factory is not compatible with method type.\"); IMP newIMP = imp_implementationWithBlock(newIMPBlock); // Atomically replace the original method with our new implementation. // This will ensure that if someone else's code on another thread is messing // with the class' method list too, we always have a valid method at all times. // // If the class does not implement the method itself then // class_replaceMethod returns NULL and superclasses's implementation will be used. // // We need a lock to be sure that originalIMP has the right value in the // originalImpProvider block above. OSSpinLockLock(&amp;lock); // originIMP get value from here originalIMP = class_replaceMethod(classToSwizzle, selector, newIMP, methodType); OSSpinLockUnlock(&amp;lock);} 具体过程解析 如果hook的方法在hook的类中有实现 1. block生成新的IMP 2. 替换IMP, 这时候拿到原始的ORIGINIMP 3. block接受了一个RSSwizzleInfo参数，从参数中可以拿到当时保存的获得IMP的block 4. 由于block中存储的是originIMP ，所以获得的是原始的实现 如果hook的方法在子类中无实现 1. block生成新的IMP 2. 替换IMP（由于没有实现，相当于add了IMP）, 原始的实现为nil 3. block 中我们调用calloriginIMP,这个方法实际调用了一个block originalImpProvider 4. 这个block的从父类找到相应的实现（注意，这里实际上是在 调用方法 时才会触发） 这种情况是调用时，动态获得 当时的方法实现，所以可以避免hook顺序带来的问题。 那么影响Swizzle的结果到底是是什么呢？Swizzle实现方式本质上就是改变方法的IMP 为 NewIMP, 并调用原先的originIMP 只hook一个是没问题，但是涉及到多次hook, 并且hook的方法可能为一个时， 他们的顺序就会导致不同的结果，因为顺序不同，Swizzle时，Method 相应的 IMP 不相同。这里我们更关注，父子类+hook 同一个方法产生的问题。 那么RSSwizzle 怎么解决问题的呢？ 父类有method, 子类没有实现method.我们有如下的IMP:superIMP,superNewIMP,subNewIMp此时，我们Swizzle 父类的method 为 superNewIMPSwizzle子类的method 为 subNewIMp 首先关注我们期望的调用顺序 1. subNewIMP 2. superNewIMP 3. superIMP 我们先hook父类，再hook子类后，的调用顺序 1. subNewImp 2. superNewIMP 3. superIMp 先hook子类再hook父类 1. subNewIMP 2. superIMP 为什么会有差异?因为当我们在hook子类方法时，原先的方法实现是不同的。 解决问题那就要保证，即使hook的顺序不同，也能正确取到相应的IMP那我们保证，子类在调用相应方法的时候，取到的IMP是父类当前的IMP就可以(这样就和Swizzle的时间顺序没有了关系) RSSwizzle 加锁，保证线程安全originalImpProvider 的代码 12345678910RSSWizzleImpProvider originalImpProvider = ^IMP{ OSSpinLockLock(&amp;lock); IMP imp = originalIMP; OSSpinLockUnlock(&amp;lock); if (NULL == imp){ Class superclass = class_getSuperclass(classToSwizzle); imp = method_getImplementation(class_getInstanceMethod(superclass,selector)); } return imp;} Swizzle 方法的某个部分 123OSSpinLockLock(&amp;lock);originalIMP = class_replaceMethod(classToSwizzle, selector, newIMP, methodType);OSSpinLockUnlock(&amp;lock); 这两个方法有个共享变量 originalIMP，这就意味着，可能会出现线程安全问题。再仔细看下代码 1234OSSpinLockLock(&amp;lock);IMP imp = originalIMP;OSSpinLockUnlock(&amp;lock);if (NULL == imp){ 这个共享变量，和条件判断相关。敏锐的同学一眼就能看出来，在不加锁的情况下，当不同的线程对 这两段代码进行执行的时候，就会出现，即使if (NULL == imp){通过了，但实际上，另一条线程执行了class_replaceMethod()。这时就会出现问题。 在加锁之后，在同一时间段内，只有一个线程能访问改变这个变量的代码。避免了共享变量导致的线程安全问题。 采用Block添加实现，没有命名冲突问题连命名的机会都没有… 12345678910111213RSSwizzleInstanceMethod(classToSwizzle, @selector(calculate:), RSSWReturnType(int), RSSWArguments(int number), RSSWReplacement({ // The following code will be used as the new implementation. // Calling original implementation. int res = RSSWCallOriginal(number); // Returning modified return value. return res + 1;}), 0, NULL); 采用block 添加实现，只是改变了原来的IMP ，Selector没有改变，实现的_cmd并没有改变参数_cmd是当前方法的selector swizzle method 可能会导致的_cmd 参数改变，例如我们有originMethod和newMethod,他们分别对应着 OriginIMP,和NewIMP.当我们交换方法实现后: 12originmethod -&gt; NewIMPnewMethod -&gt; OriginIMP 要想调用原来的实现，我们需要调用 newMethod 这就导致了 相同的IMP 但是_cmd 却改变了","link":"/2017/12/04/safeSwizzleRSSwizzleAnalyze/"},{"title":"CocoaPods插件开发原理(二) 定制项目CocoaPods插件环境","text":"CocoaPods是主流的iOS工程依赖管理工具。我们在使用CocoaPods管理工程的过程中，经常面对\b各种定制化的需求。CocoaPods提供的插件机制可以帮助我们定制CocoaPods。随着插件的增多，管理插件也成为了蛋疼的问题…… 本片文章介绍如何利用Bundler管理项目插件。 BundlerBundler是Ruby的依赖管理工具，通过Gemfile可以指定项目依赖的ruby gems。通过bundle install 进行安装。bundle exec 执行。 Gemfile和 podfile 挺像的,可以类比一下。 1234567# 指定了gem源source &apos;https://rubygems.org&apos; # 指定 gem 及其 版本 gem &apos;nokogiri&apos;gem &apos;rack&apos;, &apos;~&gt; 2.0.1&apos;gem &apos;rspec&apos; bundle installbundle install 会安装 Gemfile指定的依赖。 bundle execbundle exec 将会在 bundle install 依赖安装后的环境中执行 命令。 This command executes the command, making all gems specified in the Gemfile(5) available to require in Ruby programs. 上面巴拉巴拉说了一堆，总之就是 把依赖写进 Gemfile 里 bundle install 安装依赖 bundle exec 在安装依赖后的环境中执行命令","link":"/2019/11/26/projectpodenv/"},{"title":"理解HTTPS","text":"Monday, 25 September 20177:36 PM 文章围绕的问题： 如何解决窃听风险？ 如何解决篡改风险？ 如何解决冒充风险？ 什么是数字证书？ CA证书的验证 什么是签名？ HTTPS 简介超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。这个协议由网景公司（Netscape）在1994年首次提出，随后扩展到互联网上。 wikipedia https简单的图示 HTTP+加密+认证+完整性保护 = HTTPS. 通常，http直接和tcp通信。当使用ssl/tls时，则演变成先和ssl/tls通信，再由ssl/tls和tcp通讯，因此，https其实就是身披ssl/tls保护外衣的http. HTTPS 四次握手的过程 客户端发出请求在这一步，客户端主要向服务器提供以下信息。（1） 支持的协议版本，比如TLS 1.0版。（2） 一个客户端生成的随机数，稍后用于生成”对话密钥”。（3） 支持的加密方法，比如RSA公钥加密。（4） 支持的压缩方法。 服务器回应服务器收到客户端请求后，向客户端发出回应，这叫severHello.包含如下内容（1）确认使用的加密通信协议版本（2）一个服务器生成的随机数（3）确认使用的加密方法，比如RSA（4）服务器证书 客户端回应客户端验证证书，如果证书没有问题，客户端就会从证书中取出服务器的public-key。向服务器发送下面三项消息。（1）一个随机数。该随机数用服务器public-key加密，防止被窃听（2）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项也是前面发送的所有内容的hash值，用来供服务器校检。 服务器的最后回应服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的“会话密钥”。然后向客户端最后发送下面消息。（1）编码改变通知。表示随后的信息都将用双方商定的加密方法和密钥发送。（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash, 用来供服务器校检。 HTTPS 解决了 HTTP 在安全性方面的哪些问题HTTP 通信的风险 窃听风险：第三方可以获知通信内容 篡改风险：第三方可以修改通信内容 冒充风险：第三方可以冒充他人身份参与通信 如何解决这些风险? SSL/TSL 协议 加密传播，第三方无法窃听 具有校验机制，一旦被篡改，通信双方会立刻发现 SSL/TSL协议有两个问题 如何保证public-key不被篡改？ 可信任的第三方认证证书，证书中有public-key 那如何保证证书的可信任性？ publick-key计算量太大，如何减少耗用的时间？ 解决方法：每一次对话（session），客户端和服务器端都生成一个”对话密钥”（session key），用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。 上面对HTTPS的介绍 看不懂没关系，下面来了解一些相关的概念 SSL，数字证书，签名，RSASSL/TLS协议的基本过程 （1）客户端向服务器索要并验证public-key （2） 双方协商生成“对话密钥” （3）双方采用“对话密钥”进行加密通信 如何验证数字证书？ 读取证书发布机构 在操作系统中受信任的发布机构中查找 从证书中取出publick-key对证书的指纹和指纹算法用这个public-key进行解密，然后用这个指纹算法计算证书指纹，然后与证书中的指纹进行对比。 如果一致，说明证书是CA发布的 证书如何证明服务器身份 在使用证书之前，通信中，可能出现对方的身份无法确定。 使用证书之后，CA是可信的，通过对证书进行校检，确认证书的合法性，证书合法后，则 客户端向服务器发送随机字符串 服务器加密 客户端用证书中的public-key解密，结果一致，则可以证明服务器是证书上的服务器。 RSA RSA是一种公钥密码体制 RSA密码体制是一种公钥密码体制，公钥公开，私钥保密，它的加密解密算法是公开的。 由公钥加密的内容可以并且只能由私钥进行解密，并且由私钥加密的内容可以并且只能由公钥进行解密。也就是说，RSA的这一对公钥、私钥都可以用来加密和解密，并且一方加密的内容可以由并且只能由对方进行解密。 重点：自己保留private-key, 只有private-key加密的内容，才能用public-key解密，这是保证别人无法伪造private-key持有者的重要保障。也就是说，是无法伪造RSA加密后内容的。 RSA加密算法在通信过程中起到的作用主要有两个： 因为私钥只有“服务器”拥有，因此“客户”可以通过判断对方是否有私钥来判断对方是否是“服务器” 客户端通过RSA的掩护，安全的和服务器商量好一个对称加密算法和密钥来保证后面通信过程内容的安全。 签名签名就是在信息的后面再加上一段内容，可以证明信息没有修改过。一般对信息进行hash计算得到一个hash值。在把信息发送时，把签名和签名算法一起发送出去。接收方在接受信息后，用签名算法计算hash值，与签名进行比较。 报文Hash生成摘要信息Digest,用private-key 加密生成签名 客户端用public-key揭秘签名 客户端对报文做同样的hash处理，和上一步得到的结果进行对比 为了防止他人修改信息内容时，也对hash值进行修改，hash值和算法都会加密，以保证这个hash值不被修改。 加密算法，加密算法后，对方无法根据内容得到相应的hash值，这样就无法伪造内容。 加密hash值，加密后，则可以给接收方一个用来验证的值。 使用rsa加密算法，可以保证签名和hash算法不被他人更改。 数字证书 数字证书简称CA，它由权威机构给某网站颁发的一种认可凭证，这个凭证是被大家（浏览器）所认可的 为什么需要数字证书？ 避免他人冒充服务器 中间人攻击 数字证书一般由证书认证机构颁发，证书里面包含了真实服务器的public-key和网站的其他信息，数字证书机构用自己的private-key加密后发给浏览器，浏览器使用数字证书机构的publick-key揭秘后得到真实服务器的publick-key。 为什么一定要用三个随机数，来生成”会话密钥” 至于为什么一定要用三个随机数，来生成”会话密钥”，dog250解释得很好：“不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。” 详细过程图 注 ： 双方都进行hash验证 服务端知道hash是否正确后，需要让客户端知道自己是否验证正确，客户端也需要验证一次hash，避免服务器造假。 D是最后HTTP使用的密钥 参考文章• SSL/TLS协议运行机制的概述 http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html• 图解SSL http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html• 数字证书 https://blog.cnbluebox.com/blog/2014/03/24/shu-zi-zheng-shu/• 数字证书原理 http://blog.sae.sina.com.cn/archives/4939• 图解HTTPS http://www.jianshu.com/p/51cc23843756","link":"/2017/09/26/%E7%90%86%E8%A7%A3HTTPS/"},{"title":"理解 Objc Runtime","text":"Runtime 是什么一个用C和汇编语言写的Runtime库,来动态 创建类和对象、进行消息传递和转发。（在运行时执行部分编译后的代码） Objective-CObjective-C 扩展了 C 语言，并加入了面向对象特性和 Smalltalk 式的消息传递机制。而这个扩展的核心是一个用 C 和 编译语言 写的 Runtime 库。它是 Objective-C 面向对象和动态机制的基石。 Objective-C 是一个动态语言，这意味着它不仅需要一个编译器，也需要一个运行时系统来动态 创建类和对象、进行消息传递和转发。理解 Objective-C 的 Runtime 机制可以帮我们更好的了解这个语言，适当的时候还能对语言进行扩展，从系统层面解决项目中的一些设计或技术问题。 Runtime的核心是 - 消息传递 （Messaging）。(动态调度) Runtime 原理的概述Objective-C的是一个运行时面向语言，这意味着当它可能在运行时决定如何实现而不是在编译期。 这给你很大的灵活性，你可以根据需要将消息重定向到适当的对象，或者甚至有意交换方法实现等。如果我们将它与C语言进行对比。 在很多语言，比如 C ，调用一个方法其实就是跳到内存中的某一点并开始执行一段代码。没有任何动态的特性，因为这在编译时就决定好了。而在 Objective-C 中，[object foo] 语法并不会立即执行 foo 这个方法的代码。它是在运行时给 object 发送一条叫 foo 的消息。这个消息，也许会由 object 来处理，也许会被转发给另一个对象，或者不予理睬假装没收到这个消息。多条不同的消息也可以对应同一个方法实现。这些都是在程序运行的时候决定的。 什么是Objective-C运行时？Objective-C运行时是一个运行库，它是一个主要在C＆Assembler中编写的库，它将面向对象的功能添加到C中以创建Objective-C。 这意味着它加载类信息，所有方法调度，方法转发等。Objective-C运行时本质上创建所有支持结构，使面向对象的编程与Objective-C可能。 Objective-C 类和对象Objective-c类本身也是对象，而运行时通过创建Meta类处理这一点。 当你发送一个消息，如[NSObject alloc]，你实际上是发送一个消息到类对象，该类对象需要是一个MetaClass的实例，它本身是根元类的实例。 而如果你说NSObject的子类，你的类指向NSObject作为它的超类。 然而，所有元类都指向根元类作为它们的超类。 所有的元类都只有它们响应的消息的方法列表的类方法。 所以当你发送消息到类对象，如[NSObject alloc]，然后objc_msgSend（）实际上通过元类查看它的响应，然后如果它找到一个方法，操作类对象。 为什么Objective-C的对象都要继承 NSObject最初当你开始Cocoa开发，你可能没注意到我们的类一直都恪守着继承自NSObject的写法，有一件事你甚至没有意识到，发生在你身上的是将对象设置为使用Objective-C运行时。 1MyObject *object = [[MyObject alloc] init]; 执行的第一个消息是+ alloc。 如果你看看文档，它说“新实例的isa实例变量被初始化为描述类的数据结构;所有其他实例变量的内存设置为0” 所以通过继承NSObject类，我们不仅继承了一些伟大的属性，而且我们继承了在内存中容易地分配和创建我们的对象的能力. 那么什么是类缓存？ （objc_cache * cache）你或许在源码中发现了 Cache cache; 1234567891011struct objc_class : objc_object { Class superclass; const char *name; uint32_t version; uint32_t info; uint32_t instance_size; struct old_ivar_list *ivars; struct old_method_list **methodLists; Cache cache; ...} 看看它是什么样的结构体: 12345struct objc_cache { unsigned int mask /* total = mask + 1 */ OBJC2_UNAVAILABLE; unsigned int occupied OBJC2_UNAVAILABLE; Method buckets[1] OBJC2_UNAVAILABLE;}; 可以看到一个类中 有 一个存放方法列表的数据结构,那么它到底用来干嘛的呢? 一个 class 往往只有 20% 的函数会被经常调用，可能占总调用次数的 80% 。每个消息都需要遍历一次 objc_method_list 并不合理。如果把经常被调用的函数缓存下来，那可以大大提高函数查询的效率。这也就是 objc_class 中另一个重要成员 objc_cache 做的事情 - 再找到 foo 之后，把 foo 的 method_name 作为 key ，method_imp 作为 value 给存起来。当再次收到 foo 消息的时候，可以直接在 cache 里找到，避免去遍历 objc_method_list.(Hash表的方法实现) 当Objective-C运行时通过跟踪它的isa指针检查对象时，它可以找到一个实现许多方法的对象。然而，你可能只调用它们的一小部分，并且每次查找时，搜索所有选择器的类分派表没有意义。所以类实现一个缓存，每当你搜索一个类分派表，并找到相应的选择器，它把它放入它的缓存。所以当objc_msgSend（）查找一个类的选择器，它首先搜索类缓存。这是基于这样的理论：如果你在类上调用一个消息，你可能以后再次调用该消息。所以如果我们考虑到这一点，这意味着如果我们有一个NSObject子类，名为MyObject并运行以下代码 12345678910MyObject *obj = [[MyObject alloc] init];@implementation MyObject-(id)init { if(self = [super init]){ [self setVarA:@”blah”]; } return self;}@end 消息发送 I’m sorry that I long ago coined the term “objects” for this topic because it gets many people to focus on the lesser idea. The big idea is “messaging” – that is what the kernal[sic] of Smalltalk is all about… The key in making great and growable systems is much more to design how its modules communicate rather than what their internal properties and behaviors should be. Alan Kay 曾多次强调 Smalltalk 的核心不是面向对象，面向对象只是 the lesser ideas，消息传递 才是 the big idea。 消息传递的关键藏于 objc_object 中的 isa 指针和 objc_class 中的 class dispatch table。 在 Objective-C 中，类、对象和方法都是一个 C 的结构体，从 objc/objc.h 头文件中，我们可以找到他们的定义： 123456789101112131415struct objc_class : objc_object { Class superclass; const char *name; uint32_t version; uint32_t info; uint32_t instance_size; struct old_ivar_list *ivars; struct old_method_list **methodLists; Cache cache; struct old_protocol_list *protocols; // CLS_EXT only const uint8_t *ivar_layout; struct old_class_ext *ext; /.../} struct objc_ivar_list ivars OBJC2_UNAVAILABLE; // 该类的成员变量链表struct objc_method_list *methodLists OBJC2_UNAVAILABLE; // 方法定义的链表 12345678struct old_ivar_list { int ivar_count;#ifdef __LP64__ int space;#endif /* variable length structure */ struct old_ivar ivar_list[1];}; 1234567891011struct old_method_list { void *obsolete; int method_count;#ifdef __LP64__ int space;#endif /* variable length structure */ // 可变长的方法数组 struct old_method method_list[1];}; objc_method_list 本质是一个有 objc_method 元素的可变长度的数组。一个 objc_method 结构体中有函数名，也就是SEL，有表示函数类型的字符串 (见 Type Encoding) ，以及函数的实现IMP。 这里有一些你可能感兴趣的代码: Cache,protocol_List,class_extension 123456789101112131415typedef struct objc_cache *Cache OBJC2_UNAVAILABLE;#define CACHE_BUCKET_NAME(B) ((B)-&gt;method_name)#define CACHE_BUCKET_IMP(B) ((B)-&gt;method_imp)#define CACHE_BUCKET_VALID(B) (B)#ifndef __LP64__#define CACHE_HASH(sel, mask) (((uintptr_t)(sel)&gt;&gt;2) &amp; (mask))#else#define CACHE_HASH(sel, mask) (((unsigned int)((uintptr_t)(sel)&gt;&gt;3)) &amp; (mask))#endifstruct objc_cache { unsigned int mask /* total = mask + 1 */ OBJC2_UNAVAILABLE; unsigned int occupied OBJC2_UNAVAILABLE; Method buckets[1] OBJC2_UNAVAILABLE;}; 12345struct old_protocol_list { struct old_protocol_list *next; long count; struct old_protocol *list[1];}; 12345struct old_class_ext { uint32_t size; const uint8_t *weak_ivar_layout; struct old_property_list **propertyLists;}; 好了 接下来让我们接触Runtime的核心机制，消息机制 消息发送的步骤 Check for ignored selectors (GC) and short-circuit.如果 selector 是需要被忽略的垃圾回收用到的方法，则将 IMP 结果设为 _objc_ignored_method，这是个汇编程序入口，可以理解为一个标记。(OSX) Check for nil target.检查对象是否为nil If nil &amp; nil receiver handler configured, jump to handler If nil &amp; no handler (default), cleanup and return. Search the class’s method cache for the method IMP 在cache 中查找IMP If found, jump to it.找到，跳转到相应的内存地址 Not found: lookup the method IMP in the class itself 未找到，在类的method_list中查找 If found, jump to it.找到，跳转 If not found, jump to forwarding mechanism.未找到，进入消息分发的步骤 消息分发的步骤 在对象类的 dispatch table 中尝试找到该消息。如果找到了，跳到相应的函数IMP去执行实现代码； 如果没有找到，Runtime 会发送 +resolveInstanceMethod: 或者 +resolveClassMethod: 尝试去 resolve 这个消息； 如果 resolve 方法返回 NO，Runtime 就发送 -forwardingTargetForSelector: 允许你把这个消息转发给另一个对象； 如果没有新的目标对象返回， Runtime 就会发送 -methodSignatureForSelector: 和 -forwardInvocation: 消息。你可以发送 -invokeWithTarget: 消息来手动转发消息或者发送 -doesNotRecognizeSelector: 抛出异常。 resolveInstanceMethod/resolveClassMethod 方法解析，这里可以动态添加方法（添加了即可返回YES) forwardingTargetForSelector 把Selector 转发给其他实例响应 methodSignatureForSelector,invokeWithTarget,doesNotRecognizeSelector 添加方法签名，让其他实例来处理方法的调用 关于objc_msgSend函数事实上，在编译时你写的 Objective-C 函数调用的语法都会被翻译成一个 C 的函数调用 - objc_msgSend() 。 关于消息分发三个步骤的Example: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 第一步// 成功解析的实例方法/* + (BOOL)resolveInstanceMethod:(SEL)sel { NSString *selectorString = NSStringFromSelector(sel); if ([selectorString isEqualToString:@\"mysteriousMethod\"]) { class_addMethod(self.class, @selector(mysteriousMethod), (IMP)functionForMethod1, \"@:\"); } return [super resolveInstanceMethod:sel]; } */// 在没有找到方法时，会先调用此方法，可用于动态添加方法// 返回 YES 表示相应 selector 的实现已经被找到并添加到了类中，否则返回 NO+ (BOOL)resolveInstanceMethod:(SEL)sel { return YES;}// 第二步// 如果第一步的返回 NO 或者直接返回了 YES 而没有添加方法，该方法被调用// 在这个方法中，我们可以指定一个可以返回一个可以响应该方法的对象// 如果返回 self 就会死循环- (id)forwardingTargetForSelector:(SEL)aSelector{ if(aSelector == @selector(xxx:)){ return self.alternateObject; } return [super forwardingTargetForSelector:aSelector];}// 第三步// 如果 `forwardingTargetForSelector:` 返回了 nil，则该方法会被调用，系统会询问我们要一个合法的『类型编码(Type Encoding)』// 若返回 nil，则不会进入下一步，而是无法处理消息- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector { return [NSMethodSignature signatureWithObjCTypes:\"v@:\"];}// 当实现了此方法后，-doesNotRecognizeSelector: 将不会被调用// 如果要测试找不到方法，可以注释掉这一个方法// 在这里进行消息转发- (void)forwardInvocation:(NSInvocation *)anInvocation { // 我们还可以改变方法选择器 [anInvocation setSelector:@selector(notFind)]; // 改变方法选择器后，还需要指定接受者 [anInvocation invokeWithTarget:self];}- (void)notFind { NSLog(@\"没有实现 -mysteriousMethod 方法，并且成功的转成了 -notFind 方法\");} 你可能忽略了一个细节 V-Table如果你学过C++，你可能会了解到Hybrid vTable Dispatch（虚拟表分发）.你可以参考我的这篇文章iOS 调用机制 Hybrid vTable Dispatch新的 Objc-runtime-new.m 这样写到 1234567891011121314151617181920212223242526272829/************************************************************************ vtable dispatch** Every class gets a vtable pointer. The vtable is an array of IMPs.* The selectors represented in the vtable are the same for all classes* (i.e. no class has a bigger or smaller vtable).* Each vtable index has an associated trampoline which dispatches to* the IMP at that index for the receiver class&apos;s vtable (after* checking for NULL). Dispatch fixup uses these trampolines instead* of objc_msgSend.* Fragility: The vtable size and list of selectors is chosen at launch* time. No compiler-generated code depends on any particular vtable* configuration, or even the use of vtable dispatch at all.* Memory size: If a class&apos;s vtable is identical to its superclass&apos;s* (i.e. the class overrides none of the vtable selectors), then* the class points directly to its superclass&apos;s vtable. This means* selectors to be included in the vtable should be chosen so they are* (1) frequently called, but (2) not too frequently overridden. In* particular, -dealloc is a bad choice.* Forwarding: If a class doesn&apos;t implement some vtable selector, that* selector&apos;s IMP is set to objc_msgSend in that class&apos;s vtable.* +initialize: Each class keeps the default vtable (which always* redirects to objc_msgSend) until its +initialize is completed.* Otherwise, the first message to a class could be a vtable dispatch,* and the vtable trampoline doesn&apos;t include +initialize checking.* Changes: Categories, addMethod, and setImplementation all force vtable* reconstruction for the class and all of its subclasses, if the* vtable selectors are affected.**********************************************************************/ 123456789101112131415161718192021222324252627282930313233343536static const char * const defaultVtable[] = { &quot;allocWithZone:&quot;, &quot;alloc&quot;, &quot;class&quot;, &quot;self&quot;, &quot;isKindOfClass:&quot;, &quot;respondsToSelector:&quot;, &quot;isFlipped&quot;, &quot;length&quot;, &quot;objectForKey:&quot;, &quot;count&quot;, &quot;objectAtIndex:&quot;, &quot;isEqualToString:&quot;, &quot;isEqual:&quot;, &quot;retain&quot;, &quot;release&quot;, &quot;autorelease&quot;,};static const char * const defaultVtableGC[] = { &quot;allocWithZone:&quot;, &quot;alloc&quot;, &quot;class&quot;, &quot;self&quot;, &quot;isKindOfClass:&quot;, &quot;respondsToSelector:&quot;, &quot;isFlipped&quot;, &quot;length&quot;, &quot;objectForKey:&quot;, &quot;count&quot;, &quot;objectAtIndex:&quot;, &quot;isEqualToString:&quot;, &quot;isEqual:&quot;, &quot;hash&quot;, &quot;addObject:&quot;, &quot;countByEnumeratingWithState:objects:count:&quot;,}; Runtime 通过 vTable 的方式 加速调用类的常用方法。 Category但是category则完全不一样，它是在运行期决议的。就category和extension的区别来看，我们可以推导出一个明显的事实，extension可以添加实例变量，而category是无法添加实例变量的（因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的） -category和+load方法我们知道，在类和category中都可以有+load方法，那么有两个问题：1)、在类的+load方法调用的时候，我们可以调用category中声明的方法么？2)、这么些个+load方法，调用顺序是咋样的呢？ 1)、可以调用，因为附加category到类的工作会先于+load方法的执行2)、+load的执行顺序是先类，后category，而category的+load执行顺序是根据编译顺序决定的。 部分内容引用和翻译自http://www.friday.com/bbum/2009/12/18/objc_msgsend-part-1-the-road-map/http://cocoasamurai.blogspot.com/2010/01/understanding-objective-c-runtime.html","link":"/2017/02/06/%E6%B7%B1%E5%85%A5Objc-Runtime/"},{"title":"fishhook与共享库和PIC","text":"fishhook是不能hook同一个library内的符号调用的，在某个issus的解答如下。 People have had issues with socket and/or connect in the past. One problem is that fishhook can only hook external calls, which means function calls within the same library generally cannot be hooked. In this case, calls to socket and connect from within the same library (libSystem) cannot be hooked. With the simulator, the system libraries are broken out into many sub-libraries, including libsystem_networking. With many sub-libraries, this means function calls from one sub-library to another can be hooked on the simulator, but on device where there’s just a single libSystem, those same calls are within the same library and cannot be hooked. 这是由于fishhook利用 Macho-O dyld link 的 dynamically rebinding symbols实现所导致的。 这边文章就围绕这个话题来展开，解释一下la_symbol_ptr存在的原因。由于Mac OS 上使用 stubs, la_symbol_ptrs, stub_helper来实现延迟绑定的原理和Linux ELF差不多，这里就使用ELF的实现来解释。 PIC位置无关代码的引入设想一个场景，因为Linux/Mac os使用的是虚拟内存系统，这意味着共享库引用的外部符号地址在不同进程的虚拟内存中是不同的，对应到物理内存中TEXT段也不同，所以必须拷贝多份。这显然是不可以接受的，内存中存在了大量拷贝，浪费RAM资源。 如果我们共享库对外部引用是位置无关的就好了，就不会存在这个问题。 GOT 全局偏移表这时利用DATA段读写的特性，DATA段会在内存中有多份拷贝，并且DATA段和TEXT段的距离不变，在DATA段存储变化的地址，TEXT段使用指向DATA段对应位置的引用。这就解决了TEXT段共享的问题。这里我们引入了一个全局偏移量表，GOT。动态链接器会重定位GOT中的每个条目，使得它包含正确的绝对地址。 PIC函数调用 和 PLT过程链接表使用GOT这种方式，我们每次调用函数都需要额外的三条指令 1234 call L1L1: popl %ebx addl $PROCOFF, %ebx call *(%ebx) 将PC的值移到 ebx中 ebx 指向GOT中适当的条目 这样的效率未免有些低。于是引入了 延迟绑定的技术，将过程地址的绑定推迟到第一次调用该过程时。第一次调用过程的运行时开销很大，但是其后的每次调用都只会花费一条指令和一个间接地存储器引用。 过程 1call 8048464 调用相应的PLT条目 123jmp *0x8049684pushl $0x8jmp 8048444 跳转到addvec","link":"/2018/01/15/sharedlibraryandpic/"}],"tags":[],"categories":[{"name":"源码分析","slug":"源码分析","link":"/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"iOS","slug":"iOS","link":"/categories/iOS/"},{"name":"APM","slug":"APM","link":"/categories/APM/"},{"name":"研发流程","slug":"研发流程","link":"/categories/%E7%A0%94%E5%8F%91%E6%B5%81%E7%A8%8B/"},{"name":"设计架构","slug":"设计架构","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/"},{"name":"Hook","slug":"Hook","link":"/categories/Hook/"}]}