<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Category: iOS - xiejunyi Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="xiejunyi"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="xiejunyi"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="xiejunyi Blog"><meta property="og:url" content="http://yoursite.com/"><meta property="og:site_name" content="xiejunyi Blog"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://yoursite.com/img/og_image.png"><meta property="article:author" content="junyixie"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com"},"headline":"xiejunyi Blog","image":["http://yoursite.com/img/og_image.png"],"author":{"@type":"Person","name":"junyixie"},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">xiejunyi&#039;s Blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">Categories</a></li><li class="is-active"><a href="#" aria-current="page">iOS</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2017-12-24T07:29:03.000Z" title="2017-12-24T07:29:03.000Z">2017-12-24</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-11-26T15:35:08.000Z" title="2019-11-26T15:35:08.000Z">2019-11-26</time></span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a></span><span class="level-item">9 minutes read (About 1299 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/12/24/In-depthUnderStandingOfThreadSafety/">理解线程安全</a></h1><div class="content"><h2 id="线程安全问题的来源"><a href="#线程安全问题的来源" class="headerlink" title="线程安全问题的来源"></a>线程安全问题的来源</h2><blockquote>
<p>线程安全是编程中的术语，指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。</p>
</blockquote>
<p>可以看到这一切的诱因就是因为共享变量。如果我们的线程执行过程中，没有相互影响，就不会出现问题。</p>
<p>当我们的线程访问共享变量时，我们无法预测操作系统是否将为我们的线程选择一个正确的顺序。这就尴尬了！</p>
<p>对多个线程对资源的访问，我们称之为 竞争。</p>
<p>由于两个或者多个进程竞争使用不能被同时访问的资源，使得这些进程有可能因为时间上推进的先后原因而出现问题，这叫做竞争条件（Race Condition）。</p>
<p><strong>竞争条件分为两类</strong></p>
<ol>
<li>Mutex 不能被多个进程同时使用的资源</li>
<li>Synchronization 两个或多个进程彼此指针存在内在的制约关系</li>
</ol>
<ul>
<li>消费者生产者问题就是同步问题，它需要调度对共享资源的访问，是  Synchronization。</li>
<li>读者写者问题是互斥问题的一个概括。</li>
</ul>
<p><strong>消费者生产者问题</strong></p>
<blockquote>
<p>因为插入和取出项目都涉及更新共享变量，所以我们必须保证对缓冲区的访问是互斥的。但是只保证互斥访问是不够的，我们还需要调度对缓冲区的访问。如果缓冲区是满的，那么生产者必须等待直到有一个槽位变为可用。与之相似，如果缓冲区是空的，那么消费者必须等待直到有一个项目变为可用。</p>
</blockquote>
<p><strong>读者-写者问题</strong></p>
<blockquote>
<p>读者写者问题是互斥问题的一个概括。一组并发的线程要访问一个共享对象。写者必须拥有对对象独占的访问。</p>
</blockquote>
<h2 id="如何保证线程安全"><a href="#如何保证线程安全" class="headerlink" title="如何保证线程安全"></a>如何保证线程安全</h2><p>在我们需要访问共享变量的情况下，我们需要保证线程执行顺序的正确性。或者我们尽量避免使用共享变量。</p>
<p><strong>进度图</strong><br>如果我们用 纵横坐标分别表示两个进程执行的指令顺序，那么操作共享变量的指令会构成一个二维的不安全区，当两条线程的执行轨迹会同时访问不安全区时，我们就认为执行是不安全的。(局限性：无法描述多处理器并发执行)</p>
<p>我们可以选择安全的轨迹线，或者使用信号量实现互斥。</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>思考一下，锁做了什么？</p>
<p>lock是在执行多线程时用于强行限制资源访问的同步机制，即用于在并发控制中保证对互斥要求的满足.<br>对于竞争条件中的 Mutex 我们可以使用互斥锁处理。Synchronization 可以使用条件锁。<br>使用lock是可以保证线程安全的，但不能保证线程的执行顺序。</p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>原子性（Atomic），一个事务包含多个操作，这些操作要么全部执行，要么全都不执行。</p>
<p>OC 中一个很经典的面试题是， property 设置 atomic 能保证线程安全吗？<br>很多人都回答可以，这是压根没理解线程安全的体现。<br><strong>原子性不能保证线程安全</strong><br>原子性可以保证写操作一小块代码段是互斥的，但是并不能保证线程安全。</p>
<p>设置atomic之后，只是保证了 属性的赋值操作是互斥的，可惜只是该属性..<br>不能保证我们整个代码的线程安全。</p>
<p>考虑一段代码.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.a = <span class="number">0</span>;<span class="comment">//1</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.a == <span class="number">0</span>) &#123;</span><br><span class="line">    print(<span class="string">&quot;safe&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;unsafe&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 self.a = 0; 执行完毕后</p>
<p>处理机调度，切换到另一个线程执行</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.b = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>再次切换为原先的线程<br>此时，结果是<br><strong>unsafe.</strong><br>我们原先的值被其他线程篡改了。并不能保证线程安全。</p>
<p>会想一下 那经典的 进度图，原子性无法阻止多个线程访问不安全区。</p>
<p>加锁之后，就保证 代码块 不会被多个进程访问，保证了线程安全。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lock();</span><br><span class="line"><span class="keyword">self</span>.a = <span class="number">0</span>;<span class="comment">//1</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.a == <span class="number">0</span>) &#123;</span><br><span class="line">    print(<span class="string">&quot;safe&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;unsafe&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">unlock();</span><br></pre></td></tr></table></figure>


<h2 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h2><p>不可变性，这个跟线程安全关系大吗？<br>显然，我们对共享变量的访问，会导致线程安全问题是因为我们对其进行了写操作。不可变可以避免代码编写中因为疏忽导致的问题。真正处理线程安全的时候，你遇到的，会是可变的共享变量！<br>所以，这个对线程安全问题，没有用处。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2017-10-27T12:25:33.000Z" title="2017-10-27T12:25:33.000Z">2017-10-27</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-11-25T16:22:21.000Z" title="2019-11-25T16:22:21.000Z">2019-11-26</time></span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a></span><span class="level-item">32 minutes read (About 4811 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/10/27/dyld3withappstart/">链接和App启动速度优化</a></h1><div class="content"><p>最近看了链接相关的知识，结合 WWDC 2篇Session 和 iOS 启动优化 做一下总结.</p>
<h2 id="1-链接相关的基础知识"><a href="#1-链接相关的基础知识" class="headerlink" title="1 链接相关的基础知识"></a>1 链接相关的基础知识</h2><h3 id="1-1-从main-c到一个可执行目标文件"><a href="#1-1-从main-c到一个可执行目标文件" class="headerlink" title="1.1 从main.c到一个可执行目标文件"></a>1.1 从main.c到一个可执行目标文件</h3><p>我们的源程序main.c 经过C预处理器 翻译成一个ASCII中间文件 main.i,接下来 驱动程序运行C编译器，它将main.i翻译成一个ASCII汇编语言文件main.s,然后驱动程序运行汇编器，它讲main.s翻译成一个可重定位目标文件main.o,链接器程序将main.o和一些必要的系统目标文件组合起来,创建一个可执行目标文件。在运行时,main.o还可以和一些共享目标文件链接。</p>
<p><strong>预处理</strong></p>
<p>在该阶段，编译器将上述代码中的stdio.h编译进来，并且用户可以使用gcc的选项”-E”进行查看，该选项的作用是让gcc在预处理结束后停止编译过程。预处理阶段主要处理#include和#define，它把</p>
<ol>
<li>#include包含进来的.h 文件插入到#include所在的位置</li>
<li>把源程序中使用到的用#define定义的宏用实际的字符串代替</li>
</ol>
<p>hello.c</p>
<p><code>gcc -E hello.c -o hello.i</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Hello world!\n&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/JunyiXie/JunyiXie.github.io/blob/master/2017/10/27/dyld3withappstart/demo/hello.i">hello.i</a></p>
<p><strong>编译阶段</strong></p>
<p>接下来进行的是编译阶段，在这个阶段中，Gcc首先要检查代码的规范性、是否有语法错误等，以确定代码的实际要做的工作，在检查无误后，Gcc把代码翻译成汇编语言。用户可以使用”-S”选项来进行查看，该选项只进行编译而不进行汇编，生成汇编代码。</p>
<p><code>gcc -S hello.c -o hello.s</code></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">	.section</span>	__TEXT,__text,regular,pure_instructions</span><br><span class="line"><span class="meta">	.macosx_version_min</span> <span class="number">10</span>, <span class="number">12</span></span><br><span class="line"><span class="meta">	.globl</span>	_main</span><br><span class="line"><span class="meta">	.p2align</span>	<span class="number">4</span>, <span class="number">0x90</span></span><br><span class="line"><span class="symbol">_main:</span>                                  ## @main</span><br><span class="line"><span class="meta">	.cfi_startproc</span></span><br><span class="line">## BB#<span class="number">0</span>:</span><br><span class="line">	pushq	%rbp</span><br><span class="line"><span class="symbol">Lcfi0:</span></span><br><span class="line"><span class="meta">	.cfi_def_cfa_offset</span> <span class="number">16</span></span><br><span class="line"><span class="symbol">Lcfi1:</span></span><br><span class="line"><span class="meta">	.cfi_offset</span> %rbp, -<span class="number">16</span></span><br><span class="line">	<span class="keyword">movq</span>	%rsp, %rbp</span><br><span class="line"><span class="symbol">Lcfi2:</span></span><br><span class="line"><span class="meta">	.cfi_def_cfa_register</span> %rbp</span><br><span class="line">	subq	<span class="number">$16</span>, %rsp</span><br><span class="line">	leaq	L_<span class="number">.</span><span class="keyword">str</span>(%rip), %rdi</span><br><span class="line">	movl	<span class="number">$0</span>, -<span class="number">4</span>(%rbp)</span><br><span class="line">	movb	<span class="number">$0</span>, %al</span><br><span class="line">	callq	_printf</span><br><span class="line">	xorl	%ecx, %ecx</span><br><span class="line">	movl	%eax, -<span class="number">8</span>(%rbp)          ## <span class="number">4</span>-<span class="built_in">byte</span> Spill</span><br><span class="line">	movl	%ecx, %eax</span><br><span class="line">	addq	<span class="number">$16</span>, %rsp</span><br><span class="line">	popq	%rbp</span><br><span class="line">	retq</span><br><span class="line"><span class="meta">	.cfi_endproc</span></span><br><span class="line"></span><br><span class="line"><span class="meta">	.section</span>	__TEXT,__cstring,cstring_literals</span><br><span class="line"><span class="symbol">L_.str:</span>                                 ## @.str</span><br><span class="line"><span class="meta">	.asciz</span>	<span class="string">&quot;Hello world! \n&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">.subsections_via_symbols</span></span><br></pre></td></tr></table></figure>

<p><strong>汇编阶段</strong></p>
<p>汇编阶段把<code>.s</code>文件翻译成二进制机器指令文件<code>.o</code>，如命令gcc -c hello.s -o hello.o，其中-c告诉gcc进行汇编处理。这步生成的文件是二进制文件，直接用文本工具打开看到的将是乱码，我们需要反汇编工具如IDA的帮助才能读懂它</p>
<p><img src="idahello" alt="IDAhello.s"></p>
<p><strong>链接阶段</strong></p>
<p>在编译之后，就进入到了链接阶段。我们<code>hello.c</code> 中是没有定义<code>printf</code>的。我们需要把<code>hello.o</code>中的<code>printf</code>符号和它的定义相关联，重定位hello.o和相关的模块，生成一个可执行目标文件.此时我们的<code>printf</code>符号就能正常调用了.</p>
<p>链接使用<code>ld</code>工具.如果没有特别的指定,gcc会到系统默认的搜索路径<code>/usr/lib</code>下进行查找,找到合适的函数库，进行链接.</p>
<p><code>gcc hello.o -o hello.out</code> 生成可执行文件</p>
<p><code>./hello.out</code> 运行可执行文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello world!</span><br></pre></td></tr></table></figure>


<h3 id="1-2-链接的分类"><a href="#1-2-链接的分类" class="headerlink" title="1.2 链接的分类"></a>1.2 链接的分类</h3><ol>
<li>静态链接</li>
<li>动态链接</li>
</ol>
<p><strong>静态链接</strong><br>像Linux LD程序这样的静态链接器以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的，可以加载和运行的可执行目标文件为输出。</p>
<p><strong>动态链接</strong><br>共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链接.由一个叫做动态链接器的程序来执行的。</p>
<h3 id="1-3-链接的任务"><a href="#1-3-链接的任务" class="headerlink" title="1.3 链接的任务"></a>1.3 链接的任务</h3><ol>
<li><p>符号解析<br>目标文件定义和引用符号，符号解析的目的是将每个符号引用正好和一个符号定义关联起来</p>
</li>
<li><p>重定位<br>编译器和链接器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，是他们指向这个内存位置。</p>
</li>
</ol>
<p><strong>可重定位目标文件</strong></p>
<p>链接器是以可重定位目标文件作为输入的，要想理解链接的过程，首先应该了解可重定位目标文件。</p>
<table>
<thead>
<tr>
<th>setion</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>ELF头</td>
<td>系统的字的大小，字节顺序，ELF头的大小，目标文件的类型，机器类型，节头部表的文件偏移，节头部表中条目的大小和数量</td>
</tr>
<tr>
<td>.text</td>
<td>已编译程序的机器代码</td>
</tr>
<tr>
<td>.rodata</td>
<td>只读数据</td>
</tr>
<tr>
<td>.data</td>
<td>已初始化的全局和静态C变量</td>
</tr>
<tr>
<td>.bss</td>
<td>未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量</td>
</tr>
<tr>
<td>.symtab</td>
<td>一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。</td>
</tr>
<tr>
<td>.rel.text</td>
<td>重定位条目，一个.text节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这个位置。</td>
</tr>
<tr>
<td>.rel.data</td>
<td>重定位条目，被模块引用或定义的所有全局变量的重定位信息。</td>
</tr>
<tr>
<td>.debug</td>
<td>一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的C源文件。</td>
</tr>
<tr>
<td>.line</td>
<td>原始C源程序中的行号和.text节中机器指令间的映射。</td>
</tr>
<tr>
<td>.strtab</td>
<td>一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。字符串表就是以null结尾的字符串的序列。</td>
</tr>
<tr>
<td>节头目表</td>
<td>不同节的位置和大小。</td>
</tr>
</tbody></table>
<p>我们在链接中做的工作主要是：<br>符号解析<code>.text</code>,<code>.data</code>段的符号引用，重定位目标文件。</p>
<p><strong>符号和符号表</strong></p>
<p>在我们的一个可重定位目标模块中，通常会使用在当前模块和其他模块中定义的函数和全局变量，我们称之为符号。每个可重定位目标模块都有一个符号表，它包含m定义和引用符号的信息。</p>
<p><strong>ELF符号表条目</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> name;</span><br><span class="line">    <span class="keyword">char</span> type:<span class="number">4</span>,binding:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">char</span> reserved;<span class="comment">//没用</span></span><br><span class="line">    <span class="keyword">short</span> section;</span><br><span class="line">    <span class="keyword">long</span> value;</span><br><span class="line">    <span class="keyword">long</span> size;</span><br><span class="line">&#125;Elf64_Symbol;</span><br></pre></td></tr></table></figure>

<ul>
<li>Name: 字符串表中的字节偏移</li>
<li>Value:符号的地址</li>
<li>Size:目标的大小</li>
<li>Type:函数或者是数据</li>
<li>Bingding:符号是本地的还是全局的</li>
</ul>
<p>使用nm命令我们可以看到：<br><code>$ nm mymalloc.o</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                 U ___real_free</span><br><span class="line">                 U ___real_malloc</span><br><span class="line">0000000000000050 T ___wrap_free</span><br><span class="line">0000000000000000 T ___wrap_malloc</span><br><span class="line">                 U _printf</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">___wrap_free,___wrap_malloc 是已定义的符号，在text段，有相应的内存地址.</span><br><span class="line">___real_free,_printf,___real_malloc 是未定义的符号</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>符号解析</strong></p>
<p>模块引用了符号，我们需要将符号和一个确定的符号定义关联起来，这样我们的程序才可以正常的执行下去。<br>对于引用和定义在相同模块中的局部符号，符号解析是很简单明了的。<br>但是当编译器遇到不是在当前模块中定义的符号时，只能假设该符号已经在其他模块中定义，生成一个链接器符号表条目，把它交给链接器处理。</p>
<p><strong>重定位</strong></p>
<p>一但链接器完成了符号解析这一步，就把代码中的每个符号引用和正好一个符号定义关联起来（即它的一个输入目标模块中的一个），此时，链接器就知道它的输入目标模块中的代码节和数据节的确切大小。现在就可以开始重定位步骤，在这个步骤中重定位将合并输入模块，并为每个符号分配运行时地址。</p>
<p><strong>重定位由两步组成：</strong></p>
<ol>
<li>重定位节和符号定义 <ul>
<li>链接器将所有相同类型的节合并为同一类型的新的聚合节。</li>
<li>链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成后，程序中的每条指令和全局变量都有唯一的运行时内存地址了。</li>
</ul>
</li>
<li>重定位节中的符号引用<ul>
<li>链接器依赖可重定位条目的数据结构，修改代码节和数据节中对每个符号的引用，使它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目标模块中成为可重定位条目的数据结构。</li>
</ul>
</li>
</ol>
<p><strong>可重定位条目</strong></p>
<p>当汇编器生成一个目标模块时，它并不知道数据和代码最终放在内存中的什么位置。他也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。所以，无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。</p>
<p>代码的可重定位条目在<code>.rel.text</code>节中，已初始化数据的重定位条目放在<code>.rel.data</code>中.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">long</span> offset;<span class="comment">// 需要被修改引用的节偏移</span></span><br><span class="line">	<span class="keyword">long</span> type:<span class="number">32</span>,symbol:<span class="number">32</span>;<span class="comment">// type:如何修改新的引用,symbol:标示被修改引用应该指向的符号</span></span><br><span class="line">	<span class="keyword">long</span> addend;<span class="comment">// 一些类型的重定位要使用它对被修改引用的值做偏移调整</span></span><br><span class="line">&#125;Elf64_Rela;</span><br></pre></td></tr></table></figure>

<p><strong>两种基本的重定位类型</strong>：</p>
<ol>
<li>PC 相对地址引用 一个PC相对地址就是 距程序计数器(PC)的当前运行值的偏移量</li>
<li>绝对地址引用 </li>
</ol>
<h3 id="1-4-动态链接共享库"><a href="#1-4-动态链接共享库" class="headerlink" title="1.4 动态链接共享库"></a>1.4 动态链接共享库</h3><p>静态库有一些明显的缺点，比如：</p>
<ol>
<li>静态库更新后需要显式地将他们的程序与更新了的库重新链接。</li>
<li>静态库的代码会被复制到每个运行进程的文本段中。</li>
</ol>
<p><strong>共享库，动态链接</strong><br>共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链接.由一个叫做动态链接器的程序来执行的。</p>
<p><strong>共享库的共享方式</strong></p>
<ol>
<li>给定文件系统中一个库只有一个.so文件。</li>
<li>内存中，一个共享库的.text节的一个副本可以被不同的正在运行的进程共享。</li>
</ol>
<p><strong>共享库的链接时机</strong></p>
<ol>
<li>在运行时由动态链接器练链接和加载</li>
<li>在调用程序被加载和开始执行时</li>
<li>根据需要在程序调用 dlopen 库的函数时</li>
</ol>
<p><strong>PIC 借助GOT,PLT实现</strong><br>第一次调用外部函数：<br>    1. 调用外部符号，程序进入相应的PLT条目<br>    2. 把 调用的 ID压入栈后，跳转到PLT[0]<br>    3. PLT[0]通过GOT[1]间接的把动态链接器的一个参数压入栈中，然后通过GOT[2]间接的跳转进动态链接器中。动态链接器使用两个栈条目来确定 外部函数的 远行时为止，用这个地址重写GOT[4],再把控制权传给 函数。</p>
<p>后续再次调用：<br>    1. 控制传递到PLT相应条目<br>    2. 通过相应的GOT条目直接转移控制到 函数</p>
<p>PLT[0]: 特殊条目，它跳转到动态链接器中<br>GOT[0]和GOT[1]包含动态链接器在解析函数地址时会使用的信息。<br>GOT[2]是动态链接器在ld-linux.so模块中的入口点。</p>
<h3 id="1-4-加载可执行目标文件"><a href="#1-4-加载可执行目标文件" class="headerlink" title="1.4 加载可执行目标文件"></a>1.4 加载可执行目标文件</h3><p>加载器将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。</p>
<p><strong>需要注意的是：</strong></p>
<ol>
<li>由于.data段有对齐要求，所以代码段和数据段之间是有间隙的</li>
<li>链接器会使用ASLR技术,每次区域运行时区域的地址都会改变，但是相对地址不会改变。</li>
</ol>
<p><strong>Linux下的加载</strong></p>
<ol>
<li>父shell进程生成一个子进程，它是父进程的一个复制</li>
<li>子进程通过execve系统调用启动加载器</li>
<li>加载器删除子进程现有的虚拟内存段，并创建一组新的代码，数据，堆和栈段</li>
<li>将虚拟地址空间中的页映射到可执行文件的页大小的片（chunk） ，新的代码和数据段被初始化为可执行文件的内容</li>
<li>加载器跳转到_start地址，最终会调用应用程序的main 函数。</li>
</ol>
<p>注意：除了一些头部信息，在加载过程中没有任何从磁盘到内存的数据复制。直到CPU引用一个被映射的虚拟页时才会进行复制，此时，操作系统利用它的页面调度机制，自动将页面从磁盘传送到内存。</p>
<h2 id="2-Apple-App-Start-And-Dyld"><a href="#2-Apple-App-Start-And-Dyld" class="headerlink" title="2 Apple App Start And Dyld"></a>2 Apple App Start And Dyld</h2><h3 id="2-1-dyld"><a href="#2-1-dyld" class="headerlink" title="2.1 dyld"></a>2.1 dyld</h3><p>当内核完成映射进程的工作后会将名字为dyld的Mach-O文件映射到进程中的随机地址，它将PC寄存器设为dyld的地址并运行.</p>
<p><strong>Fix-ups</strong><br>由于代码签名，我们无法修改<code>__TEXT</code>段的内容,我们可以通过PIC（Position Independent Code）将<code>dyld</code>修改的引用的地址存储到<code>__DATA</code>中. 在Linux中是通过<code>GOT(Global Offset Table)</code>和<code>PLT(Procedure Linkage Table)</code>实现的.</p>
<p><strong>dyld的时间线：</strong><br>Load dylibs -&gt; Rebase -&gt; Bind -&gt; ObjC -&gt; Initalizers</p>
<p><strong>Load</strong></p>
<ul>
<li>Load dylibs:dylibs映射到内存上。</li>
</ul>
<p><strong>Rebase和Binding</strong></p>
<p>Rebase：在镜像内部调整指针的指向. Binding：将指针指向镜像外部的内容</p>
<ul>
<li>Rebase和Binding:使用PIC技术重定位<code>__DATA</code>中对应<code>__TEXT</code>中符号的指针</li>
</ul>
<p>可以通过命令行查看 rebase 和 bind 相关的资源指针：<br><code>xcrun dyldinfo -rebase -bind -lazy_bind xxx.app/xxx</code><br>诸如此类的输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__DATA  __la_symbol_ptr  0x1000341C8 0x04C3 libobjc          _objc_setAssociatedObject</span><br><span class="line">__DATA  __la_symbol_ptr  0x1000341D0 0x04E4 libobjc          _objc_setProperty_nonatomic_copy</span><br><span class="line">__DATA  __la_symbol_ptr  0x1000341D8 0x050C libobjc          _objc_storeStrong</span><br><span class="line">__DATA  __la_symbol_ptr  0x1000341E0 0x0525 libobjc          _objc_storeWeak</span><br><span class="line">__DATA  __la_symbol_ptr  0x1000341E8 0x053C libobjc          _objc_unsafeClaimAutoreleasedReturnValue</span><br><span class="line">__DATA  __la_symbol_ptr  0x1000341F0 0x056C libSystem        _pow</span><br><span class="line">__DATA  __la_symbol_ptr  0x1000341F8 0x0578 libSystem        _sin</span><br><span class="line">__DATA  __la_symbol_ptr  0x100034200 0x0584 libSystem        _sinf</span><br><span class="line">__DATA  __la_symbol_ptr  0x100034208 0x0591 libswiftCore     _swift_getObjCClassMetadata</span><br><span class="line">__DATA  __la_symbol_ptr  0x100034210 0x05B4 libswiftCore     _swift_getObjectType</span><br><span class="line">__DATA  __la_symbol_ptr  0x100034218 0x05D0 libswiftCore     _swift_unknownRelease</span><br><span class="line">__DATA  __la_symbol_ptr  0x100034220 0x05ED libswiftCore     _swift_unknownRetain</span><br></pre></td></tr></table></figure>





<p><strong>ObjC Runtime</strong></p>
<ul>
<li>ObjC  数据结构中有class DATA structure 有很多指针，例如指向 methods 和 super 的指针。这些指针的Fixed-up是通过 rebasing 和 binding.可以说我们类中method_list中的很多信息都是通过 Fix-ups 来维护的</li>
<li>因为Objc的动态性,Objc 可以通过类名来实例化对象, 这意味着 ObjC runtime 需要维护 一张哈希表，负责<code>class name</code>和<code>class</code>的映射.因此当你加载dylib的时候，dylib中定义的类都会被注册到表中。</li>
<li>更新类定义 没有C++中易碎的基类问题，因为 Fix-ups已经更新了<code>__DATA</code> 因此类中ivar相对于类实例起始地址的offset也被更新了.</li>
<li>ObjC 可以定义类别，类别可以改变 类的方法,但是 类别的定义可能和类不在同一个 image 中，在加载过程中，也需要做Fix-up,修复方法的指针. 将category中的method 加到class method_list 的前面，这样我们 在OC 运行时顺序查找方法表，先找的是 category 定义的方法.</li>
<li>ObjC 的 selector 是唯一的</li>
</ul>
<p><strong>Initializers</strong></p>
<ul>
<li>C++ 为静态创建的对象生成初始化器</li>
<li>Objc <code>+load</code> 方法，已经废弃,建议使用 <code>+initialize</code></li>
</ul>
<h3 id="2-2-启动调用顺序"><a href="#2-2-启动调用顺序" class="headerlink" title="2.2 启动调用顺序"></a>2.2 启动调用顺序</h3><p>initialize -&gt; dyld -&gt; main() -&gt; UIApplicationMain()</p>
<h2 id="3-dyld3"><a href="#3-dyld3" class="headerlink" title="3 dyld3"></a>3 dyld3</h2><p>在WWDC 2017 上，苹果宣布已经使用 dyld3 来作为系统app的动态链接器</p>
<p><strong>dyld3可以分成三个部分</strong></p>
<ol>
<li>一个进程外的 mach-o 分析器和编译器 处理可能影响启动速度的searchpath @rpaths 和 环境变量，解析mach-o二进制文件，完成符号解析的工作.</li>
<li>一个进程内的引擎 执行启动收尾处理 验证启动收尾，映射动态链接库</li>
<li>一个启动收尾缓存服务  系统程序收尾被直接加入到共享缓存，使用这个工具在系统中运行和分析每个mach-o文件，将它们放入共享缓存，使它映射到缓存中，所有dylib都使用它来启动. 对于第三方程序，在程序安装或系统更新时，生成启动收尾处理（因为系统库那时已经发生更改）</li>
</ol>
<p><strong>为什么启动收尾可以提高启动速度?</strong><br>通过启动收尾，缓存了 符号相对于库中的偏移位置， 这就避免了以后启动程序进程再次进行符号链接的时间消耗。直接从磁盘读取缓存的启动收尾，验证是否正确即可.</p>
<h2 id="4-优化方案"><a href="#4-优化方案" class="headerlink" title="4 优化方案"></a>4 优化方案</h2><p>App 的启动时间: dylib和App可执行文件的加载时间 + - (BOOL)Application:(UIApplication *)Application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions执行时间.</p>
<p><strong>加载images</strong></p>
<ul>
<li>使用更少的非系统dylibs 合并多个dylibs 使用静态库</li>
</ul>
<p><strong>Rebase/Binding</strong></p>
<ul>
<li>减少Objc 类数量，减少selector数量，减少C++虚函数数量，使用Swift struct</li>
</ul>
<p><strong>Initializer</strong><br>Explict Initializer</p>
<ul>
<li>使用 <code>+initialize</code> 而不是 <code>+load</code></li>
<li>不要使用 <strong>atribute</strong>((constructor)) 将方法显式标记为初始化器,而是让初始化方法调用时才执行.可以使用 <code>dispatch_once()</code>,<code>pthread_once()</code>,<code>std::once()</code></li>
</ul>
<p>Implict Initializer</p>
<ul>
<li>在调用的地方使用初始化器</li>
<li>只用简单值类型赋值（POD:Plain Old Data），这样静态链接器会预先计算 __DATA 中的数据，无需再进行 fix-up 工作</li>
<li>使用编译器 warning 标志 -Wglobal-constructors 来发现隐式初始化代码。</li>
<li>苹果还建议更多使用 Swift。Swift 在设计上能避免很多 C、C++ 和 OC 的陷阱；Swift 没有初始化过程；Swift 也不允许不对齐的结构体。这些都对启动时间的优化有一定帮助</li>
</ul>
<h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5 参考"></a>5 参考</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2017/413/">2017 WWDC Session 413</a></p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2016/406/">2016 WWDC Session 406</a></p>
</blockquote>
<blockquote>
<p>《深入理解计算机系统》</p>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2017-09-26T06:47:47.000Z" title="2017-09-26T06:47:47.000Z">2017-09-26</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-11-26T15:32:58.000Z" title="2019-11-26T15:32:58.000Z">2019-11-26</time></span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a></span><span class="level-item">18 minutes read (About 2746 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/09/26/%E7%90%86%E8%A7%A3HTTPS/">理解HTTPS</a></h1><div class="content"><p>Monday, 25 September 2017<br>7:36 PM</p>
<blockquote>
<p>文章围绕的问题：</p>
</blockquote>
<ol>
<li>如何解决窃听风险？</li>
<li>如何解决篡改风险？</li>
<li>如何解决冒充风险？</li>
<li>什么是数字证书？</li>
<li>CA证书的验证</li>
<li>什么是签名？</li>
</ol>
<h2 id="HTTPS-简介"><a href="#HTTPS-简介" class="headerlink" title="HTTPS 简介"></a>HTTPS 简介</h2><p>超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。这个协议由网景公司（Netscape）在1994年首次提出，随后扩展到互联网上。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/超文本传输安全协议">wikipedia https</a><br>简单的图示<br><img src="https://github.com/JunyiXie/JunyiXie.github.io/raw/master/2017/09/26/%E7%90%86%E8%A7%A3HTTPS/https.png" alt="HTTPS"></p>
</blockquote>
<p><strong>HTTP+加密+认证+完整性保护 = HTTPS.</strong><br> 通常，http直接和tcp通信。当使用ssl/tls时，则演变成先和ssl/tls通信，再由ssl/tls和tcp通讯，因此，https其实就是身披ssl/tls保护外衣的http.</p>
<p> <strong>HTTPS 四次握手的过程</strong></p>
<ol>
<li><p>客户端发出请求<br>在这一步，客户端主要向服务器提供以下信息。<br>（1） 支持的协议版本，比如TLS 1.0版。<br>（2） 一个客户端生成的随机数，稍后用于生成”对话密钥”。<br>（3） 支持的加密方法，比如RSA公钥加密。<br>（4） 支持的压缩方法。</p>
</li>
<li><p>服务器回应<br>服务器收到客户端请求后，向客户端发出回应，这叫severHello.包含如下内容<br>（1）确认使用的加密通信协议版本<br>（2）一个服务器生成的随机数<br>（3）确认使用的加密方法，比如RSA<br>（4）服务器证书</p>
</li>
<li><p>客户端回应<br>客户端验证证书，如果证书没有问题，客户端就会从证书中取出服务器的public-key。向服务器发送下面三项消息。<br>（1）一个随机数。该随机数用服务器public-key加密，防止被窃听<br>（2）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。<br>（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项也是前面发送的所有内容的hash值，用来供服务器校检。</p>
</li>
<li><p>服务器的最后回应<br>服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的“会话密钥”。然后向客户端最后发送下面消息。<br>（1）编码改变通知。表示随后的信息都将用双方商定的加密方法和密钥发送。<br>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash, 用来供服务器校检。</p>
</li>
</ol>
<h2 id="HTTPS-解决了-HTTP-在安全性方面的哪些问题"><a href="#HTTPS-解决了-HTTP-在安全性方面的哪些问题" class="headerlink" title="HTTPS 解决了 HTTP 在安全性方面的哪些问题"></a>HTTPS 解决了 HTTP 在安全性方面的哪些问题</h2><p><strong>HTTP 通信的风险</strong></p>
<ol>
<li>窃听风险：第三方可以获知通信内容</li>
<li>篡改风险：第三方可以修改通信内容</li>
<li>冒充风险：第三方可以冒充他人身份参与通信</li>
</ol>
<p><strong>如何解决这些风险? SSL/TSL 协议</strong></p>
<ol>
<li>加密传播，第三方无法窃听</li>
<li>具有校验机制，一旦被篡改，通信双方会立刻发现</li>
</ol>
<p><strong>SSL/TSL协议有两个问题</strong></p>
<ol>
<li><p>如何保证public-key不被篡改？</p>
<ul>
<li>可信任的第三方认证证书，证书中有public-key</li>
<li>那如何保证证书的可信任性？</li>
</ul>
</li>
<li><p>publick-key计算量太大，如何减少耗用的时间？</p>
<ul>
<li>解决方法：每一次对话（session），客户端和服务器端都生成一个”对话密钥”（session key），用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。</li>
</ul>
</li>
</ol>
<p><strong>上面对HTTPS的介绍 看不懂没关系，下面来了解一些相关的概念</strong></p>
<h2 id="SSL，数字证书，签名，RSA"><a href="#SSL，数字证书，签名，RSA" class="headerlink" title="SSL，数字证书，签名，RSA"></a>SSL，数字证书，签名，RSA</h2><p><strong>SSL/TLS协议的基本过程</strong><br> （1）客户端向服务器索要并验证public-key<br> （2） 双方协商生成“对话密钥”<br> （3）双方采用“对话密钥”进行加密通信</p>
<p> <strong>如何验证数字证书？</strong></p>
<ol>
<li>读取证书发布机构</li>
<li>在操作系统中受信任的发布机构中查找</li>
<li>从证书中取出publick-key对证书的指纹和指纹算法用这个public-key进行解密，然后用这个指纹算法计算证书指纹，然后与证书中的指纹进行对比。</li>
<li>如果一致，说明证书是CA发布的</li>
</ol>
<p><strong>证书如何证明服务器身份</strong><br> 在使用证书之前，通信中，可能出现对方的身份无法确定。<br> 使用证书之后，CA是可信的，通过对证书进行校检，确认证书的合法性，证书合法后，则</p>
<ol>
<li>客户端向服务器发送随机字符串</li>
<li>服务器加密</li>
<li>客户端用证书中的public-key解密，结果一致，则可以证明服务器是证书上的服务器。</li>
</ol>
<p> <strong>RSA</strong><br> RSA是一种公钥密码体制<br> RSA密码体制是一种公钥密码体制，公钥公开，私钥保密，它的加密解密算法是公开的。 由公钥加密的内容可以并且只能由私钥进行解密，并且由私钥加密的内容可以并且只能由公钥进行解密。也就是说，RSA的这一对公钥、私钥都可以用来加密和解密，并且一方加密的内容可以由并且只能由对方进行解密。</p>
<p> 重点：自己保留private-key, 只有private-key加密的内容，才能用public-key解密，这是保证别人无法伪造private-key持有者的重要保障。<strong>也就是说，是无法伪造RSA加密后内容的。</strong></p>
<p> <strong>RSA加密算法在通信过程中起到的作用主要有两个：</strong></p>
<ol>
<li><p>因为私钥只有“服务器”拥有，因此“客户”可以通过判断对方是否有私钥来判断对方是否是“服务器”</p>
</li>
<li><p>客户端通过RSA的掩护，安全的和服务器商量好一个对称加密算法和密钥来保证后面通信过程内容的安全。</p>
<p><strong>签名</strong><br>签名就是在信息的后面再加上一段内容，可以证明信息没有修改过。<br>一般对信息进行hash计算得到一个hash值。在把信息发送时，把签名和签名算法一起发送出去。接收方在接受信息后，用签名算法计算hash值，与签名进行比较。</p>
</li>
</ol>
<ul>
<li><p>报文Hash生成摘要信息Digest,用private-key 加密生成签名</p>
</li>
<li><p>客户端用public-key揭秘签名</p>
</li>
<li><p>客户端对报文做同样的hash处理，和上一步得到的结果进行对比</p>
<p>为了防止他人修改信息内容时，也对hash值进行修改，hash值和算法都会加密，以保证这个hash值不被修改。</p>
</li>
<li><p>加密算法，加密算法后，对方无法根据内容得到相应的hash值，这样就无法伪造内容。</p>
</li>
<li><p>加密hash值，加密后，则可以给接收方一个用来验证的值。</p>
<p>使用rsa加密算法，可以保证签名和hash算法不被他人更改。</p>
</li>
</ul>
<p> <strong>数字证书</strong><br> 数字证书简称CA，它由权威机构给某网站颁发的一种认可凭证，这个凭证是被大家（浏览器）所认可的<br> <strong>为什么需要数字证书？</strong><br> 避免他人冒充服务器</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/中间人攻击">中间人攻击</a></p>
</blockquote>
<p> 数字证书一般由证书认证机构颁发，证书里面包含了真实服务器的public-key和网站的其他信息，数字证书机构用自己的private-key加密后发给浏览器，浏览器使用数字证书机构的publick-key揭秘后得到真实服务器的publick-key。</p>
<p><strong>为什么一定要用三个随机数，来生成”会话密钥”</strong></p>
<blockquote>
<p>至于为什么一定要用三个随机数，来生成”会话密钥”，dog250解释得很好：<br>“不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。<br>对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。<br>pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。”</p>
</blockquote>
<h3 id="详细过程图"><a href="#详细过程图" class="headerlink" title="详细过程图"></a>详细过程图</h3><p> <img src="https://github.com/JunyiXie/JunyiXie.github.io/raw/master/2017/09/26/%E7%90%86%E8%A7%A3HTTPS/https_detail.png" alt="https_detail"><br> 注  ：</p>
<ol>
<li><p>双方都进行hash验证</p>
<ul>
<li>服务端知道hash是否正确后，需要让客户端知道自己是否验证正确，客户端也需要验证一次hash，避免服务器造假。</li>
</ul>
</li>
<li><p>D是最后HTTP使用的密钥</p>
<blockquote>
<p>参考文章<br>•    SSL/TLS协议运行机制的概述 <a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a><br>•    图解SSL <a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html">http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html</a><br>•    数字证书 <a target="_blank" rel="noopener" href="https://blog.cnbluebox.com/blog/2014/03/24/shu-zi-zheng-shu/">https://blog.cnbluebox.com/blog/2014/03/24/shu-zi-zheng-shu/</a><br>•    数字证书原理 <a target="_blank" rel="noopener" href="http://blog.sae.sina.com.cn/archives/4939">http://blog.sae.sina.com.cn/archives/4939</a><br>•    图解HTTPS <a target="_blank" rel="noopener" href="http://www.jianshu.com/p/51cc23843756">http://www.jianshu.com/p/51cc23843756</a></p>
</blockquote>
</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2017-05-01T06:09:25.000Z" title="2017-05-01T06:09:25.000Z">2017-05-01</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-11-25T16:24:14.000Z" title="2019-11-25T16:24:14.000Z">2019-11-26</time></span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a></span><span class="level-item">18 minutes read (About 2718 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/05/01/Objective-C-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%92%8C%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/">Objective-C 深入理解中的消息机制和方法调用</a></h1><div class="content"><h2 id="objc-msgSend-的背后"><a href="#objc-msgSend-的背后" class="headerlink" title="objc_msgSend 的背后"></a>objc_msgSend 的背后</h2><p>在Objective-C中，消息在Runtime的时候才绑定到方法实现。编译器把</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[receiver message]</span><br></pre></td></tr></table></figure>
<p>转换成</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(receiver, selector)</span><br></pre></td></tr></table></figure>

<p>这个messaging function 做了动态绑定所有的工作</p>
<ul>
<li>首先找到selector 指定的 方法实现.相同的方法可以在不同的类中有不同的实现。被找到的方法实现取决于消息的接受者(类)。</li>
<li>然后调用方法实现，并传递方法所需的参数.</li>
<li>最后，将所调用方法的返回值 作为自身的返回值.</li>
</ul>
<p>消息传递的关键在于 编译器为每个class和object建立的 结构体.每个类的结构体包含着两个必备的元素:</p>
<ul>
<li>一个指向父类的指针</li>
<li>一个 class dispatch table.表中包含了method selectors 和 特定class相应方法实现的地址</li>
</ul>
<p>实例中有一个isa指针，isa指向实例的class structure.</p>
<p>如图所示 通过isa指针，描述了类的继承关系<br><img src="messaging1.gif" alt="message1"></p>
<h3 id="消息传递的过程"><a href="#消息传递的过程" class="headerlink" title="消息传递的过程"></a>消息传递的过程</h3><ol>
<li>当一个消息被发送给一个对象，messaging function<strong>跟随对象的isa指针</strong>找到他的class structure,在dispatch table中寻找method selector.</li>
<li>如果没有找到selector,objc_msgsend 跟随该<strong>类实例的isa</strong>找到父类，尝试在父类的dispatch table中寻找selector</li>
<li>重复步骤2,直到isa指向NSObject Class为止。</li>
</ol>
<p><strong>一但objc_msgsend定位到了selector,该函数,调用dispatch table中的方法，并将其传递给接收对象的数据结构。</strong></p>
<p>这是Runtime中选择所需方法实现的实现方式.在面向对象编程的术语中，这些methods和messages 是动态绑定的。</p>
<p><strong>为了加速消息传递的过程，runtime 系统缓存了使用过的 selectors 和 方法实现的地址。</strong></p>
<p>每个class都有特定的cache.并且它可以包含 继承的selector和 定义在类中的方法。</p>
<p>在OC编程中，你向对象发送消息是因为该对象实现了相应的方法，并且你希望调用该方法。<br>在搜索dispatch tables之前，消息传递机制通常会<strong>首先检查接受方法的对象的cache</strong>。如果方法的selector在缓存中，调用method所需的时间仅仅比function call 稍微慢一点点<br>一但程序预热cache之后，大多数消息调用都能从cache中找到。为了存放更多的方法，Cache会动态的增长。 </p>
<h2 id="深入理解消息转发过程"><a href="#深入理解消息转发过程" class="headerlink" title="深入理解消息转发过程"></a>深入理解消息转发过程</h2><p>以下是文档的中文翻译：</p>
<h3 id="resolveInstanceMethod"><a href="#resolveInstanceMethod" class="headerlink" title="resolveInstanceMethod:"></a>resolveInstanceMethod:</h3><p>resolveInstanceMethod: 和 resolveClassMethod: 方法允许你为一个给定的 selector 动态的提供方法的实现。<br>OC 方法在底层的C函数的实现中需要至少两个参数：self 和 _cmd。使用 class_addMethod 函数，你能够添加一个函数到一个类来作为方法使用。</p>
<h3 id="forwardingTargetForSelector"><a href="#forwardingTargetForSelector" class="headerlink" title="forwardingTargetForSelector:"></a>forwardingTargetForSelector:</h3><p>如果一个对象实现了这个方法，并且返回了一个非空（以及非 self）的结果，返回的对象会用来作为一个新的接收对象，随后消息会被重新派发给这个新对象。（很明显，如果你在这个方法中返回了self，那这段代码将会坠入无限循环。）<br>如果你这段方法在一个非 root 的类中实现，并且如果这个类根据给定的selector什么都不作返回，那么你应该返回一个 执行父类的实现后返回的结果。<br>这个方法为对象在开销大的多的 forwardInvocation:  方法接管之前提供了一次转发未知消息的机会。这对你只是想简单的重新定位消息到另一个对象是非常有用的，并且相对普通转发更快一个数量级。如果转发的目的是捕捉到NSInvocation，或者操作参数，亦或者是在转发过程中返回一个值，那这个方法就没有用了。</p>
<h3 id="forwardInvocation"><a href="#forwardInvocation" class="headerlink" title="forwardInvocation:"></a>forwardInvocation:</h3><p>当对象接受到一条自己不能响应的消息时，运行时会给接收者一次机会来把消息委托给另一个接收者。他委托的消息是通过NSInvocation对象来表示的，然后将这个对象作为 forwardInvocation: 的参数。接收者收到 forwardInvocation: 这条消息后可以选择转发这个NSInvacation对象给其他接收对象。（如果这个接收对象也不能响应这条消息，他也会给一次转发这条消息的机会。）<br>因此 forwardInvocation: 允许在两个对象之间通过某个消息来建立关系。转发给其他对象的这种行为，从某种意义上来说，他“继承”了他所转发给的对象的一些特征。注意为了响应这个你无法识别的方法，你除了 forwardInvocation: 方法外，还必须重写 methodSignatureForSelector:  方法。在转发消息的机制中会从 methodSignatureForSelector: 方法来创建NSInvocation对象。所以你必须为给定的 selector 提供一个合适的 method signature ，可以通过预先设置一个或者向另一个对象请求一个。</p>
<h3 id="forwardInvocation，forwardingTargetForSelector-的差异"><a href="#forwardInvocation，forwardingTargetForSelector-的差异" class="headerlink" title="forwardInvocation，forwardingTargetForSelector  的差异"></a>forwardInvocation，forwardingTargetForSelector  的差异</h3><p><strong>相较于 forwardingTargetForSelector 只能拿到 selector 来说， forwardInvocation 借助于invocation 可以获得参数和返回值等信息。</strong></p>
<h4 id="NSInvocation文档翻译"><a href="#NSInvocation文档翻译" class="headerlink" title="NSInvocation文档翻译"></a>NSInvocation文档翻译</h4><p>NSInvocation:NSInvocation对象用于在对象之间和应用程序之间存储和转发消息，主要由NSTimer对象和分布式对象系统来完成。 NSInvocation对象包含Objective-C消息的所有元素：目标，选择器，参数和返回值。每个元素都可以直接设置，并在调度NSInvocation对象时自动设置返回值。</p>
<p>一个NSInvocation对象可以重复地分派给不同的目标;它的参数可以针对不同结果的调度时进行修改;甚至它的选择器可以变为另一个具有相同的方法签名（参数和返回类型）。这种灵活性使得NSInvocation对重复发送具有许多参数和变体的消息有用;而不是为每条消息重新输入一个稍微不同的表达式，每次在将其分派到新目标之前，都需要根据需要修改NSInvocation对象。</p>
<p>NSInvocation不支持具有可变数量的参数或联合参数的方法的调用。您应该使用invocationWithMethodSignature：类方法来创建NSInvocation对象;你不应该使用alloc和init来创建这些对象。</p>
<p>此类不保留默认包含的调用的参数。如果这些对象可能在创建NSInvocation实例和使用它的时间之间消失，则应该自己保留对象或调用retainArguments方法以使调用对象保留它们本身。</p>
<p>总结一下：可以拿到参数和返回值,可以改selecter(方法签名相同),可以把消息分发给多个对象。相较于 forwardingTargetForSelector 只能拿到selector 灵活了很多。</p>
<h4 id="forwardingTargetForSelector-相较于-forwardInvocation-的优点"><a href="#forwardingTargetForSelector-相较于-forwardInvocation-的优点" class="headerlink" title="forwardingTargetForSelector 相较于 forwardInvocation 的优点"></a>forwardingTargetForSelector 相较于 forwardInvocation 的优点</h4><p>This method gives an object a chance to redirect an unknown message sent to it before the much more expensive forwardInvocation: machinery takes over. This is useful when you simply want to redirect messages to another object and can be an order of magnitude faster than regular forwarding. It is not useful where the goal of the forwarding is to capture the NSInvocation, or manipulate the arguments or return value during the forwarding.</p>
<p>简而言之，只做简单的消息转发时， 它比forwardInvocation 对性能的消耗要少。</p>
<p><strong>我们需要注意</strong></p>
<ol>
<li>forwardInvocation，forwardingTargetForSelector 都会给指定的对象 再走一次 objc_msgsend流程。</li>
<li>forwardInvocation 相较于 forwardingTargetForSelector  消耗更大</li>
<li>forwardInvocation 可以拿到参数和返回值,可以改selecter(方法签名相同),可以把消息分发给多个对象。相较于 forwardingTargetForSelector 只能拿到selector 灵活了很多。</li>
</ol>
<h2 id="来看看C-中的方法调度机制"><a href="#来看看C-中的方法调度机制" class="headerlink" title="来看看C++中的方法调度机制"></a>来看看C++中的方法调度机制</h2><p><strong>直接调度</strong><br>直接调度是最快的一种。它不仅有最少的汇编指令，而且编译器也可以做各种智能优化，比如内联代码，许多其它本文不会涉及的东西。直接调度也常常被称为静态调度。</p>
<p><strong>表调度</strong><br>表调度是编译型语言中最常见的动态行为的实现方式。表调度在类声明中为每一个方法用一个函数指针的数组。大多数语言称之为“虚表”。每一个子类都有它自己的一张父类表的拷贝，表中每个被覆盖的方法都是不同于父类的函数指针。当子类添加新的方法的时候，这些方法就被追加到这个数组的后面。然后在运行时就会访问这个表来决定执行哪个方法。</p>
<h3 id="V-Table-和-dispatch-table-的不同之处"><a href="#V-Table-和-dispatch-table-的不同之处" class="headerlink" title="V-Table 和 dispatch table 的不同之处"></a>V-Table 和 dispatch table 的不同之处</h3><p><strong>这里的虚表 与 Objective-C 中的dispatch table 完全是两个概念.</strong><br>虚表包含了当前类和父类的函数指针。<br>dispatch table 仅仅包含了当前类的selector和MethodIMP的地址。 </p>
<h3 id="其实-Objective-C-中也有-V-Table"><a href="#其实-Objective-C-中也有-V-Table" class="headerlink" title="其实 Objective-C 中也有 V-Table"></a>其实 Objective-C 中也有 V-Table</h3><p>其实OC中也有V-Table 它用来存放 最常调用的方法来加速程序的性能。这些方法直接通过V-table 调用。（执行msg_send()会花费更多的时间)<br>每一个对象都有一个vtable point 指向 一些方法的IMP.<br><a target="_blank" rel="noopener" href="https://opensource.apple.com/source/objc4/objc4-437/runtime/objc-runtime-new.m">objc-runtime-new.m</a></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* vtable dispatch</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* Every class gets a vtable pointer. The vtable is an array of IMPs.</span></span><br><span class="line"><span class="comment">* The selectors represented in the vtable are the same for all classes</span></span><br><span class="line"><span class="comment">*   (i.e. no class has a bigger or smaller vtable).</span></span><br><span class="line"><span class="comment">* Each vtable index has an associated trampoline which dispatches to </span></span><br><span class="line"><span class="comment">*   the IMP at that index for the receiver class&#x27;s vtable (after </span></span><br><span class="line"><span class="comment">*   checking for NULL). Dispatch fixup uses these trampolines instead </span></span><br><span class="line"><span class="comment">*   of objc_msgSend.</span></span><br><span class="line"><span class="comment">* Fragility: The vtable size and list of selectors is chosen at launch </span></span><br><span class="line"><span class="comment">*   time. No compiler-generated code depends on any particular vtable </span></span><br><span class="line"><span class="comment">*   configuration, or even the use of vtable dispatch at all.</span></span><br><span class="line"><span class="comment">* Memory size: If a class&#x27;s vtable is identical to its superclass&#x27;s </span></span><br><span class="line"><span class="comment">*   (i.e. the class overrides none of the vtable selectors), then </span></span><br><span class="line"><span class="comment">*   the class points directly to its superclass&#x27;s vtable. This means </span></span><br><span class="line"><span class="comment">*   selectors to be included in the vtable should be chosen so they are </span></span><br><span class="line"><span class="comment">*   (1) frequently called, but (2) not too frequently overridden. In </span></span><br><span class="line"><span class="comment">*   particular, -dealloc is a bad choice.</span></span><br><span class="line"><span class="comment">* Forwarding: If a class doesn&#x27;t implement some vtable selector, that </span></span><br><span class="line"><span class="comment">*   selector&#x27;s IMP is set to objc_msgSend in that class&#x27;s vtable.</span></span><br><span class="line"><span class="comment">* +initialize: Each class keeps the default vtable (which always </span></span><br><span class="line"><span class="comment">*   redirects to objc_msgSend) until its +initialize is completed.</span></span><br><span class="line"><span class="comment">*   Otherwise, the first message to a class could be a vtable dispatch, </span></span><br><span class="line"><span class="comment">*   and the vtable trampoline doesn&#x27;t include +initialize checking.</span></span><br><span class="line"><span class="comment">* Changes: Categories, addMethod, and setImplementation all force vtable </span></span><br><span class="line"><span class="comment">*   reconstruction for the class and all of its subclasses, if the </span></span><br><span class="line"><span class="comment">*   vtable selectors are affected.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> defaultVtable[] = &#123;</span><br><span class="line">    <span class="string">&quot;allocWithZone:&quot;</span>, </span><br><span class="line">    <span class="string">&quot;alloc&quot;</span>, </span><br><span class="line">    <span class="string">&quot;class&quot;</span>, </span><br><span class="line">    <span class="string">&quot;self&quot;</span>, </span><br><span class="line">    <span class="string">&quot;isKindOfClass:&quot;</span>, </span><br><span class="line">    <span class="string">&quot;respondsToSelector:&quot;</span>, </span><br><span class="line">    <span class="string">&quot;isFlipped&quot;</span>, </span><br><span class="line">    <span class="string">&quot;length&quot;</span>, </span><br><span class="line">    <span class="string">&quot;objectForKey:&quot;</span>, </span><br><span class="line">    <span class="string">&quot;count&quot;</span>, </span><br><span class="line">    <span class="string">&quot;objectAtIndex:&quot;</span>, </span><br><span class="line">    <span class="string">&quot;isEqualToString:&quot;</span>, </span><br><span class="line">    <span class="string">&quot;isEqual:&quot;</span>, </span><br><span class="line">    <span class="string">&quot;retain&quot;</span>, </span><br><span class="line">    <span class="string">&quot;release&quot;</span>, </span><br><span class="line">    <span class="string">&quot;autorelease&quot;</span>, </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> defaultVtableGC[] = &#123;</span><br><span class="line">    <span class="string">&quot;allocWithZone:&quot;</span>, </span><br><span class="line">    <span class="string">&quot;alloc&quot;</span>, </span><br><span class="line">    <span class="string">&quot;class&quot;</span>, </span><br><span class="line">    <span class="string">&quot;self&quot;</span>, </span><br><span class="line">    <span class="string">&quot;isKindOfClass:&quot;</span>, </span><br><span class="line">    <span class="string">&quot;respondsToSelector:&quot;</span>, </span><br><span class="line">    <span class="string">&quot;isFlipped&quot;</span>, </span><br><span class="line">    <span class="string">&quot;length&quot;</span>, </span><br><span class="line">    <span class="string">&quot;objectForKey:&quot;</span>, </span><br><span class="line">    <span class="string">&quot;count&quot;</span>, </span><br><span class="line">    <span class="string">&quot;objectAtIndex:&quot;</span>, </span><br><span class="line">    <span class="string">&quot;isEqualToString:&quot;</span>, </span><br><span class="line">    <span class="string">&quot;isEqual:&quot;</span>, </span><br><span class="line">    <span class="string">&quot;hash&quot;</span>, </span><br><span class="line">    <span class="string">&quot;addObject:&quot;</span>, </span><br><span class="line">    <span class="string">&quot;countByEnumeratingWithState:objects:count:&quot;</span>, </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2017-04-20T04:44:52.000Z" title="2017-04-20T04:44:52.000Z">2017-04-20</time></span><span class="level-item">Updated&nbsp;<time dateTime="2018-05-26T11:27:59.000Z" title="2018-05-26T11:27:59.000Z">2018-05-26</time></span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a></span><span class="level-item">5 minutes read (About 707 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/04/20/Cocoa-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3KVO/">Cocoa 深入理解KVO</a></h1><div class="content"><p>深入理解KVO<br>……</p></div><a class="article-more button is-small is-size-7" href="/2017/04/20/Cocoa-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3KVO/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2017-02-06T07:03:59.000Z" title="2017-02-06T07:03:59.000Z">2017-02-06</time></span><span class="level-item">Updated&nbsp;<time dateTime="2018-05-26T11:27:55.000Z" title="2018-05-26T11:27:55.000Z">2018-05-26</time></span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a></span><span class="level-item">24 minutes read (About 3605 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/02/06/%E6%B7%B1%E5%85%A5Objc-Runtime/">理解 Objc Runtime</a></h1><div class="content"><h2 id="Runtime-是什么"><a href="#Runtime-是什么" class="headerlink" title="Runtime 是什么"></a>Runtime 是什么</h2><p>一个用C和汇编语言写的Runtime库,来动态 创建类和对象、进行消息传递和转发。<br>（在运行时执行部分编译后的代码）</p>
<h2 id="Objective-C"><a href="#Objective-C" class="headerlink" title="Objective-C"></a>Objective-C</h2><p>Objective-C 扩展了 C 语言，并加入了面向对象特性和 Smalltalk 式的消息传递机制。而这个扩展的核心是一个用 C 和 编译语言 写的 Runtime 库。它是 Objective-C 面向对象和动态机制的基石。</p>
<p>Objective-C 是一个动态语言，这意味着它不仅需要一个编译器，也需要一个运行时系统来动态 创建类和对象、进行消息传递和转发。理解 Objective-C 的 Runtime 机制可以帮我们更好的了解这个语言，适当的时候还能对语言进行扩展，从系统层面解决项目中的一些设计或技术问题。 Runtime的核心是 - 消息传递 （Messaging）。(动态调度)</p>
<h2 id="Runtime-原理的概述"><a href="#Runtime-原理的概述" class="headerlink" title="Runtime 原理的概述"></a>Runtime 原理的概述</h2><p>Objective-C的是一个运行时面向语言，这意味着当它可能在运行时决定如何实现而不是在编译期。 这给你很大的灵活性，你可以根据需要将消息重定向到适当的对象，或者甚至有意交换方法实现等。如果我们将它与C语言进行对比。</p>
<p>在很多语言，比如 C ，调用一个方法其实就是跳到内存中的某一点并开始执行一段代码。没有任何动态的特性，因为这在编译时就决定好了。而在 Objective-C 中，[object foo] 语法并不会立即执行 foo 这个方法的代码。它是在运行时给 object 发送一条叫 foo 的消息。这个消息，也许会由 object 来处理，也许会被转发给另一个对象，或者不予理睬假装没收到这个消息。多条不同的消息也可以对应同一个方法实现。这些都是在程序运行的时候决定的。</p>
<h3 id="什么是Objective-C运行时？"><a href="#什么是Objective-C运行时？" class="headerlink" title="什么是Objective-C运行时？"></a>什么是Objective-C运行时？</h3><p>Objective-C运行时是一个运行库，它是一个主要在C＆Assembler中编写的库，它将面向对象的功能添加到C中以创建Objective-C。 这意味着它加载类信息，所有方法调度，方法转发等。Objective-C运行时本质上创建所有支持结构，使面向对象的编程与Objective-C可能。</p>
<h3 id="Objective-C-类和对象"><a href="#Objective-C-类和对象" class="headerlink" title="Objective-C 类和对象"></a>Objective-C 类和对象</h3><p>Objective-c类本身也是对象，而运行时通过创建Meta类处理这一点。 当你发送一个消息，如[NSObject alloc]，你实际上是发送一个消息到类对象，该类对象需要是一个MetaClass的实例，它本身是根元类的实例。 而如果你说NSObject的子类，你的类指向NSObject作为它的超类。 然而，所有元类都指向根元类作为它们的超类。 所有的元类都只有它们响应的消息的方法列表的类方法。 所以当你发送消息到类对象，如[NSObject alloc]，然后objc_msgSend（）实际上通过元类查看它的响应，然后如果它找到一个方法，操作类对象。</p>
<h4 id="为什么Objective-C的对象都要继承-NSObject"><a href="#为什么Objective-C的对象都要继承-NSObject" class="headerlink" title="为什么Objective-C的对象都要继承 NSObject"></a>为什么Objective-C的对象都要继承 NSObject</h4><p>最初当你开始Cocoa开发，你可能没注意到我们的类一直都恪守着继承自NSObject的写法，有一件事你甚至没有意识到，发生在你身上的是将对象设置为使用Objective-C运行时。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyObject *object &#x3D; [[MyObject alloc] init];</span><br></pre></td></tr></table></figure>

<p>执行的第一个消息是+ alloc。 如果你看看文档，它说“新实例的isa实例变量被初始化为描述类的数据结构;所有其他实例变量的内存设置为0” 所以通过继承NSObject类，我们不仅继承了一些伟大的属性，而且我们继承了在内存中容易地分配和创建我们的对象的能力.</p>
<h3 id="那么什么是类缓存？-（objc-cache-cache）"><a href="#那么什么是类缓存？-（objc-cache-cache）" class="headerlink" title="那么什么是类缓存？ （objc_cache * cache）"></a>那么什么是类缓存？ （objc_cache * cache）</h3><p>你或许在源码中发现了 Cache cache;</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    uint32_t version;</span><br><span class="line">    uint32_t info;</span><br><span class="line">    uint32_t instance_size;</span><br><span class="line">    <span class="keyword">struct</span> old_ivar_list *ivars;</span><br><span class="line">    <span class="keyword">struct</span> old_method_list **methodLists;</span><br><span class="line">    Cache cache;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看看它是什么样的结构体:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_cache &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask <span class="comment">/* total = mask + 1 */</span>                 OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> occupied                                    OBJC2_UNAVAILABLE;</span><br><span class="line">    Method buckets[<span class="number">1</span>]                                        OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到一个类中 有 一个存放方法列表的数据结构,那么它到底用来干嘛的呢?</p>
<p>一个 class 往往只有 20% 的函数会被经常调用，可能占总调用次数的 80% 。每个消息都需要遍历一次 objc_method_list 并不合理。如果把经常被调用的函数缓存下来，那可以大大提高函数查询的效率。这也就是 objc_class 中另一个重要成员 objc_cache 做的事情 - 再找到 foo 之后，把 foo 的 method_name 作为 key ，method_imp 作为 value 给存起来。当再次收到 foo 消息的时候，可以直接在 cache 里找到，避免去遍历 objc_method_list.<br>(Hash表的方法实现)</p>
<p>当Objective-C运行时通过跟踪它的isa指针检查对象时，它可以找到一个实现许多方法的对象。然而，你可能只调用它们的一小部分，并且每次查找时，搜索所有选择器的类分派表没有意义。所以类实现一个缓存，每当你搜索一个类分派表，并找到相应的选择器，它把它放入它的缓存。所以当objc_msgSend（）查找一个类的选择器，它首先搜索类缓存。这是基于这样的理论：如果你在类上调用一个消息，你可能以后再次调用该消息。所以如果我们考虑到这一点，这意味着如果我们有一个NSObject子类，名为MyObject并运行以下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyObject *obj &#x3D; [[MyObject alloc] init];</span><br><span class="line"></span><br><span class="line">@implementation MyObject</span><br><span class="line">-(id)init &#123;</span><br><span class="line">    if(self &#x3D; [super init])&#123;</span><br><span class="line">        [self setVarA:@”blah”];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>


<h2 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h2><blockquote>
<p>I’m sorry that I long ago coined the term “objects” for this topic because it gets many people to focus on the lesser idea. The big idea is “messaging” – that is what the kernal[sic] of Smalltalk is all about… The key in making great and growable systems is much more to design how its modules communicate rather than what their internal properties and behaviors should be.</p>
</blockquote>
<p>Alan Kay 曾多次强调 Smalltalk 的核心不是面向对象，面向对象只是 the lesser ideas，<strong>消息传递</strong> 才是 the big idea。</p>
<p>消息传递的关键藏于 objc_object 中的 isa 指针和 objc_class 中的 class dispatch table。</p>
<p>在 Objective-C 中，类、对象和方法都是一个 C 的结构体，从 objc/objc.h 头文件中，我们可以找到他们的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">    Class superclass;</span><br><span class="line">    const char *name;</span><br><span class="line">    uint32_t version;</span><br><span class="line">    uint32_t info;</span><br><span class="line">    uint32_t instance_size;</span><br><span class="line">    struct old_ivar_list *ivars;</span><br><span class="line">    struct old_method_list **methodLists;</span><br><span class="line">    Cache cache;</span><br><span class="line">    struct old_protocol_list *protocols;</span><br><span class="line">    &#x2F;&#x2F; CLS_EXT only</span><br><span class="line">    const uint8_t *ivar_layout;</span><br><span class="line">    struct old_class_ext *ext;</span><br><span class="line">    &#x2F;...&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>struct objc_ivar_list <em>ivars            OBJC2_UNAVAILABLE;  // 该类的成员变量链表<br>struct objc_method_list *</em>methodLists   OBJC2_UNAVAILABLE;  // 方法定义的链表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct old_ivar_list &#123;</span><br><span class="line">    int ivar_count;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    int space;</span><br><span class="line">#endif</span><br><span class="line">    &#x2F;* variable length structure *&#x2F;</span><br><span class="line">    struct old_ivar ivar_list[1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct old_method_list &#123;</span><br><span class="line">    void *obsolete;</span><br><span class="line"></span><br><span class="line">    int method_count;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    int space;</span><br><span class="line">#endif</span><br><span class="line">    &#x2F;* variable length structure *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 可变长的方法数组</span><br><span class="line">    struct old_method method_list[1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>objc_method_list 本质是一个有 objc_method 元素的可变长度的数组。一个 objc_method 结构体中有函数名，也就是SEL，有表示函数类型的字符串 (见 Type Encoding) ，以及函数的实现IMP。</p>
<blockquote>
<p>这里有一些你可能感兴趣的代码: Cache,protocol_List,class_extension</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_cache *Cache                             OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">#define CACHE_BUCKET_NAME(B)  ((B)-&gt;method_name)</span><br><span class="line">#define CACHE_BUCKET_IMP(B)   ((B)-&gt;method_imp)</span><br><span class="line">#define CACHE_BUCKET_VALID(B) (B)</span><br><span class="line">#ifndef __LP64__</span><br><span class="line">#define CACHE_HASH(sel, mask) (((uintptr_t)(sel)&gt;&gt;2) &amp; (mask))</span><br><span class="line">#else</span><br><span class="line">#define CACHE_HASH(sel, mask) (((unsigned int)((uintptr_t)(sel)&gt;&gt;3)) &amp; (mask))</span><br><span class="line">#endif</span><br><span class="line">struct objc_cache &#123;</span><br><span class="line">    unsigned int mask &#x2F;* total &#x3D; mask + 1 *&#x2F;                 OBJC2_UNAVAILABLE;</span><br><span class="line">    unsigned int occupied                                    OBJC2_UNAVAILABLE;</span><br><span class="line">    Method buckets[1]                                        OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct old_protocol_list &#123;</span><br><span class="line">    struct old_protocol_list *next;</span><br><span class="line">    long count;</span><br><span class="line">    struct old_protocol *list[1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct old_class_ext &#123;</span><br><span class="line">    uint32_t size;</span><br><span class="line">    const uint8_t *weak_ivar_layout;</span><br><span class="line">    struct old_property_list **propertyLists;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>好了 接下来让我们接触Runtime的核心机制，消息机制</strong></p>
<h3 id="消息发送的步骤"><a href="#消息发送的步骤" class="headerlink" title="消息发送的步骤"></a>消息发送的步骤</h3><ol>
<li>Check for ignored selectors (GC) and short-circuit.如果 selector 是需要被忽略的垃圾回收用到的方法，则将 IMP 结果设为 _objc_ignored_method，这是个汇编程序入口，可以理解为一个标记。(OSX)</li>
<li>Check for nil target.检查对象是否为nil<ul>
<li>If nil &amp; nil receiver handler configured, jump to handler</li>
<li>If nil &amp; no handler (default), cleanup and return.</li>
</ul>
</li>
<li>Search the class’s method cache for the method IMP 在cache 中查找IMP<ul>
<li>If found, jump to it.找到，跳转到相应的内存地址</li>
<li>Not found: lookup the method IMP in the class itself 未找到，在类的method_list中查找<ul>
<li>If found, jump to it.找到，跳转</li>
<li>If not found, jump to forwarding mechanism.未找到，进入消息分发的步骤</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="消息分发的步骤"><a href="#消息分发的步骤" class="headerlink" title="消息分发的步骤"></a>消息分发的步骤</h3><ul>
<li>在对象类的 dispatch table 中尝试找到该消息。如果找到了，跳到相应的函数IMP去执行实现代码；</li>
<li>如果没有找到，Runtime 会发送 +resolveInstanceMethod: 或者 +resolveClassMethod: 尝试去 resolve 这个消息；</li>
<li>如果 resolve 方法返回 NO，Runtime 就发送 -forwardingTargetForSelector: 允许你把这个消息转发给另一个对象；</li>
<li>如果没有新的目标对象返回， Runtime 就会发送 -methodSignatureForSelector: 和 -forwardInvocation: 消息。你可以发送 -invokeWithTarget: 消息来手动转发消息或者发送 -doesNotRecognizeSelector: 抛出异常。</li>
</ul>
<ol>
<li>resolveInstanceMethod/resolveClassMethod 方法解析，这里可以动态添加方法（添加了即可返回YES)</li>
<li>forwardingTargetForSelector 把Selector 转发给其他实例响应</li>
<li>methodSignatureForSelector,invokeWithTarget,doesNotRecognizeSelector 添加方法签名，让其他实例来处理方法的调用</li>
</ol>
<blockquote>
<p>关于objc_msgSend函数<br>事实上，在编译时你写的 Objective-C 函数调用的语法都会被翻译成一个 C 的函数调用 - objc_msgSend() 。</p>
</blockquote>
<p><strong>关于消息分发三个步骤的Example:</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  第一步</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功解析的实例方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> + (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span></span><br><span class="line"><span class="comment"> NSString *selectorString = NSStringFromSelector(sel);</span></span><br><span class="line"><span class="comment"> if ([selectorString isEqualToString:@&quot;mysteriousMethod&quot;]) &#123;</span></span><br><span class="line"><span class="comment"> class_addMethod(self.class, @selector(mysteriousMethod), (IMP)functionForMethod1, &quot;@:&quot;);</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> return [super resolveInstanceMethod:sel];</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  在没有找到方法时，会先调用此方法，可用于动态添加方法</span></span><br><span class="line"><span class="comment">//  返回 YES 表示相应 selector 的实现已经被找到并添加到了类中，否则返回 NO</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  第二步</span></span><br><span class="line"><span class="comment">//  如果第一步的返回 NO 或者直接返回了 YES 而没有添加方法，该方法被调用</span></span><br><span class="line"><span class="comment">//  在这个方法中，我们可以指定一个可以返回一个可以响应该方法的对象</span></span><br><span class="line"><span class="comment">//  如果返回 self 就会死循环</span></span><br><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(aSelector == <span class="keyword">@selector</span>(xxx:))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.alternateObject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  第三步</span></span><br><span class="line"><span class="comment">//  如果 `forwardingTargetForSelector:` 返回了 nil，则该方法会被调用，系统会询问我们要一个合法的『类型编码(Type Encoding)』</span></span><br><span class="line"><span class="comment">//  若返回 nil，则不会进入下一步，而是无法处理消息</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="string">&quot;v@:&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当实现了此方法后，-doesNotRecognizeSelector: 将不会被调用</span></span><br><span class="line"><span class="comment">// 如果要测试找不到方法，可以注释掉这一个方法</span></span><br><span class="line"><span class="comment">// 在这里进行消息转发</span></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    <span class="comment">// 我们还可以改变方法选择器</span></span><br><span class="line">    [anInvocation setSelector:<span class="keyword">@selector</span>(notFind)];</span><br><span class="line">    <span class="comment">// 改变方法选择器后，还需要指定接受者</span></span><br><span class="line">    [anInvocation invokeWithTarget:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)notFind &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;没有实现 -mysteriousMethod 方法，并且成功的转成了 -notFind 方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>你可能忽略了一个细节 V-Table</strong><br>如果你学过C++，你可能会了解到Hybrid vTable Dispatch（虚拟表分发）.<br>你可以参考我的这篇文章<a target="_blank" rel="noopener" href="https://junyixie.github.io/2017/04/29/Swift-方法调用/">iOS 调用机制</a></p>
<h3 id="Hybrid-vTable-Dispatch"><a href="#Hybrid-vTable-Dispatch" class="headerlink" title="Hybrid vTable Dispatch"></a>Hybrid vTable Dispatch</h3><p>新的 Objc-runtime-new.m 这样写到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***********************************************************************</span><br><span class="line">* vtable dispatch</span><br><span class="line">*</span><br><span class="line">* Every class gets a vtable pointer. The vtable is an array of IMPs.</span><br><span class="line">* The selectors represented in the vtable are the same for all classes</span><br><span class="line">*   (i.e. no class has a bigger or smaller vtable).</span><br><span class="line">* Each vtable index has an associated trampoline which dispatches to</span><br><span class="line">*   the IMP at that index for the receiver class&#39;s vtable (after</span><br><span class="line">*   checking for NULL). Dispatch fixup uses these trampolines instead</span><br><span class="line">*   of objc_msgSend.</span><br><span class="line">* Fragility: The vtable size and list of selectors is chosen at launch</span><br><span class="line">*   time. No compiler-generated code depends on any particular vtable</span><br><span class="line">*   configuration, or even the use of vtable dispatch at all.</span><br><span class="line">* Memory size: If a class&#39;s vtable is identical to its superclass&#39;s</span><br><span class="line">*   (i.e. the class overrides none of the vtable selectors), then</span><br><span class="line">*   the class points directly to its superclass&#39;s vtable. This means</span><br><span class="line">*   selectors to be included in the vtable should be chosen so they are</span><br><span class="line">*   (1) frequently called, but (2) not too frequently overridden. In</span><br><span class="line">*   particular, -dealloc is a bad choice.</span><br><span class="line">* Forwarding: If a class doesn&#39;t implement some vtable selector, that</span><br><span class="line">*   selector&#39;s IMP is set to objc_msgSend in that class&#39;s vtable.</span><br><span class="line">* +initialize: Each class keeps the default vtable (which always</span><br><span class="line">*   redirects to objc_msgSend) until its +initialize is completed.</span><br><span class="line">*   Otherwise, the first message to a class could be a vtable dispatch,</span><br><span class="line">*   and the vtable trampoline doesn&#39;t include +initialize checking.</span><br><span class="line">* Changes: Categories, addMethod, and setImplementation all force vtable</span><br><span class="line">*   reconstruction for the class and all of its subclasses, if the</span><br><span class="line">*   vtable selectors are affected.</span><br><span class="line">**********************************************************************&#x2F;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">static const char * const defaultVtable[] &#x3D; &#123;</span><br><span class="line">    &quot;allocWithZone:&quot;,</span><br><span class="line">    &quot;alloc&quot;,</span><br><span class="line">    &quot;class&quot;,</span><br><span class="line">    &quot;self&quot;,</span><br><span class="line">    &quot;isKindOfClass:&quot;,</span><br><span class="line">    &quot;respondsToSelector:&quot;,</span><br><span class="line">    &quot;isFlipped&quot;,</span><br><span class="line">    &quot;length&quot;,</span><br><span class="line">    &quot;objectForKey:&quot;,</span><br><span class="line">    &quot;count&quot;,</span><br><span class="line">    &quot;objectAtIndex:&quot;,</span><br><span class="line">    &quot;isEqualToString:&quot;,</span><br><span class="line">    &quot;isEqual:&quot;,</span><br><span class="line">    &quot;retain&quot;,</span><br><span class="line">    &quot;release&quot;,</span><br><span class="line">    &quot;autorelease&quot;,</span><br><span class="line">&#125;;</span><br><span class="line">static const char * const defaultVtableGC[] &#x3D; &#123;</span><br><span class="line">    &quot;allocWithZone:&quot;,</span><br><span class="line">    &quot;alloc&quot;,</span><br><span class="line">    &quot;class&quot;,</span><br><span class="line">    &quot;self&quot;,</span><br><span class="line">    &quot;isKindOfClass:&quot;,</span><br><span class="line">    &quot;respondsToSelector:&quot;,</span><br><span class="line">    &quot;isFlipped&quot;,</span><br><span class="line">    &quot;length&quot;,</span><br><span class="line">    &quot;objectForKey:&quot;,</span><br><span class="line">    &quot;count&quot;,</span><br><span class="line">    &quot;objectAtIndex:&quot;,</span><br><span class="line">    &quot;isEqualToString:&quot;,</span><br><span class="line">    &quot;isEqual:&quot;,</span><br><span class="line">    &quot;hash&quot;,</span><br><span class="line">    &quot;addObject:&quot;,</span><br><span class="line">    &quot;countByEnumeratingWithState:objects:count:&quot;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Runtime 通过 vTable 的方式 加速调用类的常用方法。</strong></p>
<h2 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h2><p>但是category则完全不一样，它是在运行期决议的。<br>就category和extension的区别来看，我们可以推导出一个明显的事实，extension可以添加实例变量，而category是无法添加实例变量的（因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的）</p>
<h3 id="category和-load方法"><a href="#category和-load方法" class="headerlink" title="-category和+load方法"></a>-category和+load方法</h3><p>我们知道，在类和category中都可以有+load方法，那么有两个问题：<br>1)、在类的+load方法调用的时候，我们可以调用category中声明的方法么？<br>2)、这么些个+load方法，调用顺序是咋样的呢？</p>
<p>1)、可以调用，因为附加category到类的工作会先于+load方法的执行<br>2)、+load的执行顺序是先类，后category，而category的+load执行顺序是根据编译顺序决定的。</p>
<blockquote>
<p>部分内容引用和翻译自<br><a target="_blank" rel="noopener" href="http://www.friday.com/bbum/2009/12/18/objc_msgsend-part-1-the-road-map/">http://www.friday.com/bbum/2009/12/18/objc_msgsend-part-1-the-road-map/</a><br><a target="_blank" rel="noopener" href="http://cocoasamurai.blogspot.com/2010/01/understanding-objective-c-runtime.html">http://cocoasamurai.blogspot.com/2010/01/understanding-objective-c-runtime.html</a></p>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2017-01-24T11:27:06.000Z" title="2017-01-24T11:27:06.000Z">2017-01-24</time></span><span class="level-item">Updated&nbsp;<time dateTime="2018-05-26T11:27:59.000Z" title="2018-05-26T11:27:59.000Z">2018-05-26</time></span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a></span><span class="level-item">44 minutes read (About 6590 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/01/24/iOS-Core-Animation%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/">iOS Core Animation性能调优 笔记</a></h1><div class="content"><h2 id="高效绘图"><a href="#高效绘图" class="headerlink" title="高效绘图"></a>高效绘图</h2><h3 id="一些关键词"><a href="#一些关键词" class="headerlink" title="一些关键词"></a>一些关键词</h3><h3 id="软件绘图"><a href="#软件绘图" class="headerlink" title="软件绘图"></a>软件绘图</h3><p>上下文：指代软件绘图（意即：不由GPU协助 的绘图）软件绘图通常是由Core Graphics框架完成来完成</p>
<blockquote>
<p>绘制速度 OpenGL&gt;Core Animation&gt;Core Graphics</p>
</blockquote>
<ul>
<li>消耗可观的内存<br>  CALayer 只需要一些与自己相关 的内存：只有它的寄宿图会消耗一定的内存空间。即使直接赋给 contents 属性一 张图片，也不需要增加额外的照片存储大小。如果相同的一张图片被多个图层作 为 contents 属性，那么他们将会共用同一块内存，而不是复制内存块。<br>如果你实现了</li>
<li>-drawLayer:inContext:</li>
<li>-drawRect:<br>这两个方法中的任意一个方法，图层就创建了了一个绘制上下文，这个上下文需要的大小的内存可从这个算式得出：图层宽<em>图 层高</em>4字节，宽高的单位均为像素。对于一个在Retina iPad上的全屏图层来说，这 个内存量就是 2048<em>1526</em>4字节，相当于12MB内存，图层每次重绘的时候都需要 重新抹掉内存然后重新分配。<blockquote>
<p>你应该避免重绘你的视图。提高绘制性能 的秘诀就在于尽量避免去绘制。</p>
</blockquote>
</li>
</ul>
<h3 id="矢量图形"><a href="#矢量图形" class="headerlink" title="矢量图形"></a>矢量图形</h3><p>我们用Core Graphics来绘图的一个通常原因就是只是用图片或是图层效果不能</p>
<p>轻易地绘制出矢量图形。矢量绘图包含一下这些：</p>
<ul>
<li>任意多边形（不仅仅是一个矩形）</li>
<li>斜线或曲线</li>
<li>文本</li>
<li>渐变</li>
</ul>
<p>Core Animation为这些图形类型的绘制提供了专门的类，并给他们提供硬件支持 （第六章『专有图层』有详细提到）。 CAShapeLayer 可以绘制多边形，直线和 曲线。 CATextLayer 可以绘制文本。 CAGradientLayer 用来绘制渐变。这些总<br>体上都比Core Graphics更快，同时他们也避免了创造一个寄宿图。</p>
<h3 id="脏矩形"><a href="#脏矩形" class="headerlink" title="脏矩形"></a>脏矩形</h3><p>，Mac OS和iOS设备将会把屏幕区分为需要重绘的区域和 不需要重绘的区域。那些需要重绘的部分被称作『脏区域』。在实际应用中，鉴于 非矩形区域边界裁剪和混合的复杂性，通常会区分出包含指定视图的矩形位置，而 这个位置就是『脏矩形』。<br>但是Core Animation通常并不了 解你的自定义绘图代码，它也不能自己计算出脏区域的位置。然而，你的确可以提 供这些信息。</p>
<p>当你检测到指定视图或图层的指定部分需要被重绘，你直接调用 - setNeedsDisplayInRect: 来标记它，然后将影响到的矩形作为参数传入。这样就</p>
<p>会在一次视图刷新时调用视图的</p>
<ul>
<li>-drawRect:</li>
</ul>
<p>图层代理的</p>
<ul>
<li>-drawLayer:inContext:</li>
</ul>
<h3 id="异步绘制"><a href="#异步绘制" class="headerlink" title="异步绘制"></a>异步绘制</h3><p>UIKit的单线程天性意味着寄宿图通畅要在主线程上更新，这意味着绘制会打断用 户交互，甚至让整个app看起来处于无响应状态。<br>针对这个问题，有一些方法可以用到：一些情况下，我们可以推测性地提前在另 外一个线程上绘制内容，然后将由此绘出的图片直接设置为图层的内容。这实现起 来可能不是很方便，但是在特定情况下是可行的。Core Animation提供了一些选 择： CATiledLayer 和 drawsAsynchronously 属性。</p>
<h2 id="图像IO"><a href="#图像IO" class="headerlink" title="图像IO"></a>图像IO</h2><p><strong>优化从闪存驱动器或者网络中加载和显示图片</strong></p>
<h3 id="加载和潜伏"><a href="#加载和潜伏" class="headerlink" title="加载和潜伏"></a>加载和潜伏</h3><ul>
<li>加载</li>
<li>解压</li>
</ul>
<h4 id="线程加载"><a href="#线程加载" class="headerlink" title="线程加载"></a>线程加载</h4><ol>
<li>图像加载的优化 异步加载图片，避免主线程堵塞</li>
</ol>
<p>注意事项，异步加载图片造成的问题</p>
<p>   由于视图在UICollectionView会被循环利用，我们加载图片的时候不能确定是否被不同的索引重新复用。为了避免图片加载到错误的视图中，我们在加载前把单元格打上索引的标签，然后在设置图片的时候检测标签是否发生了改变。+</p>
<h4 id="延迟解压"><a href="#延迟解压" class="headerlink" title="延迟解压"></a>延迟解压</h4><pre><code>当加载图片的时候，iOS通常会延迟解压图片的时间，直到加载到内存之后。这就会在准备绘制图片的时候影响性能，因为需要在绘制之前进行解压</code></pre><ul>
<li><p>+imageNamed: 这个方法会在加载图片后立刻解压,但是只对应用资源束中的图片有效</p>
</li>
<li><p>+imageWithContentsOfFile:会延迟解压图片的时间，直到加载到内存之后</p>
</li>
<li><p>另一种立刻加载图片的方法就是把它设置成图层内容，或者是UIImageView的image属性。不幸的是，这又需要在主线程执行，所以不会对性能有所提升。</p>
</li>
<li><p>第三种方式就是绕过UIKit，像下面这样使用ImageIO框架：</p>
</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSInteger</span> index = indexPath.row;</span><br><span class="line"><span class="built_in">NSURL</span> *imageURL = [<span class="built_in">NSURL</span> fileURLWithPath:<span class="keyword">self</span>.imagePaths[index]];</span><br><span class="line"><span class="built_in">NSDictionary</span> *options = @&#123;(__bridge <span class="keyword">id</span>)kCGImageSourceShouldCache: @YES&#125;;</span><br><span class="line"><span class="built_in">CGImageSourceRef</span> source = <span class="built_in">CGImageSourceCreateWithURL</span>((__bridge <span class="built_in">CFURLRef</span>)imageURL, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">CGImageRef</span> imageRef = <span class="built_in">CGImageSourceCreateImageAtIndex</span>(source, <span class="number">0</span>,(__bridge <span class="built_in">CFDictionaryRef</span>)options);</span><br><span class="line"><span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithCGImage:imageRef];</span><br><span class="line"><span class="built_in">CGImageRelease</span>(imageRef);</span><br><span class="line"><span class="built_in">CFRelease</span>(source);</span><br></pre></td></tr></table></figure>
<p>这样就可以使用kCGImageSourceShouldCache来创建图片，强制图片立刻解压，然后在图片的生命周期保留解压后的版本。</p>
<ul>
<li>最后一种方式就是使用UIKit加载图片，但是立刻会知道CGContext中去。图片必须要在绘制之前解压，所以就强制了解压的及时性。这样的好处在于绘制图片可以再后台线程（例如加载本身）执行，而不会阻塞UI。</li>
</ul>
<p>有两种方式可以为强制解压提前渲染图片：</p>
<ol>
<li>将图片的一个像素绘制成一个像素大小的CGContext。这样仍然会解压整张图片，但是绘制本身并没有消耗任何时间。这样的好处在于加载的图片并不会在特定的设备上为绘制做优化，所以可以在任何时间点绘制出来。同样iOS也就可以丢弃解压后的图片来节省内存了。</li>
<li>将整张图片绘制到CGContext中，丢弃原始的图片，并且用一个从上下文内容中新的图片来代替。这样比绘制单一像素那样需要更加复杂的计算，但是因此产生的图片将会为绘制做优化，而且由于原始压缩图片被抛弃了，iOS就不能够随时丢弃任何解压后的图片来节省内存了。</li>
</ol>
<p>需要注意的是苹果特别推荐了不要使用这些诡计来绕过标准图片解压逻辑（所以也是他们选择用默认处理方式的原因），但是如果你使用很多大图来构建应用，那如果想提升性能，就只能和系统博弈了。</p>
<p>如果不使用+imageNamed:，那么把整张图片绘制到CGContext可能是最佳的方式了。尽管你可能认为多余的绘制相较别的解压技术而言性能不是很高，但是新创建的图片（在特定的设备上做过优化）可能比原始图片绘制的更快。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="built_in">UICollectionViewCell</span> *)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView</span><br><span class="line">                  cellForItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//dequeue cell</span></span><br><span class="line">    <span class="built_in">UICollectionViewCell</span> *cell = [collectionView dequeueReusableCellWithReuseIdentifier:<span class="string">@&quot;Cell&quot;</span> forIndexPath:indexPath];</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//switch to background thread</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="comment">//load image</span></span><br><span class="line">        <span class="built_in">NSInteger</span> index = indexPath.row;</span><br><span class="line">        <span class="built_in">NSString</span> *imagePath = <span class="keyword">self</span>.imagePaths[index];</span><br><span class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithContentsOfFile:imagePath];</span><br><span class="line">        <span class="comment">//redraw image using device context</span></span><br><span class="line">        <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(imageView.bounds.size, <span class="literal">YES</span>, <span class="number">0</span>);</span><br><span class="line">        [image drawInRect:imageView.bounds];</span><br><span class="line">        image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">        <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">        <span class="comment">//set image on main thread, but only if index still matches up</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="keyword">if</span> (index == cell.tag) &#123;</span><br><span class="line">                imageView.image = image;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="CATiledLayer"><a href="#CATiledLayer" class="headerlink" title="CATiledLayer"></a>CATiledLayer</h4><p>如第6章“专用图层”中的例子所示，CATiledLayer可以用来异步加载和显示大型图片，而不阻塞用户输入。但是我们同样可以使用CATiledLayer在UICollectionView中为每个表格创建分离的CATiledLayer实例加载传动器图片，每个表格仅使用一个图层。<br>这样使用CATiledLayer有几个潜在的弊端：</p>
<ul>
<li>CATiledLayer的队列和缓存算法没有暴露出来，所以我们只能祈祷它能匹配我们的需求</li>
<li>CATiledLayer需要我们每次重绘图片到CGContext中，即使它已经解压缩，而且和我们单元格尺寸一样（因此可以直接用作图层内容，而不需要重绘）。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"><span class="meta">#import</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span>()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span> *imagePaths;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UICollectionView</span> *collectionView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//set up data</span></span><br><span class="line">    <span class="keyword">self</span>.imagePaths = [[<span class="built_in">NSBundle</span> mainBundle] pathsForResourcesOfType:<span class="string">@&quot;jpg&quot;</span> inDirectory:<span class="string">@&quot;Vacation Photos&quot;</span>];</span><br><span class="line">    [<span class="keyword">self</span>.collectionView registerClass:[<span class="built_in">UICollectionViewCell</span> <span class="keyword">class</span>] forCellWithReuseIdentifier:<span class="string">@&quot;Cell&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView numberOfItemsInSection:(<span class="built_in">NSInteger</span>)section</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.imagePaths count];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UICollectionViewCell</span> *)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView cellForItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//dequeue cell</span></span><br><span class="line">    <span class="built_in">UICollectionViewCell</span> *cell = [collectionView dequeueReusableCellWithReuseIdentifier:<span class="string">@&quot;Cell&quot;</span> forIndexPath:indexPath];</span><br><span class="line">    <span class="comment">//add the tiled layer</span></span><br><span class="line">    <span class="built_in">CATiledLayer</span> *tileLayer = [cell.contentView.layer.sublayers lastObject];</span><br><span class="line">    <span class="keyword">if</span> (!tileLayer) &#123;</span><br><span class="line">        tileLayer = [<span class="built_in">CATiledLayer</span> layer];</span><br><span class="line">        tileLayer.frame = cell.bounds;</span><br><span class="line">        tileLayer.contentsScale = [<span class="built_in">UIScreen</span> mainScreen].scale;</span><br><span class="line">        tileLayer.tileSize = <span class="built_in">CGSizeMake</span>(cell.bounds.size.width * [<span class="built_in">UIScreen</span> mainScreen].scale, cell.bounds.size.height * [<span class="built_in">UIScreen</span> mainScreen].scale);</span><br><span class="line">        tileLayer.delegate = <span class="keyword">self</span>;</span><br><span class="line">        [tileLayer setValue:@(indexPath.row) forKey:<span class="string">@&quot;index&quot;</span>];</span><br><span class="line">        [cell.contentView.layer addSublayer:tileLayer];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//tag the layer with the correct index and reload</span></span><br><span class="line">    tileLayer.contents = <span class="literal">nil</span>;</span><br><span class="line">    [tileLayer setValue:@(indexPath.row) forKey:<span class="string">@&quot;index&quot;</span>];</span><br><span class="line">    [tileLayer setNeedsDisplay];</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)drawLayer:(<span class="built_in">CATiledLayer</span> *)layer inContext:(<span class="built_in">CGContextRef</span>)ctx</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//get image index</span></span><br><span class="line">    <span class="built_in">NSInteger</span> index = [[layer valueForKey:<span class="string">@&quot;index&quot;</span>] integerValue];</span><br><span class="line">    <span class="comment">//load tile image</span></span><br><span class="line">    <span class="built_in">NSString</span> *imagePath = <span class="keyword">self</span>.imagePaths[index];</span><br><span class="line">    <span class="built_in">UIImage</span> *tileImage = [<span class="built_in">UIImage</span> imageWithContentsOfFile:imagePath];</span><br><span class="line">    <span class="comment">//calculate image rect</span></span><br><span class="line">    <span class="built_in">CGFloat</span> aspectRatio = tileImage.size.height / tileImage.size.width;</span><br><span class="line">    <span class="built_in">CGRect</span> imageRect = <span class="built_in">CGRectZero</span>;</span><br><span class="line">    imageRect.size.width = layer.bounds.size.width;</span><br><span class="line">    imageRect.size.height = layer.bounds.size.height * aspectRatio;</span><br><span class="line">    imageRect.origin.y = (layer.bounds.size.height - imageRect.size.height)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//draw tile</span></span><br><span class="line">    <span class="built_in">UIGraphicsPushContext</span>(ctx);</span><br><span class="line">    [tileImage drawInRect:imageRect];</span><br><span class="line">    <span class="built_in">UIGraphicsPopContext</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<pre><code>需要解释几点：</code></pre><p>CATiledLayer的tileSize属性单位是像素，而不是点，所以为了保证瓦片和表格尺寸一致，需要乘以屏幕比例因子。<br>在-drawLayer:inContext:方法中，我们需要知道图层属于哪一个indexPath以加载正确的图片。这里我们利用了CALayer的KVC来存储和检索任意的值，将图层和索引打标签。</p>
<h4 id="分辨率交换"><a href="#分辨率交换" class="headerlink" title="分辨率交换"></a>分辨率交换</h4><p>视网膜分辨率（根据苹果市场定义）代表了人的肉眼在正常视角距离能够分辨的最小像素尺寸。但是这只能应用于静态像素。当观察一个移动图片时，你的眼睛就会对细节不敏感，于是一个低分辨率的图片和视网膜质量的图片没什么区别了。+</p>
<p>如果需要快速加载和显示移动大图，简单的办法就是欺骗人眼，在移动传送器的时候显示一个小图（或者低分辨率），然后当停止的时候再换成大图。这意味着我们需要对每张图片存储两份不同分辨率的副本，但是幸运的是，由于需要同时支持Retina和非Retina设备，本来这就是普遍要做到的。<br>如果从远程源或者用户的相册加载没有可用的低分辨率版本图片，那就可以动态将大图绘制到较小的CGContext，然后存储到某处以备复用。<br>为了做到图片交换，我们需要利用UIScrollView的一些实现UIScrollViewDelegate协议的委托方法（和其他类似于UITableView和UICollectionView基于滚动视图的控件一样）：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView willDecelerate:(<span class="built_in">BOOL</span>)decelerate;</span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidEndDecelerating:(<span class="built_in">UIScrollView</span> *)scrollView;  </span><br></pre></td></tr></table></figure>

<p>你可以使用这几个方法来检测传送器是否停止滚动，然后加载高分辨率的图片。只要高分辨率图片和低分辨率图片尺寸颜色保持一致，你会很难察觉到替换的过程（确保在同一台机器使用相同的图像程序或者脚本生成这些图片）。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>如果有很多张图片要显示，最好不要提前把所有都加载进来，而是应该当移出屏幕之后立刻销毁。通过选择性的缓存，你就可以避免来回滚动时图片重复性的加载了。</p>
<h4 id="imageNamed-方法"><a href="#imageNamed-方法" class="headerlink" title="+imageNamed:方法"></a>+imageNamed:方法</h4><p>之前我们提到使用[UIImage imageNamed:]加载图片有个好处在于可以立刻解压图片而不用等到绘制的时候。但是[UIImage imageNamed:]方法有另一个非常显著的好处：它在内存中自动缓存了解压后的图片，即使你自己没有保留对它的任何引用。</p>
<p>对于iOS应用那些主要的图片（例如图标，按钮和背景图片），使用[UIImage imageNamed:]加载图片是最简单最有效的方式。在nib文件中引用的图片同样也是这个机制，所以你很多时候都在隐式的使用它。</p>
<p>但是[UIImage imageNamed:]并不适用任何情况。它为用户界面做了优化，但是并不是对应用程序需要显示的所有类型的图片都适用。有些时候你还是要实现自己的缓存机制，原因如下：</p>
<ul>
<li>[UIImage imageNamed:]方法仅仅适用于在应用程序资源束目录下的图片，但是大多数应用的许多图片都要从网络或者是用户的相机中获取，所以[UIImage imageNamed:]就没法用了。</li>
<li>[UIImage imageNamed:]缓存用来存储应用界面的图片（按钮，背景等等）。如果对照片这种大图也用这种缓存，那么iOS系统就很可能会移除这些图片来节省内存。那么在切换页面时性能就会下降，因为这些图片都需要重新加载。对传送器的图片使用一个单独的缓存机制就可以把它和应用图片的生命周期解耦。</li>
<li>[UIImage imageNamed:]缓存机制并不是公开的，所以你不能很好地控制它。例如，你没法做到检测图片是否在加载之前就做了缓存，不能够设置缓存大小，当图片没用的时候也不能把它从缓存中移除。</li>
</ul>
<h4 id="自定义缓存"><a href="#自定义缓存" class="headerlink" title="自定义缓存"></a>自定义缓存</h4><blockquote>
<p>构建一个所谓的缓存系统非常困难。菲尔 卡尔顿曾经说过：“在计算机科学中只有两件难事：缓存和命名”。</p>
</blockquote>
<p>如果要写自己的图片缓存的话，那该如何实现呢？让我们来看看要涉及哪些方面：</p>
<ul>
<li>选择一个合适的缓存键 - 缓存键用来做图片的唯一标识。如果实时创建图片，通常不太好生成一个字符串来区分别的图片。在我们的图片传送带例子中就很简单，我们可以用图片的文件名或者表格索引。</li>
<li>提前缓存 - 如果生成和加载数据的代价很大，你可能想当第一次需要用到的时候再去加载和缓存。提前加载的逻辑是应用内在就有的，但是在我们的例子中，这也非常好实现，因为对于一个给定的位置和滚动方向，我们就可以精确地判断出哪一张图片将会出现。</li>
<li>缓存失效 - 如果图片文件发生了变化，怎样才能通知到缓存更新呢？这是个非常困难的问题（就像菲尔 卡尔顿提到的），但是幸运的是当从程序资源加载静态图片的时候并不需要考虑这些。对用户提供的图片来说（可能会被修改或者覆盖），一个比较好的方式就是当图片缓存的时候打上一个时间戳以便当文件更新的时候作比较。</li>
<li>缓存回收 - 当内存不够的时候，如何判断哪些缓存需要清空呢？这就需要到你写一个合适的算法了。幸运的是，对缓存回收的问题，苹果提供了一个叫做NSCache通用的解决方案</li>
</ul>
<h4 id="NSCache"><a href="#NSCache" class="headerlink" title="NSCache"></a>NSCache</h4><p>NSCache和NSDictionary类似。你可以通过-setObject:forKey:和-object:forKey:方法分别来插入，检索。和字典不同的是，NSCache在系统低内存的时候自动丢弃存储的对象。</p>
<p>NSCache用来判断何时丢弃对象的算法并没有在文档中给出，但是你可以使用-setCountLimit:方法设置缓存大小，以及-setObject:forKey:cost:来对每个存储的对象指定消耗的值来提供一些暗示。</p>
<p>指定消耗数值可以用来指定相对的重建成本。如果对大图指定一个大的消耗值，<strong>那么缓存就知道这些物体的存储更加昂贵，于是当有大的性能问题的时候才会丢弃这些物体。</strong>你也可以用-setTotalCostLimit:方法来指定全体缓存的尺寸。</p>
<p>NSCache是一个普遍的缓存解决方案，我们创建一个比传送器案例更好的自定义的缓存类。（例如，我们可以基于不同的缓存图片索引和当前中间索引来判断哪些图片需要首先被释放）。但是NSCache对我们当前的缓存需求来说已经足够了；没必要过早做优化。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span>()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span> *imagePaths;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UICollectionView</span> *collectionView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//set up data</span></span><br><span class="line">    <span class="keyword">self</span>.imagePaths = [[<span class="built_in">NSBundle</span> mainBundle] pathsForResourcesOfType:<span class="string">@&quot;png&quot;</span> inDirectory:<span class="string">@&quot;Vacation Photos&quot;</span>];</span><br><span class="line">    <span class="comment">//register cell class</span></span><br><span class="line">    [<span class="keyword">self</span>.collectionView registerClass:[<span class="built_in">UICollectionViewCell</span> <span class="keyword">class</span>] forCellWithReuseIdentifier:<span class="string">@&quot;Cell&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView numberOfItemsInSection:(<span class="built_in">NSInteger</span>)section</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.imagePaths count];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIImage</span> *)loadImageAtIndex:(<span class="built_in">NSUInteger</span>)index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//set up cache</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSCache</span> *cache = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (!cache) &#123;</span><br><span class="line">        cache = [[<span class="built_in">NSCache</span> alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if already cached, return immediately</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = [cache objectForKey:@(index)];</span><br><span class="line">    <span class="keyword">if</span> (image) &#123;</span><br><span class="line">        <span class="comment">//如果为NSNull 这意味着，会有代码对其进行赋值，所以这里赋值一个nil,即可。不用担心，image 的赋值不会出现问题。</span></span><br><span class="line">        <span class="keyword">return</span> [image isKindOfClass:[<span class="built_in">NSNull</span> <span class="keyword">class</span>]]? <span class="literal">nil</span>: image;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设定为NSNull 后面的代码会在随后的执行中进行赋值</span></span><br><span class="line">    <span class="comment">//set placeholder to avoid reloading image multiple times</span></span><br><span class="line">    [cache setObject:[<span class="built_in">NSNull</span> null] forKey:@(index)];</span><br><span class="line">    <span class="comment">//switch to background thread</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>( dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="comment">//load image</span></span><br><span class="line">        <span class="built_in">NSString</span> *imagePath = <span class="keyword">self</span>.imagePaths[index];</span><br><span class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithContentsOfFile:imagePath];</span><br><span class="line">        <span class="comment">//redraw image using device context</span></span><br><span class="line">        <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(image.size, <span class="literal">YES</span>, <span class="number">0</span>);</span><br><span class="line">        [image drawAtPoint:<span class="built_in">CGPointZero</span>];</span><br><span class="line">        image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">        <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">        <span class="comment">//set image for correct image view</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123; <span class="comment">//cache the image</span></span><br><span class="line">            [cache setObject:image forKey:@(index)];</span><br><span class="line">            <span class="comment">//display the image</span></span><br><span class="line">            <span class="built_in">NSIndexPath</span> *indexPath = [<span class="built_in">NSIndexPath</span> indexPathForItem: index inSection:<span class="number">0</span>]; <span class="built_in">UICollectionViewCell</span> *cell = [<span class="keyword">self</span>.collectionView cellForItemAtIndexPath:indexPath];</span><br><span class="line">            <span class="built_in">UIImageView</span> *imageView = [cell.contentView.subviews lastObject];</span><br><span class="line">            imageView.image = image;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//not loaded yet</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UICollectionViewCell</span> *)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView cellForItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//dequeue cell</span></span><br><span class="line">    <span class="built_in">UICollectionViewCell</span> *cell = [collectionView dequeueReusableCellWithReuseIdentifier:<span class="string">@&quot;Cell&quot;</span> forIndexPath:indexPath];</span><br><span class="line">    <span class="comment">//add image view</span></span><br><span class="line">    <span class="built_in">UIImageView</span> *imageView = [cell.contentView.subviews lastObject];</span><br><span class="line">    <span class="keyword">if</span> (!imageView) &#123;</span><br><span class="line">        imageView = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:cell.contentView.bounds];</span><br><span class="line">        imageView.contentMode = <span class="built_in">UIViewContentModeScaleAspectFit</span>;</span><br><span class="line">        [cell.contentView addSubview:imageView];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//set or load image for this index</span></span><br><span class="line">    imageView.image = [<span class="keyword">self</span> loadImageAtIndex:indexPath.item];</span><br><span class="line">    <span class="comment">//preload image for previous and next index</span></span><br><span class="line">    <span class="keyword">if</span> (indexPath.item &lt; [<span class="keyword">self</span>.imagePaths count] - <span class="number">1</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> loadImageAtIndex:indexPath.item + <span class="number">1</span>]; &#125;</span><br><span class="line">    <span class="keyword">if</span> (indexPath.item &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> loadImageAtIndex:indexPath.item - <span class="number">1</span>]; &#125;</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>果然效果更好了！当滚动的时候虽然还有一些图片进入的延迟，但是已经非常罕见了。缓存意味着我们做了更少的加载。这里提前加载逻辑非常粗暴，其实可以把滑动速度和方向也考虑进来，但这已经比之前没做缓存的版本好很多了。</p>
<h2 id="图层性能"><a href="#图层性能" class="headerlink" title="图层性能"></a>图层性能</h2><h3 id="隐式绘制"><a href="#隐式绘制" class="headerlink" title="隐式绘制"></a>隐式绘制</h3><p><strong>寄宿图可以通过Core Graphics直接绘制</strong>，<strong>也可以直接载入一个图片文件并赋值 给 contents 属性</strong>，<strong>或事先绘制一个屏幕之外的 CGContext 上下文</strong>。在之前的两 章中我们讨论了这些场景下的优化。但是除了常见的显式创建寄宿图，你也可以通 过以下三种方式创建隐式的：1，使用特性的图层属性。2，特定的视图。3，特定 的图层子类。</p>
<h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><p>都是直接将文本绘制在图层的寄宿图中。事实上这 两种方式用了完全不同的渲染方式：在iOS 6及之前， UILabel 用WebKit的HTML 渲染引擎来绘制文本，而 CATextLayer 用的是Core Text.后者渲染更迅速，所以 在所有需要绘制大量文本的情形下都优先使用它吧。但是这两种方法都用了软件的 方式绘制，因此他们实际上要比硬件加速合成方式要慢。(iOS Text Kit)</p>
<p>CATextLayer和UILabel不论如何，尽可能地避免改变那些包含文本的视图的frame，因为这样做的话文 本就需要重绘。例如，如果你想在图层的角落里显示一段静态的文本，但是这个图 层经常改动，你就应该把文本放在一个子图层中。</p>
<h3 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h3><p>在第四章『视觉效果』中我们提到了 CALayer 的 shouldRasterize 属性，它 可以解决重叠透明图层的混合失灵问题。同样在第12章『速度的曲调』中，它也是 作为绘制复杂图层树结构的优化方法。</p>
<p>启用 shouldRasterize 属性会将图层绘制到一个屏幕之外的图像。然后这个图 像将会被缓存起来并绘制到实际图层的 contents 和子图层。如果有很多的子图层 或者有复杂的效果应用，这样做就会比重绘所有事务的所有帧划得来得多。但是光 栅化原始图像需要时间，而且还会消耗额外的内存。（shouldRasterize，如果视图加载内容经常变化，会大量消耗内存和CPU 导致掉帧）</p>
<p>当我们使用得当时，光栅化可以提供很大的性能优势（如你在第12章所见），但 是一定要避免作用在内容不断变动的图层上，否则它缓存方面的好处就会消失，而 且会让性能变的更糟。</p>
<h3 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h3><p>当图层属性的混合体被指定为在未预合成之前不能直接在屏幕中绘制时，屏幕外 渲染就被唤起了。屏幕外渲染并不意味着软件绘制，<strong>但是它意味着图层必须在被显 示之前在一个屏幕外上下文中被渲染（不论CPU还是GPU）</strong>。图层的以下属性将会 触发屏幕外绘制：</p>
<ul>
<li>圆角</li>
<li>图层蒙版</li>
<li>阴影</li>
</ul>
<p>屏幕外渲染和我们启用光栅化时相似，除了它并没有像光栅化图层那么消耗大， <strong>子图层并没有被影响到，而且结果也没有被缓存</strong>，所以不会有长期的内存占用。但 是，如果太多图层在屏幕外渲染依然会影响到性能。</p>
<p>有时候我们可以把那些需要屏幕外绘制的图层开启光栅化以作为一个优化方式， 前提是这些图层并不会被频繁地重绘。</p>
<p>对于那些需要动画而且要在屏幕外渲染的图层来说，你可以用 CAShapeLayer ，contentsCenter，shadowPath 较少地影响到性能。</p>
<h4 id="CAShapeLayer"><a href="#CAShapeLayer" class="headerlink" title="CAShapeLayer"></a>CAShapeLayer</h4><pre><code>cornerRadius和maskToBounds独立作用的时候都不会有太大的性能问题，但是当他俩结合在一起，就触发了屏幕外渲染。有时候你想显示圆角并沿着图层裁切子图层的时候，你可能会发现你并不需要沿着圆角裁切，这个情况下用CAShapeLayer就可以避免这个问题了。2

你想要的只是圆角且沿着矩形边界裁切，同时还不希望引起性能问题。其实你可以用现成的UIBezierPath的构造器+bezierPathWithRoundedRect:cornerRadius:（见清单15.1）.这样做并不会比直接用cornerRadius更快，但是它避免了性能问题。</code></pre><h3 id="混合和过度绘制"><a href="#混合和过度绘制" class="headerlink" title="混合和过度绘制"></a>混合和过度绘制</h3><pre><code>在第12章有提到，GPU每一帧可以绘制的像素有一个最大限制（就是所谓的fill rate），这个情况下可以轻易地绘制整个屏幕的所有像素。但是如果由于重叠图层的关系需要不停地重绘同一区域的话，掉帧就可能发生了。
**GPU会放弃绘制那些完全被其他图层遮挡的像素**，但是要计算出一个图层是否被遮挡也是相当复杂并且会消耗处理器资源。同样，合并不同图层的透明重叠像素（即混合）消耗的资源也是相当客观的。所以为了加速处理进程，不到必须时刻不要使用透明图层。任何情况下，你应该这样做：
- 给视图的backgroundColor属性设置一个固定的，不透明的颜色
- 设置opaque属性为YES
这样做减少了混合行为（因为编译器知道在图层之后的东西都不会对最终的像素颜色产生影响）并且计算得到了加速，避免了过度绘制行为因为Core Animation可以舍弃所有被完全遮盖住的图层，而不用每个像素都去计算一遍。
如果用到了图像，尽量避免透明除非非常必要。如果图像要显示在一个固定的背景颜色或是固定的背景图之前，你没必要相对前景移动，你只需要预填充背景图片就可以避免运行时混色了。
如果是文本的话，一个白色背景的UILabel（或者其他颜色）会比透明背景要更高效。
最后，明智地使用shouldRasterize属性，可以将一个固定的图层体系折叠成单张图片，这样就不需要每一帧重新合成了，也就不会有因为子图层之间的混合和过度绘制的性能问题了。</code></pre><h3 id="减少图层数量"><a href="#减少图层数量" class="headerlink" title="减少图层数量"></a>减少图层数量</h3></div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="xiejunyi"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">xiejunyi</p><p class="is-size-6 is-block">底层码农</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>BeiJing</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">32</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">6</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/junyixie" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/junyixie"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://maimai.cn/contact/detail/179426899" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">脉脉</span></span><span class="level-right"><span class="level-item tag">maimai.cn</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/APM/"><span class="level-start"><span class="level-item">APM</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Hook/"><span class="level-start"><span class="level-item">Hook</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/iOS/"><span class="level-start"><span class="level-item">iOS</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><span class="level-start"><span class="level-item">源码分析</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%A0%94%E5%8F%91%E6%B5%81%E7%A8%8B/"><span class="level-start"><span class="level-item">研发流程</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/"><span class="level-start"><span class="level-item">设计架构</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-02-19T12:45:55.000Z">2021-02-19</time></p><p class="title"><a href="/2021/02/19/behind-thread-local/">behind __thread. __thread实现原理</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-01-25T12:52:56.000Z">2021-01-25</time></p><p class="title"><a href="/2021/01/25/cpython-mutilcore/">cpython mutilcore 实现</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-12-10T13:57:17.000Z">2020-12-10</time></p><p class="title"><a href="/2020/12/10/clang-add-option/">clang添加命令行参数</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-11-22T08:32:37.000Z">2020-11-22</time></p><p class="title"><a href="/2020/11/22/fix-ffi-ios14-2crash/">修复ffi ios 14.2 crash</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-04-09T16:26:43.000Z">2020-04-10</time></p><p class="title"><a href="/2020/04/10/objcblockimp/">imp_implementationWithBlock 的内部实现 trampoline</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">February 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">January 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">December 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/11/"><span class="level-start"><span class="level-item">November 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/04/"><span class="level-start"><span class="level-item">April 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/03/"><span class="level-start"><span class="level-item">March 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/02/"><span class="level-start"><span class="level-item">February 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/11/"><span class="level-start"><span class="level-item">November 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/10/"><span class="level-start"><span class="level-item">October 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">September 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/09/"><span class="level-start"><span class="level-item">September 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/06/"><span class="level-start"><span class="level-item">June 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/04/"><span class="level-start"><span class="level-item">April 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/01/"><span class="level-start"><span class="level-item">January 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/12/"><span class="level-start"><span class="level-item">December 2017</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/10/"><span class="level-start"><span class="level-item">October 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/09/"><span class="level-start"><span class="level-item">September 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/05/"><span class="level-start"><span class="level-item">May 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/04/"><span class="level-start"><span class="level-item">April 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/02/"><span class="level-start"><span class="level-item">February 2017</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/01/"><span class="level-start"><span class="level-item">January 2017</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">xiejunyi&#039;s Blog</a><p class="is-size-7"><span>&copy; 2021 junyixie</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>